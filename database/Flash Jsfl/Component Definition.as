jsfl to add parameter to library componentFinally ,I did all I can do to find out that there is noly a way to achive it.1.Create an empty .xfl file in your extendsion.2.Use jsfl to open it when user want to add "Component definition" of items in library.3.Use jsfl copy the item into .xfl and save the .xfl.4.Go to .xfl saved folder and find the item's .xml you want edit.Read the .xml file and edit the "Component definition".Then save the .xml.5.Reopen the .xfl you can find the "Component definition" has been changed.6.Copy the changed item to user document(.fla),it can replace the old one.The 6 steps above just need jsfl and a empty .xfl in your extendsions or save in the location that you can find it on run time.I had thought that why Adobe didn't give me a simple API to change the "Component definition" just like what I do in Flash.exe?OR //write class on run time and load it to componentpackage myPackage {  import flash.display.MovieClip;  public class MyComponent extends MovieClip {    [Inspectable]    public var myFancyComponentParameter:String;    [Inspectable]    public var myOtherFancyComponentParameter:int;  }}// package and import statements omitted for brevitypublic class MyComponent extends MovieClip {  [Inspectable]  public var myFancyComponentParameter:String;  public function MyComponent() {    // myFancyComponentParameter not set here yet    trace(myFancyComponentParameter); // prints null    addEventListener(Event.INIT, onInit);  }  public function onInit(e:Event) {    // now we can use component parameters!    trace(myFancyComponentParameter); // prints the param value  }}stage_item.addEventListener(Event.INIT, initComponent)//About the Inspectable tagWhen determining which parameters to reveal in the authoring environment, Flash uses the Inspectable tag. The syntax for this tag is as follows:[Inspectable(value_type=value[,attribute=value,...])]property_declaration name:type;The following example defines the enabled parameter as inspectable:[Inspectable(defaultValue=true, verbose=1, category="Other")]var enabled:Boolean;The Inspectable tag also supports loosely typed attributes like this:[Inspectable("danger", 1, true, maybe)]The metadata statement must immediately precede the property's variable declaration in order to be bound to that property.The following table describes the attributes of the Inspectable tag: AttributeTypeDescriptiondefaultValueString or Number(Optional) A default value for the inspectable property.enumerationString(Optional) Specifies a comma-delimited list of legal values for the property.listOffsetNumber(Optional) Added for backward compatibility with Flash MX components. Used as the default index into a List value.nameString(Optional) A display name for the property. For example, Font Width. If not specified, use the property's name, such as _fontWidth.typeString(Optional) A type specifier. If omitted, use the property's type. The following values are acceptable:ArrayBooleanColorFont NameListNumberObjectStringvariableString(Optional) Added for backward compatibility with Flash MX components. Specifies the variable that this parameter is bound to.verboseNumber(Optional) An inspectable property that has the verbose attribute set to 1 does not appear in the Property inspector but does appear in the Component inspector. This is typically used for properties that are not modified frequently.None of these attributes are required; you can use Inspectable as the metadata tag.All properties of the superclass that are marked Inspectable are automatically inspectable in the current class. Use the InspectableList tag if you want to hide some of these properties for the current class. PUse the Event tag to define events that the component emits.This tag has the following syntax:[Event("event_name")]For example, the following code defines a click event:[Event("click")]Add the Event statements outside the class definition in the ActionScript file so that the events are bound to the class and not a particular member of the class.//About the InspectableList tagUse the InspectableList tag to specify which subset of inspectable properties should appear in the Property inspector. Use InspectableList in combination with Inspectable so that you can hide inherited attributes for components that are subclasses. If you do not add an InspectableList tag to your component's class, all inspectable parameters, including those of the component's parent classes, appear in the Property inspector.The InspectableList syntax is as follows:[InspectableList("attribute1"[,...])]// class definitionThe InspectableList tag must immediately precede the class definition because it applies to the entire class.The following example allows the flavorStr and colorStr properties to be displayed in the Property inspector, but excludes other inspectable properties from the Parent class:[InspectableList("flavorStr","colorStr")]class BlackDot extends DotParent {[Inspectable(defaultValue="strawberry")]public var flavorStr:String;[Inspectable(defaultValue="blue")]public var colorStr:String;...} //About the Event tagThe following example shows the Event metadata for the UIObject class, which handles the resize, move, and draw events:...import mx.events.UIEvent;[Event("resize")][Event("move")][Event("draw")]class mx.core.UIObject extends MovieClip {...}To broadcast a particular instance, call the dispatchEvent() method. See Using the dispatchEvent() method.//About the Bindable tagData binding connects components to each other. You achieve visual data binding through the Bindings tab of the Component inspector. From there, you add, view, and remove bindings for a component.Although data binding works with any component, its main purpose is to connect user interface components to external data sources, such as web services and XML documents. These data sources are available as components with properties, which you can bind to other component properties.Use the Bindable tag before a property in an ActionScript class to make the property appear in the Bindings tab in the Component inspector. You can declare a property by using var or getter/setter methods. If a property has both a getter and a setter method, you only need to apply the Bindable tag to one.The Bindable tag has the following syntax:[Bindable "readonly"|"writeonly",type="datatype"]Both attributes are optional.The following example defines the variable flavorStr as a property that is accessible on the Bindings tab of the Component inspector:[Bindable]public var flavorStr:String = "strawberry";The Bindable tag takes three options that specify the type of access to the property, as well as the data type of that property. The following table describes these options: OptionDescriptionreadonlyIndicates that when you create bindings in the Component inspector, you can only create bindings that use this property as a source. However, if you use ActionScript to create bindings, there is no such restriction.[Bindable("readonly")]writeonlyIndicates that when you create bindings in the Component inspector, this property can only be used as the destination of a binding. However, if you use ActionScript to create bindings, there is no such restriction.[Bindable("writeonly")]type="datatype"Indicates the type that data binding uses for the property. The rest of Flash uses the declared type.If you do not specify this option, data binding uses the property's data type as declared in the ActionScript code.In the following example, data binding will treat x as type DataProvider, even though it is really type Object:[Bindable(type="DataProvider")]var x: Object; All properties of all components can participate in data binding. The Bindable tag merely controls which of those properties are available for binding in the Component inspector. If a property is not preceded by the Bindable tag, you can still use it for data binding, but you have to create the bindings using ActionScript.The Bindable tag is required when you use the ChangeEvent tag. For more information, see About the ChangeEvent tag.//About the ChangeEvent tagThe ChangeEvent tag tells data binding that the component will generate an event any time the value of a specific property changes. In response to the event, data binding executes any binding that has that property as a source. The component only generates the event if you write appropriate ActionScript code in the component. The event should be included in the list of Event metadata declared by the class.You can declare a property by using var or getter/setter methods. If a property has both a getter and a setter method, you only need to apply the ChangeEvent tag to one.The ChangeEvent tag has the following syntax:[Bindable][ChangeEvent("event")]property_declaration or getter/setter functionIn the following example, the component generates the change event when the value of the bindable property flavorStr changes:[Bindable][ChangeEvent("change")]public var flavorStr:String;When the event that is specified in the metadata occurs, Flash notifies bindings that the property has changed.You can register multiple events in the tag, as the following example shows:[ChangeEvent("change1", "change2", "change3")]Any one of those events indicates a change to the property. They do not all have to occur to indicate a change.//About the Collection tagUse the Collection tag to describe an array of objects that can be modified as a collection of items in the Values dialog box while authoring. The type of the objects is identified by the collectionItem attribute. A collection property contains a series of collection items that you define in a separate class. This class is either mx.utils.CollectionImpl or a subclass of it. The individual objects are accessed through the methods of the class identified by the collectionClass attribute.A collection property in the Component inspector and the Values dialog box that appears when you click the magnifying glass.The syntax for the Collection tag is as follows:[Collection (name="name", variable="varname", collectionClass="mx.utils.CollectionImpl", collectionItem="coll-item-classname", identifier="string")]public var varname:mx.utils.Collection;The following table describes the attributes of the Collection tag: AttributeTypeDescriptionnameString(Required) Name that appears in the Component inspector for the collection.variableString(Required) ActionScript variable that points to the underlying Collection object (for example, you might name a Collection parameter Columns, but the underlying variable attribute might be __columns).collectionClassString(Required) Specifies the class type to be instantiated for the collection property. This is usually mx.utils.CollectionImpl, but it can also be a class that extends mx.utils.CollectionImpl.collectionItemString(Required) Specifies the class of the collection items to be stored within the collection. This class includes its own inspectable properties that are exposed through metadata.identifierString(Required) Specifies the name of an inspectable property within the collection item class that Flash MX uses as the default identifier when the user adds a new collection item through the Values dialog box. Each time a user creates a new collection item, Flash MX sets the item name to identifier plus a unique index (for example, if identifier=name, the Values dialog box displays name0, name1, name2, and so on).