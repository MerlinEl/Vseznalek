https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#printing_the_contents_of_an_array//Syntax// Arrow functionforEach((element) => { ... } )forEach((element, index) => { ... } )forEach((element, index, array) => { ... } )// Callback functionforEach(callbackFn)forEach(callbackFn, thisArg)// Inline callback functionforEach(function callbackFn(element) { ... })forEach(function callbackFn(element, index) { ... })forEach(function callbackFn(element, index, array){ ... })forEach(function callbackFn(element, index, array) { ... }, thisArg)//Polyfill// Production steps of ECMA-262, Edition 5, 15.4.4.18// Reference: https://es5.github.io/#x15.4.4.18if (!Array.prototype['forEach']) {  Array.prototype.forEach = function(callback, thisArg) {    if (this == null) { throw new TypeError('Array.prototype.forEach called on null or undefined'); }    var T, k;    // 1. Let O be the result of calling toObject() passing the    // |this| value as the argument.    var O = Object(this);    // 2. Let lenValue be the result of calling the Get() internal    // method of O with the argument "length".    // 3. Let len be toUint32(lenValue).    var len = O.length >>> 0;    // 4. If isCallable(callback) is false, throw a TypeError exception.    // See: https://es5.github.io/#x9.11    if (typeof callback !== "function") { throw new TypeError(callback + ' is not a function'); }    // 5. If thisArg was supplied, let T be thisArg; else let    // T be undefined.    if (arguments.length > 1) { T = thisArg; }    // 6. Let k be 0    k = 0;    // 7. Repeat, while k < len    while (k < len) {      var kValue;      // a. Let Pk be ToString(k).      //    This is implicit for LHS operands of the in operator      // b. Let kPresent be the result of calling the HasProperty      //    internal method of O with argument Pk.      //    This step can be combined with c      // c. If kPresent is true, then      if (k in O) {        // i. Let kValue be the result of calling the Get internal        // method of O with argument Pk.        kValue = O[k];        // ii. Call the Call internal method of callback with T as        // the this value and argument list containing kValue, k, and O.        callback.call(T, kValue, k, O);      }      // d. Increase k by 1.      k++;    }    // 8. return undefined  };}//Examplesconst arraySparse = [1,3,,7]let numCallbackRuns = 0arraySparse.forEach(function(element) {  console.log(element)  numCallbackRuns++})console.log("numCallbackRuns: ", numCallbackRuns)// 1// 3// 7// numCallbackRuns: 3// comment: as you can see the missing value between 3 and 7 didn't invoke callback function.const items = ['item1', 'item2', 'item3']const copyItems = []// beforefor (let i = 0; i < items.length; i++) {  copyItems.push(items[i])}// afteritems.forEach(function(item){  copyItems.push(item)})function logArrayElements(element, index, array) {  console.log('a[' + index + '] = ' + element)}// Notice that index 2 is skipped, since there is no item at// that position in the array...[2, 5, , 9].forEach(logArrayElements)// logs:// a[0] = 2// a[1] = 5// a[3] = 9function Counter() {  this.sum = 0  this.count = 0}Counter.prototype.add = function(array) {  array.forEach(function countEntry(entry) {    this.sum += entry    ++this.count  }, this)}const obj = new Counter()obj.add([2, 5, 9])obj.count// 3obj.sum// 16function copy(obj) {  const copy = Object.create(Object.getPrototypeOf(obj))  const propNames = Object.getOwnPropertyNames(obj)  propNames.forEach(function(name) {    const desc = Object.getOwnPropertyDescriptor(obj, name)    Object.defineProperty(copy, name, desc)  })  return copy}const obj1 = { a: 1, b: 2 }const obj2 = copy(obj1) // obj2 looks like obj1 nowlet words = ['one', 'two', 'three', 'four']words.forEach(function(word) {  console.log(word)  if (word === 'two') {    words.shift() //'one' will delete from array  }}) // one // two // fourconsole.log(words);  //['two', 'three', 'four']function flatten(arr) {  const result = []  arr.forEach(function(i) {    if (Array.isArray(i)) {      result.push(...flatten(i))    } else {      result.push(i)    }  })  return result}// Usageconst nested = [1, 2, 3, [4, 5, [6, 7], 8, 9]]flatten(nested) // [1, 2, 3, 4, 5, 6, 7, 8, 9]