-------------------------------------------------------------------------------- LS3DDataManager.ms-- Illusion Softworks-- http://www.illusionsoftworks.com-- Copyright (c) 2004-2012 Illusion Softworks & 2KCzech. All Rights Reserved---- By Antonin Hildebrand & Vladimir Zadrazil & Radek Sevcik & Jiri Bicik-------------------------------------------------------------------------------------------------------------------------------------------------------------- GLOBALS------------------------------------------------------------------------------global LS3DDataManagerVersionglobal gLS3DDataManagerVersionUI = undefinedglobal sUserDataScript = undefined-------------------------------------------------------------------------------- TIMER------------------------------------------------------------------------------struct sTimer(	begin	= 0,	end		= 0,	------------------------------------------------------------------------------	fn getSeconds =	(		local data = filterString localTime " ";		local data = filterString data[data.count] ":";		data[4] = 0		if (data.count == 3) then		(				  data[4]  = data[1] as integer * 24 * 60		  data[4] += data[2] as integer * 60				  data[4] += data[3] as integer		)				return data[4]	),	------------------------------------------------------------------------------	fn start =	(		setWaitCursor()		begin = getSeconds()	),	fn stop =	(		end = getSeconds()		setArrowCursor()	),	------------------------------------------------------------------------------	fn print = return (end - begin))-------------------------------------------------------------------------------- Object for collecting source codes of CAs (bucket types) from diskstruct sUserDataScriptCollector(	typeSeparator	= ":",	pathSeparator	= "~",		scripts			= #(),		fn GetAllScriptsCount = 	(		return scripts.count	),		fn GetAllScriptsFullNames = 	(		local result = #()		for script in scripts do		(			append result script.fullName		)		return result	),		fn GetScriptByName name =	(		for script in scripts do		(			if (script.name == name) then			(				return script;			)		)				return ();	),	fn GetScriptByFullName fullName =	(		for script in scripts do		(			if (script.fullName == fullName) then			(				return script;			)		)				return ();	),			fn GetScriptIndexByName myName =	(		local idx = 0;		for index = 1 to scripts.count do		(			--print "------------------------------------------------------------------------------"			--print scripts[index].name			if (scripts[index].name == myName) then			(				idx = index;				--format "return Index = %\n" idx;			)		)				return idx;	),		------------------------------------------------------------------------------	fn separate fullName =	(		-- separate type and name (name is in format "type:id~name", where ? is one char specifying attribute type)		local dataScript = sUserDataScript();		dataScript.fullname = fullName;				local typeSeparatorIdx = findString fullName typeSeparator;		if (typeSeparatorIdx == undefined) then		(			typeSeparatorIdx = 0;		)				local namePath = subString fullName (typeSeparatorIdx+1) -1;		local names = filterString namePath pathSeparator;		dataScript.name = names[names.count]; -- the last part of path is used as name				--build short name from capital letters of name		local characterCount = dataScript.name.count;		if (characterCount < 3) then		( -- the name is not long, use it as it is			dataScript.shortName = dataScript.name;		)		else		(			local upperName = toUpper dataScript.name; -- for comparsion to the original name, I didn't find other way to detect uppercase characters			dataScript.shortName = dataScript.name[1] as string; -- always use the 1st character			for i = 2 to characterCount do			(				if (upperName[i] == dataScript.name[i]) then				(					dataScript.shortName += upperName[i] as string;				)			)						if (dataScript.shortName.count ==1) then			( -- only the first character is used				dataScript.shortName += dataScript.name[2] as string; -- we add the second character to make the short name unique			)		)				return dataScript;	),		------------------------------------------------------------------------------	fn fetchState xfile =	(		local infile = xfile as string		local searchfor = "attributes "		local start = findstring infile searchfor				if (start == 0 or start == undefined) then			return #("", "???")					start = start + searchfor.count + 1				local s = ""		for i = start to infile.count do		(			if (infile[i] == "'") then exit			s = s + infile[i]		)				return (separate(s))	),		------------------------------------------------------------------------------	fn readInfile fname =	(		local infile = "" as stringstream;		local myfile = openfile fname; 		while not eof myfile do		(			format "%\n" (readline myfile) to:infile;		)				close myfile;				return infile;	),		fn CompareDataScriptNames item1 item2 =	(		if (item1.name == item2.name) then return 0;		if (item1.name < item2.name) then return -1;		return 1;	),		-- sort data infos according to names	fn SortDataScripts =	(		qsort scripts CompareDataScriptNames;	),		------------------------------------------------------------------------------	fn process dir =	(		local files = getFiles (dir + "\\*.ms");		for file in files do 		(			local source = readInfile(file) as string;			local dataScript = fetchState(source);			dataScript.sourceCode = source;			dataScript.fileName = file;			dataScript.CreateParams();			append scripts dataScript;		) -- for file				SortDataScripts(); -- sort scripts here to speed up later filling of listbox	),		------------------------------------------------------------------------------	fn clear =	(		scripts	= #();	))---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- creates custom attribute accordinto attribute scource code, adds it to the node and returns itfn AddCustomAttributeToNode sourceCode targetNode =(	local customAttributeDef = execute(sourceCode);	if (customAttributeDef == undefined) then		return();		custAttributes.add targetNode customAttributeDef;		for caIdx = 1 to custAttributes.count targetNode do	( -- find the CA ve have just created		local ca = custattributes.get targetNode caIdx;		local caDef = custattributes.getDef ca;		if (customAttributeDef.name == caDef.name) then		(			return ca;		)	) -- for caIdx		return();)---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- removes custom attribute from object by indexfn RemoveCustomAttributeFromNode targetNode index =(	local result = true	try (		custAttributes.delete targetNode index	) catch ( result = false )	return result)------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ Adds Custom Attribute data to object by CA name-- Can be used as standalone function in any other scripts--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------fn AddCustomAttributeByName obj CustAttribName = (	local returnValue = false	local typeSeparator	= ":"	local pathSeparator	= "~"		local scriptCollector	= sUserDataScriptCollector typeSeparator pathSeparator	scriptCollector.clear();	scriptCollector.process("$scripts\\LS3DData");			local currentBucket = scriptCollector.GetScriptByName(CustAttribName)		-- otestuj jestli uz neexistuje	local isExisting = false	local count = custAttributes.count obj	for caIndex = 1 to count do	(		local ca = custAttributes.get obj caIndex		if (ca.name == currentBucket.fullName) do		(			isExisting = true			return returnValue		)	) -- for caIndex		if (isExisting == false) then	( -- this bucket does not exist, let' create new one		returnValue = true		local newCA = AddCustomAttributeToNode currentBucket.sourceCode obj	)	return returnValue)---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- If Custom Attribute specified by CA name is on object it returns index of this object. Othervise it returns 0-- Can be used as standalone function in any other scripts--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------fn IsCustomAttributeByName obj CustAttribName = (	local typeSeparator	= ":"	local pathSeparator	= "~"		local scriptCollector	= sUserDataScriptCollector typeSeparator pathSeparator	scriptCollector.clear();	scriptCollector.process("$scripts\\LS3DData");			local currentBucket = scriptCollector.GetScriptByName(CustAttribName)		local count = custAttributes.count obj	local result = 0	for caIndex = 1 to count do	(		local ca = custAttributes.get obj caIndex		if (ca.name == currentBucket.fullName) then (			result = caIndex			exit		)	) -- for caIndex		return result)---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- Return if Custom Attribute specified by CA name is on object-- Can be used as standalone function in any other scripts--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------fn GetCustomAttributesCount obj = (	local result = 0	local typeSeparator	= ":"	local pathSeparator	= "~"		local scriptCollector	= undefined 	scriptCollector = sUserDataScriptCollector typeSeparator pathSeparator	scriptCollector.clear();	scriptCollector.process("$scripts\\LS3DData");		local scriptsCount = scriptCollector.GetAllScriptsCount()	local scriptNames = scriptCollector.GetAllScriptsFullNames()		-- otestuj jestli uz neexistuje	local count = custAttributes.count obj	for caIndex = 1 to count do	(		local caName = (custAttributes.get obj caIndex).name		for scriptIndex = 1 to scriptsCount do (			if (caName == scriptNames[scriptIndex]) then result = result + 1		)	) -- for caIndex		return result)---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- Adds Custom Attribute data to object by CA name-- Can be used as standalone function in any other scripts--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------fn GetCustomAttributeByName obj CustAttribName = (	local result = undefined	local typeSeparator	= ":"	local pathSeparator	= "~"		local scriptCollector	= sUserDataScriptCollector typeSeparator pathSeparator	scriptCollector.clear();	scriptCollector.process("$scripts\\LS3DData");			local currentBucket = scriptCollector.GetScriptByName(CustAttribName)		-- otestuj jestli uz neexistuje	local isExisting = false	local count = custAttributes.count obj	for caIndex = 1 to count do	(		local ca = custAttributes.get obj caIndex		if (ca.name == currentBucket.fullName) do		(			isExisting = true			return (ca.params)		)	) -- for caIndex		return undefined)---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- Clears all Custom Attributes from object-- Can be used as standalone function in any other scripts--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------fn ClearCustomAttributes obj = (	local result = true	local typeSeparator	= ":"	local pathSeparator	= "~"		local scriptCollector	= sUserDataScriptCollector typeSeparator pathSeparator	scriptCollector.clear();	scriptCollector.process("$scripts\\LS3DData");			local scriptsCount = scriptCollector.GetAllScriptsCount()	local scriptNames = scriptCollector.GetAllScriptsFullNames()		-- otestuj jestli uz neexistuje	local count = custAttributes.count obj	local indexToClear = #()	for caIndex = 1 to count do	(		local caName = (custAttributes.get obj caIndex).name		for scriptIndex = 1 to scriptsCount do (			if (caName == scriptNames[scriptIndex]) then append indexToClear caIndex		)	)	for i = indexToClear.count to 1 by -1 do (		if (not RemoveCustomAttributeFromNode obj indexToClear[i]) then result = false	)	return result)------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ STRUCTURES-------------------------------------------------------------------------------- default parameter of custAttribute of sUserDataScriptstruct sDataScriptAttrParameter(	name				= "",	defaultValue	= undefined)-- script for custom attribute (bucket type)struct sUserDataScript(	fileName		= "", -- from this file the script has been loaded	fullName		= "", -- name as is visible in custAttributes of MAX	name			= "", -- this name is displayed in ctrlBuckets and ctrlNodes	shortName	= "", -- name for ctrlNodes, it is used in case CA names are on the same line with node name	sourceCode	= "", -- source code of this CA, loaded from disk	custAttribute = undefined, -- here is stored the aggregated custattribute (it is created on a temp node)	params 			= #(), -- array of sDataScriptAttrParameter, parameters of custAttribute		fn CreateParams =	(		-- get parameter names and default values		-- note: we can't use getPropNames to get names of CA properties, because the names are different (ilegal characters are replaced by undescores, getProperty can't handle if this name begins with underscore)				local caDef = execute(sourceCode);		if (caDef == undefined) then		(			return();		)				local pbArray = custAttributes.getPBlockDefs caDef;		if (pbArray == undefined) then			return custAttribute;				for pbItem in pbArray do		(			for idx = 5 to pbItem.Count do			(				if (pbItem[idx].count <1) then					continue;				local parameterName = pbItem[idx][1] as string;				if (parameterName.count < 2) then					continue;								local newParameter = sDataScriptAttrParameter();				newParameter.name = parameterName;				append params newParameter;			) -- for idx		) -- for pbItem				),		-- get the MAX custom attribute in default state (properties are reset to default values)	fn GetFreshCustomAttribute =	(		if (custAttribute == undefined) then		( -- create new custom attribute			local tempNode = box(); -- we need a node to create the custom attributes on it			tempNode.name = "_ temp for DataManager. Delete me. " + tempNode.name; -- for the case the node stays in scene (e.g. error in max script)			custAttribute = AddCustomAttributeToNode sourceCode tempNode;			delete tempNode;			if (custAttribute == undefined) then			(				return();			)						-- get default values of parameters			for parameter in params do			(				parameter.defaultValue = getproperty custAttribute parameter.name ;			)					)		else		( -- reset existing custom attribute			for parameter in params do			(				setproperty custAttribute parameter.name parameter.defaultValue;			)		)				return custAttribute;	))-- this item can be displayed in ctrlNodesstruct sNodeInfo(	node				= undefined,	name				= "", -- we can get it from node, but this speeds up processing of nodes (e.g. sorting)	sortName		="", -- this name is used for sorting	displayedName = "", -- name for ctrlNodes (including indentation)	longDisplayedName = "", -- name for ctrlNodes (including indentation and shortNames of buckets)	treeLevel		= 0, -- depth in scene tree (used for coloring of the displayedName in ctrlNodes)	dataInfoString	= "", -- names of items in userDataInfos, this string can be used as toolTip	uid				= 0, -- index to nodesCollector	userDataInfos	= #(), -- array of sUserDataInfo	isVisible			= false, -- if node is in ctrlNodes	icon				= undefined)-- this item can be displayed in ctrlNodesstruct sUserDataInfo(	dataScript		= undefined, -- sUserDataScript for this CA (may be "undefined", if we have no script for this CA)	displayedName = "", -- name for ctrlNodes (including indentation)	fn GetShortName =	(		if (dataScript == undefined) then		(			return "??"		)				return dataScript.shortName	),		fn GetName = 	(		if (dataScript == undefined) then		(			return "??"		)				return dataScript.name	)	)-- this item is stored in sCaAggregator and is displayed in sroPropsstruct sAggregatedParameter(	name			= "",	value			= undefined,	isDifferent	= false -- this attribute is different in some node(s))-- this item is stored in sCaAggregator and is displayed in sroPropsstruct sAggregatedCA(	dataScript		= undefined, -- sUserDataScript for this CA	nodes		= #(), -- nodes with this custom attribute (but the value of this attribute may be different in some nodes)	params 		= #(), -- aggregated parameters of CA	CaAggregator = undefined,		-- callback from rollout	fn onParameterChange parameterName =	(--		print ("Parameter '" + parameterName + "' of '" + name + "' has been changed.")		local newValue = getproperty dataScript.custAttribute parameterName;				for aggregatedParameter in params do		(			if (aggregatedParameter.name == parameterName) then			(				aggregatedParameter.value = newValue;				aggregatedParameter.isDifferent = false;				for caNode in nodes do				(					if (isProperty caNode parameterName) then					(						setProperty caNode parameterName newValue;					)									)				exit;			)		) -- for aggregatedParameter	),		-- for rollout	fn IsParameterDifferent parameterName =	(		for aggregatedParameter in params do		(			if (aggregatedParameter.name == parameterName) then			(				return aggregatedParameter.isDifferent ;			)		) -- for aggregatedParameter				return false;	),		-- set tags properties to indicate state of CA	fn SetDialogTagProperties tag1 tag2 =	(		local someCAIsMissing = CaAggregator.nodesCount != nodes.count;		local someCAIsDifferent = false;		for caParam in params do		(			if (caParam.isDifferent) then			(				someCAIsDifferent = true;				exit;			)		)				if someCAIsMissing then		(			tag1.height = 5;			tag1.width = 600;			tag1.pos.x =0;			tag1.bitmap = CaAggregator.blueBitmap;			tag1.tooltip = "This attribute is missing on some nodes";		)		else		(			tag1.height = 0; -- setting the size to 0 is better than invisibility, it saves place in rolout		)				if someCAIsDifferent then		(			tag2.height = 5;			tag2.width = 600;			tag2.pos.x =0;			tag2.bitmap = CaAggregator.redBitmap;			tag2.tooltip = "This attribute is not the same on all nodes";		)		else		(			tag2.height = 0; -- setting the size to 0 is better than invisibility, it saves place in rolout		)	))-------------------------------------------------------------------------------- OBJECTS------------------------------------------------------------------------------struct sIndentator(	oneLevelIndentationString = "    ", -- text prefix for each indentation level in node tree	indentationStrings = #(),		fn BuildIndentationStrings maxLevel =	(		indentationStrings = #();		local currentString = "";		append indentationStrings currentString;		for i = 1 to maxLevel do		(			currentString = currentString + oneLevelIndentationString;			append indentationStrings currentString;		)	),		fn GetIndentationSring treeLevel =	(		if (treeLevel >= indentationStrings.count) then		( -- limit the indentation to keep names human readable			return indentationStrings[indentationStrings.count];		)		return indentationStrings[treeLevel + 1];	))global dataManagerIndentator;-- Object for collecting nodes selected in MAXstruct sNodesCollector(	infos = #(), -- list of sNodeInfo	dataScriptCollector, -- sUserDataScriptCollector		fn CreateUserDataInfo fullName indentationString =	(		local userDataInfo = sUserDataInfo();		userDataInfo.dataScript = dataScriptCollector.GetScriptByFullName fullName;				if (userDataInfo.dataScript == undefined) then		( -- this is unknown type of CA, we display it's name, but it can't be edited			userDataInfo.displayedName = indentationString + fullName;		)		else		(			userDataInfo.displayedName = indentationString + userDataInfo.dataScript.name;		)		return userDataInfo	),		------------------------------------------------------------------------------	fn CreateAllUserDataInfos nodeInfo treeLevel =	(		local caArray = custattributes.getdefs nodeInfo.node;		if (caArray == undefined) do			return();		local indentationString = dataManagerIndentator.GetIndentationSring(treeLevel + 1);		for c in caArray do 		(			local userDataInfo = CreateUserDataInfo (c.name as string) indentationString;			append nodeInfo.userDataInfos userDataInfo;		)	),		fn CompareDataInfoNames dataInfo1 dataInfo2 =	(		if (dataInfo1.displayedName == dataInfo2.displayedName) then return 0;		if (dataInfo1.displayedName < dataInfo2.displayedName) then return -1;		return 1;	),		-- sort data infos according to names	fn SortUserDataInfos userDataInfos =	(		qsort userDataInfos CompareDataInfoNames;	),		fn AddNode node treeLevel nodePath =	(		local nodeInfo = sNodeInfo();		nodeInfo.name = node.name;		nodeInfo.node = node;		nodeInfo.uid = infos.count + 1;		nodeInfo.treeLevel = treeLevel;		nodeInfo.sortName = nodePath; -- sorting according to nodePath keeps scene hierarchy of nodes		nodeInfo.icon = case (superclassof node) of		(			GeometryClass:	1			Light:			2			Camera:			3			Helper:			4			default:			1		)				CreateAllUserDataInfos nodeInfo treeLevel;		SortUserDataInfos nodeInfo.userDataInfos;				-- precompute names for ctrlNodes				local indentationString = dataManagerIndentator.GetIndentationSring(treeLevel);		nodeInfo.displayedName = indentationString + nodeInfo.name;		nodeInfo.longDisplayedName = nodeInfo.displayedName;		-- add acronyms of data in this node		local isFirstDataInfo = true;		for userDataInfo in nodeInfo.userDataInfos do		(			if (isFirstDataInfo == true) then			(				nodeInfo.longDisplayedName += "  >>  ";				isFirstDataInfo = false;			)			else			(				nodeInfo.longDisplayedName += "  ";				nodeInfo.dataInfoString += " + ";			)						nodeInfo.longDisplayedName += userDataInfo.GetShortName();			nodeInfo.dataInfoString += userDataInfo.GetName(); 		) -- for userDataInfo				append infos nodeInfo;	),		fn CompareNodeNames node1 node2 =	(		if (node1.sortName == node2.sortName) then return 0;		if (node1.sortName < node2.sortName) then return -1;		return 1;	),		-- sort infos according to sort name	fn SortInfos =	(		qsort infos CompareNodeNames;				-- recompute uid		local uid = 1;		for nodeInfo in infos do		(			nodeinfo.uid = uid;			uid += 1;		)	),		fn Clear =	(		infos = #();	))-- aggregates custom attributes from selected nodesstruct sCaAggregator(	dataScriptCollector, -- sUserDataScriptCollector	aggregatedCAs = #(), -- array of AggregatedCA	nodesCount = 0, -- this helps detect missing CA in some nodes	blueBitmap = bitmap 1 1 color:blue,	redBitmap = bitmap 1 1 color:red,		-- aggregate thisCA to thisAggregatedCA	fn AggregateCustomAttribute thisAggregatedCA thisCA =	(		-- note: we can't use getPropNames to get names of CA properties, because the names are different (ilegal characters are replaced by undescores, getProperty can't handle if this name begins with underscore)		if (thisAggregatedCA.dataScript == undefined) then		(			return();		)				for parameter in thisAggregatedCA.dataScript.params do		(			local parameterValue;			if (isProperty thisCA parameter.name) then			(				parameterValue = getproperty thisCA parameter.name;			)			else			( -- parameter is missing on 'thisCA' - this is legal for old version of CA				parameterValue = parameter.defaultValue;			)						local parameterExists = false;			for aggregatedParameter in thisAggregatedCA.params do			(				if (aggregatedParameter.name == parameter.name) then				( -- aggregate this parameter to the existing item in thisAggregatedCA.params					if (aggregatedParameter.value != parameterValue) then					(						aggregatedParameter.isDifferent = true;					)					parameterExists = true;					exit;				)			) -- for aggregatedParameter						if (parameterExists == false) then			( -- create new item in thisAggregatedCA.params				local newAggregatedParameter = sAggregatedParameter();				newAggregatedParameter.name = parameter.name;				newAggregatedParameter.value = parameterValue;				append thisAggregatedCA.params newAggregatedParameter;			)		) -- for parameter	),		fn CompareCAs CA1 CA2 =	(		if (CA1.dataScript.name ==  CA2.dataScript.name) then return 0;		if (CA1.dataScript.name <  CA2.dataScript.name) then return -1;		return 1;	),		-- sort data infos according to names	fn SortCAs =	(		qsort aggregatedCAs CompareCAs;	),		-- aggregate CA from nodes selected in ctrlNodes	fn AggregateByNodes nodes =	(		aggregatedCAs = #();		nodesCount = nodes.count;		for currentNode in nodes do		(						local caCount = custattributes.count currentNode.node;			for caIdx = 1 to caCount do 			(				local ca = custattributes.get currentNode.node caIdx;								-- test if this CA is in aggregatedCAs already				local caExists = false;				for aggregatedCA in aggregatedCAs do				(					if (aggregatedCA.dataScript.fullName == ca.name) then					( -- aggregate this CA to the existing item in aggregatedCAs						AggregateCustomAttribute aggregatedCA ca;						append aggregatedCA.nodes currentNode.node;						caExists = true;						exit;					)				)								if (caExists == false) then				( -- create new item in aggregatedCAs					local newAggregatedCA = sAggregatedCA();					newAggregatedCA.dataScript = dataScriptCollector.GetScriptByFullName ca.name;					if (newAggregatedCA.dataScript == undefined) then					(						continue;					)					newAggregatedCA.CaAggregator = this;										AggregateCustomAttribute newAggregatedCA ca;					append newAggregatedCA.nodes currentNode.node;					append aggregatedCAs newAggregatedCA;				) -- caExists == false			) -- for caIdx		) -- currentNode		SortCAs();	),		-- add rollouts for all items in aggregatedCAszz to the parentSubRollout	fn ShowCustomAttributes parentSubRollout =	(		if (aggregatedCAs.count == 0) then			return();				-- switch command panel from "modify "to "create", otherwise the rollout would be created in the "modify" panel		if (cui.commandPanelOpen == true and			getCommandPanelTaskMode() == #modify) do			setCommandPanelTaskMode #create;				for aggregatedCA in aggregatedCAs do		(/*						format "aggregatedCA: '%', nodesCount: %, paramsCount: %\n" aggregatedCA.dataScript.name aggregatedCA.nodes.count aggregatedCA.params.count;			for aggregatedParam in aggregatedCA.params do				format "\tparam: %, is different: %, value: %\n" aggregatedParam.name aggregatedParam.isDifferent aggregatedParam.value;-- */									if (aggregatedCA.dataScript == undefined) then			(				continue;			)						local maxCustomAttribute = aggregatedCA.dataScript.GetFreshCustomAttribute(); -- custom attribute of MAX			if (maxCustomAttribute == undefined) then				continue;						-- if a param is the same in all nodes, set his value to rollout			for param in aggregatedCA.params do			(				if (param.isDifferent or (param.value == undefined)) then					continue;				if (isProperty maxCustomAttribute param.name) then				(					setProperty maxCustomAttribute param.name param.value;				)			)						-- set aggregted CA descriptor - rollout needs aggregation info and callbacks			if ((isProperty maxCustomAttribute "aggregatedCADescriptor") == false) then			(				messageBox ("The custom attribute '" + aggregatedCA.dataScript.name + "' doesn't support aggregation. You have to modify script of this attribute. Property 'aggregatedCADescriptor' is missing.") title:"Error";				continue;			)			maxCustomAttribute.aggregatedCADescriptor = aggregatedCA;						addSubRollout parentSubRollout maxCustomAttribute.params as string;				) -- for aggregatedCA	),		-- set aggregated parameters (the same in all nodes) to the CA	fn SetAggregatedPropertiesToCA targetCA =	(		for aggregatedCA in aggregatedCAs do		(			if (aggregatedCA.dataScript.fullName != targetCA.name) then				continue;						for param in aggregatedCA.params do			(				if (param.isDifferent or (param.value == undefined)) then					continue;				if (isProperty targetCA param.name) then				(					setProperty targetCA param.name param.value;				)			)						exit;		) -- for aggregatedCA	),		-- create copy of current aggregated CAs to "target". CAs can be filtered by bucketFilter. Returns true if "target" was (or would be) changed	fn CopyCAs &target bucketFilter:undefined testOnly:false =	(		local newTarget = #();		local returnValue = false;		for aggregatedCA in aggregatedCAs do		(			if (bucketFilter != undefined) then			(				local existsInFilter = false;				for bucket in bucketFilter do				(					if (bucket == aggregatedCA.dataScript) then					(						existsInFilter = true;						exit;					)									) -- for bucket								if (existsInFilter == false) then				( -- this CA is disabled by filter					continue;				)			)						-- try to find this CA in current "target"			local currentTargetCA = undefined;			for targetCA in target do			(				if (targetCA.dataScript == aggregatedCA.dataScript) then				(					currentTargetCA = targetCA;					exit;				)			)									if (currentTargetCA == undefined) then			( -- this CA doesn't exist in current "target"				if (testOnly == true) then				( -- we already know something would be changed					return true;				)				returnValue = true;			)						-- deep copy this CA to "newTarget"  (because we need snapshot of current state)			local newCA = sAggregatedCA();			newCA.dataScript = aggregatedCA.dataScript;			-- because we will not affect a nodes directly, we do not copy properties "nodes" and "CaAggregator"						for sourceParam in aggregatedCA.params do			( -- copy the parameters and test if they differ				local newAggregatedParameter = sAggregatedParameter();				newAggregatedParameter.name = sourceParam.name;				newAggregatedParameter.value = sourceParam.value;				newAggregatedParameter.isDifferent = sourceParam.isDifferent;				append newCA.params newAggregatedParameter;								if (currentTargetCA != undefined) then				(					for currentTargetParam in currentTargetCA.params do					(						if (currentTargetParam.name != sourceParam.name) then						(							continue;						)						if ((currentTargetParam.value != sourceParam.value) or (currentTargetParam.isDifferent != sourceParam.isDifferent)) then						(							if (testOnly == true) then							( -- we already know something would be changed								return true;							)							returnValue = true;							exit;						)					) -- for currentTargetParam				)			) -- for sourceParam						append newTarget newCA;								) -- for aggregatedCA		if (target.count != newTarget.count) then		( -- maybe there are more CAs in "target" than in "newTarget"			returnValue = true;		)				if (testOnly == false) then		(			target = newTarget;		)		return returnValue;	),		fn PasteCAs &source targetNodes:undefined testOnly:false =	(		local returnValue = false;		for aggregatedCA in source do		(			for currentNode in targetNodes do			(				-- test if this bucket is added to the node alreday				local targetCA = undefined;				local count = custAttributes.count currentNode.node;				for caIndex = 1 to count do				(					local ca = custAttributes.get currentNode.node caIndex;					if (ca.name == aggregatedCA.dataScript.fullName) do					(						targetCA = ca;						exit;					)				) -- for caIndex								if (targetCA == undefined) then				( -- this bucket does not exist, let' create new one					if (testOnly == true) then					( -- we already know something would be changed						return true;					)					returnValue = true;										targetCA = AddCustomAttributeToNode aggregatedCA.dataScript.sourceCode currentNode.node;				)								if (targetCA != undefined) then				( -- set the parameters, if necessary					for param in aggregatedCA.params do					(						if (param.isDifferent or (param.value == undefined)) then						(							continue;						)												if (isProperty targetCA param.name) then						(							if (getProperty targetCA param.name == param.value) then							(								continue;							)							if (testOnly == true) then							( -- we already know something would be changed								return true;							)							returnValue = true;														setProperty targetCA param.name param.value;						)					) -- for sourceParam				)			) -- for currentNode		) -- for aggregatedCA				return returnValue;	))-------------------------------------------------------------------------------- Object for collecting CA from nodesstruct sUserDataCollector(	typeSeparator	= ":",	pathSeparator	= "~",	--	uid				= 0,	------------------------------------------------------------------------------	fn findData root str =	(		for d in root do		(			if (d.name == str) do				return d		)				return()	),	------------------------------------------------------------------------------	fn createPlainData str node =	(		uid += 1				local data		= sUserDataInfo()		data.fullname	= str		data.name		= str		data.uid		= uid		data.node		= node				return data	),	------------------------------------------------------------------------------	fn separate nodeInfo str =	(		-- separate type and name (name is in format "type:id~name", where ? is one char specifying attribute type)		local userDataInfo = sUserDataInfo()		-- save unique id		uid += 1		userDataInfo.uid = uid				-- find tokens		local idx1 = findString str typeSeparator		local idx2 = findString str pathSeparator		-- save data type		if (idx1 != undefined) then			userDataInfo.type = subString str 1 (idx1-1)		else			idx1 = 1				-- save data id		if (idx2 != undefined) then			userDataInfo.id = subString str (idx1+1) (idx2-idx1-1)		else			idx2 = idx1		-- save full name		userDataInfo.fullname = str		-- save full path		userDataInfo.path = subString str (idx2 + 1) -1		-- save simple name		local names	= filterString userDataInfo.path pathSeparator;		userDataInfo.name = names[names.count];				userDataInfo.node = nodeInfo.node				-- check if we need to process path		if (count == 1) do		(			append nodeInfo.userDataInfos userDataInfo			return()		)		-- we need to save new data into correct branch		local xxx = findData nodeInfo.userDataInfos data[1]		if (xxx == undefined) do		(			xxx = createPlainData data[1] nodeInfo.node			append nodeInfo.userDataInfos xxx		)		count -= 1		for n = 2 to count do		(			yyy = findData xxx.userDataInfos data[n]			if (yyy == undefined) do			(				yyy = createPlainData data[1] nodeInfo.node				append xxx.userDataInfos yyy				xxx = yyy			)		)				append xxx.userDataInfos userDataInfo		return userDataInfo	),	------------------------------------------------------------------------------	fn createUserDataInfo nodeInfo =	(		uid += 1		nodeInfo.uid = uid				caArray = custattributes.getdefs nodeInfo.node		if caArray == undefined do			return false		for ca in caArray do 			separate nodeInfo (ca.name as string)					return true	),	------------------------------------------------------------------------------	fn clear =	(		uid = 0	))-------------------------------------------------------------------------------- DIALOG------------------------------------------------------------------------------rollout dlgLS3DDataManager ("LS3D Data Manager v"+LS3DDataManagerVersion)(	------------------------------------------------------------------------------------	-- locals		local iniFile			= (LS3DGUP.LS3DGUP.UtilsPath + "\\LS3DDataManager.ini")	local typeSeparator	= ":"	local pathSeparator	= "~"	local scriptCollector	= sUserDataScriptCollector typeSeparator pathSeparator;	local nodesCollector	= sNodesCollector();	local caAggregator	= sCaAggregator();	local preClone			= 0		local rowsY			= #(8, 8+16+16+8, 8+16+16+8+ 30*16+2 +8, 8+16+16+8+ 30*16+2 +8+16+8, 8+16+16+8+ 30*16+2 +8+16+8 +8+16+8)	local bucketsX		= 8	local functionsX	= bucketsX + 208 + 8	local nodesX			= functionsX + 32 + 8	local dataX			= nodesX + 208 + 8		local currentSelectedBucketsTags = #(); -- listView tags of currently selected items in ctrlBuckets	local currentSelectedNodesTags = #(); -- listView tags of currently selected items in ctrlNodes	local initialSelectedBuckets = ""; -- for save/load of bucket selection to ini file	local clipboard = #(); -- array of AggregatedCA for copy/paste	local imageListObject;	------------------------------------------------------------------------------------	-- UI	label			lblSelected			""				pos:[bucketsX, rowsY[1]] width:250	label			lblCredits			""				pos:[nodesX, rowsY[1]] width:300	editText		edtFilterBuckets	"" 				pos:[bucketsX-5,rowsY[2] - 18] width:214	dotNetControl	ctrlBuckets			"System.Windows.Forms.ListView" pos:[bucketsX, rowsY[2]] width:208 height:(rowsY[3]-rowsY[2]-4) enabled:true releaseOnClose:true setupEvents:true	button			btnRefreshScripts	"Refresh"		pos:[bucketsX, rowsY[3]] width:64 height:18 toolTip:"Reloadl bucket definitions from disk";	button			btnSelectAllBuckets	"Select all"		pos:[bucketsX+64+8, rowsY[3]] width:64 height:18 enabled:false;	button			btnEditScript		"Edit Script"	pos:[bucketsX+64+8+64+8, rowsY[3]] width:64 height:18 toolTip:"Edit script of one selected bucket" enabled:false;	button			btnAddBucket		">"			pos:[functionsX,56] width:32 height:20 toolTip:"Add selected bucket(s) to selected node(s)" enabled:false;	button			btnRemoveBucket		"<"		pos:[functionsX,80] width:32 height:20 toolTip:"Remove selected bucket(s) from selected node(s)" enabled:false;	button			btnRemoveAllBuckets	"<<"		pos:[functionsX,160] width:32 height:20 toolTip:"Remove ALL buckets from selected node(s)" enabled:false;	editText		edtFilterNodes		"" 				pos:[nodesX-5,rowsY[2] - 18] width:214	dotNetControl	ctrlNodes				"System.Windows.Forms.ListView" pos:[nodesX,rowsY[2]] width:208 height:(rowsY[3]-rowsY[2]-4) enabled:true releaseOnClose:true setupEvents:true	checkbox		chkDisplayExpandedData			"Expanded data" pos:[nodesX, rowsY[3]] checked:true	button			btnSelectInMax			"Select this node(s) in MAX" pos:[nodesX, rowsY[4]] enabled:false	dropDownList	ddlFilterNodes		"" 				pos:[nodesX+100,rowsY[3] - 3/*22*/] width:109 items:#("Show All", "With User Data Only", "Without User Data Only")		label				lblData				"Selected Data:" pos:[dataX, rowsY[2] - 16] 	subRollout		sroProps			""				pos:[dataX,rowsY[2]] width:194 height:(rowsY[3]-rowsY[2]-4)	listbox			lbxStatus			""				pos:[bucketsX, rowsY[5]] width:400 height:3		button			btnCopyAll	"Copy all"				pos:[dataX, rowsY[3]] width:64 height:18 toolTip:"Copy all buckets to clipboard" enabled:false;	button			btnCopyFiltered	"Copy filtered"	pos:[dataX+64+8, rowsY[3]] width:74 height:18 toolTip:"Copy buckets to clipboard (only bucktet types selected in the left window)" enabled:false;	button			btnPaste	"Paste"					pos:[dataX+64+8+74+8, rowsY[3]] width:64 height:18 toolTip:"Paste buckets from clipboard to selected nodes" enabled:false;		------------------------------------------------------------------------------------	-- common	fn getIconFromBitmap thePath number iconFileName =	(		theFileName = getDir #image +"\\icon_"+ iconFileName +".bmp";		if not doesFileExist theFileName do		(			tempBmp = openBitmap thePath;			iconBmp = bitmap 16 15;						for v = 0 to 14 do			(				setPixels iconBmp [0,v] (getPixels tempBmp [(number-1)*16, v] 16);			)			iconBmp.filename = theFileName;			save iconBmp;			close iconBmp; 			close tempBmp;		) 		img = dotNetClass "System.Drawing.Image" --create an image		imageListObject.images.add (img.fromFile theFileName) --add to the list	)	fn WriteStatus text =	(		-- get log data		local items = lbxStatus.items				-- check if the text is same as last one		if (items.count > 0 and items[items.count] == text) do return()				-- append new text		append items text				-- show log		lbxStatus.items		= items		lbxStatus.selection	= items.count	)		------------------------------------------------------------------------------------	-- activeX methods	-- initialize of the image list for list views	fn InitImageList =	(		imageListObject = dotNetObject	"System.Windows.Forms.ImageList";		imageListObject.imageSize = dotNetObject "System.Drawing.Size" 16 14		local iconDir	 = (getDir #ui_ln) + "IconsDark\\";		getIconFromBitmap (iconDir + "PFSubObjectIcons_16i.bmp") 2 "UserData"; 		getIconFromBitmap (iconDir + "Standard_16i.bmp") 1 "GeomNode";		getIconFromBitmap (iconDir + "Lights_16i.bmp") 3 "Light";		getIconFromBitmap (iconDir + "Cameras_16i.bmp") 2 "Camera";		getIconFromBitmap (iconDir + "Helpers_16i.bmp") 1 "Helper";	)		-- initialize of the tree view for widgets	fn InitListView lv =	(		lv.View = (dotNetClass "System.Windows.Forms.View").Details;		lv.MultiSelect = true;		lv.FullRowSelect = true;		lv.HideSelection = false;		lv.ShowItemToolTips = true;		lv.LabelEdit	 = false;		lv.Sorting = (dotNetClass "System.Windows.Forms.SortOrder").None;		lv.SmallImageList = imageListObject;		lv.LabelWrap = false;		lv.Columns.Add "";		lv.HeaderStyle = (dotNetClass "System.Windows.Forms.ColumnHeaderStyle").None;	)		fn ClearListView lv =	(		lv.Items.Clear();	)		fn AutosizeListViewColumn lv =	( -- size of column is set according to largest text		lv.AutoResizeColumns (dotNetClass "System.Windows.Forms.ColumnHeaderAutoResizeStyle").ColumnContent;	)	fn GetListViewSelectionTags lv =	( -- useful for push/pop of selection		selectedTags	= #();		for idx = 0 to lv.SelectedItems.Count - 1 do		(			append selectedTags lv.SelectedItems.Item[idx].Tag;		)				return selectedTags;	)		fn SetListViewSelectionByNames lv selectedNames =	( -- useful for push/pop of selection--print "jo";				for idx = 0 to lv.Items.Count - 1 do		(			local item = lv.Items.Item[idx];--print item.Text;			local willBeSelected = (finditem selectedNames item.Text) != 0;--print willBeSelected;			if (item.Selected != willBeSelected) then -- I'm not sure maxscript can supress setting of the same value			(				item.Selected = willBeSelected;			)		) -- for item	)		fn SetListViewSelectionByTags lv selectedTags =	( -- useful for push/pop of selection		for idx = 0 to lv.Items.Count - 1 do		(			local item = lv.Items.Item[idx];			local willBeSelected = (finditem selectedTags item.Tag) != 0;			if (item.Selected != willBeSelected) then -- I'm not sure maxscript can supress setting of the same value			(				item.Selected = willBeSelected;			)		) -- for item	)		fn CompareListViewSelectionByTags lv selectedTags =	( -- useful for detection of selection change		local selectionIsChanged = false;		if (lv.Items.Count == 0) then		(			if (selectedTags.count > 0) then			(				selectionIsChanged = true;			)		)		else		(			for idx = 0 to lv.Items.Count - 1 do			(				local item = lv.Items.Item[idx];				local wasSelected = (finditem selectedTags item.tag) != 0;				if (item.Selected != wasSelected) then				(					selectionIsChanged = true;					exit;				)			) -- for item		)		return selectionIsChanged;	)		fn SetListViewSelectionAll lv =	(		for idx = 0 to lv.Items.Count - 1 do		(			local item = lv.Items.Item[idx];			if (item.Selected != true) then -- I'm not sure maxscript can supress setting of the same value			(				item.Selected = true;			)		)	)		fn EnsureListViewSelectionIsVisible lv =	(		if (lv.SelectedItems.Count > 0) do		(			local item = lv.Items.Item[0];			item.EnsureVisible();		)	)		------------------------------------------------------------------------------------	-- nodes related methods	-- returns true if name contains specified string	fn checkNameAgainstFilterString name str =	(		if (name.count == 0) or (str.count == 0) do			return true;				if (findString name str) == undefined do			return false;					return true;	)		-- return true if the node can be added to the nodelist	fn CanAddNodeToList nodeInfo =	(				local datInfoCount = nodeInfo.userDataInfos.count;				case ddlFilterNodes.selection of		(			2:	-- With User Data Only			(				if (datInfoCount == 0) then					return false;			)			3:	-- Without User Data Only			(				if (datInfoCount > 0) then					return false;			)		)		return checkNameAgainstFilterString nodeInfo.name edtFilterNodes.text;	)			------------------------------------------------------------------------------------	-- add node and it's data to ctrlNodes	fn AddNodeToList nodeInfo itemsToAdd =	(		local listItem = dotNetObject "System.Windows.Forms.ListViewItem";		if (chkDisplayExpandedData.checked == true) then		(			listItem.Text = nodeInfo.displayedName;		)		else		(			listItem.Text = nodeInfo.longDisplayedName;		)		listItem.ImageIndex = nodeInfo.icon;		listItem.Tag = nodeInfo.uid;		append itemsToAdd listItem;				-- emphasize levels - root nodes are bold, the others are gray		if (nodeInfo.treeLevel == 0) then			listItem.ForeColor = (dotNetClass "System.Drawing.Color").Black;		else			listItem.ForeColor = (dotNetClass "System.Drawing.Color").Gray;				if (chkDisplayExpandedData.checked == true) then		( -- add data of this node as items to listview			for userDataInfo in nodeInfo.userDataInfos do			(				local listDataItem = dotNetObject "System.Windows.Forms.ListViewItem";				listDataItem.Text = userDataInfo.displayedName;				listDataItem.Tag = nodeInfo.uid; -- uid is the same for node and it's data				listDataItem.ForeColor = (dotNetClass "System.Drawing.Color").Green;				listDataItem.ImageIndex = 0;								if (userDataInfo.dataScript == undefined) then				(					listDataItem.toolTipText = "There is no script for this bucket";				)								append itemsToAdd listDataItem;			)		)		else		(			listItem.toolTipText = nodeInfo.dataInfoString;		)	)		-- fill ctrlNodes by nodes and user data	fn FillNodesList =	(		ClearListView ctrlNodes;		local itemsToAdd = #(); -- array to collect the list items (to speed up filling of ListView)		for nodeInfo in nodesCollector.infos do		(			if (CanAddNodeToList nodeInfo) then			(				nodeInfo.isVisible = true;				AddNodeToList nodeInfo itemsToAdd;			)			else			(				nodeInfo.isVisible = false;			)		) -- for nodeInfo				ctrlNodes.Items.AddRange itemsToAdd;	)		fn FillBucketList =	(		local timer = sTimer(); -- the timer would report too long execution		timer.start();		local itemsToAdd = #(); -- array to collect the list items (to speed up filling of ListView)		for idx = 1 to scriptCollector.scripts.count do -- we DO need the index, don't use for/in loop		(			local scriptData = scriptCollector.scripts[idx];						if (checkNameAgainstFilterString scriptData.name edtFilterBuckets.text) == false do 				continue;				local li = dotNetObject "System.Windows.Forms.ListViewItem";						if (chkDisplayExpandedData.checked == true) then				li.Text = scriptData.name;			else				li.Text = scriptData.name + " (" + scriptData.shortName + ")";						li.ImageIndex = 0;			li.Tag = idx;			li.ToolTipText = scriptData.shortName;			append itemsToAdd li;		)		ctrlBuckets.Items.AddRange itemsToAdd;				timer.stop();		local time = timer.print();		if (time > 0) do			writeStatus ("[SLOW] FillBucketList() -> elapsed time : " + (time as string) + " sec");	)	-- update colors of items in ctrlBuckets	fn UpdateBucketColors =	(		local timer = sTimer(); -- the timer would report too long execution		timer.start();		-- update item's color		for ctrlItemIdx = 0 to ctrlBuckets.Items.Count - 1 do		(			local item = ctrlBuckets.Items.Item[ctrlItemIdx];			local scriptData = scriptCollector.scripts[item.tag];						local isUsedNowhere = true;			local isUsedEverywhere = true;						for nodeInfo in nodesCollector.infos do			(				if (nodeInfo.isVisible == false) do continue									isUsedInThisNode = false;				for userDataInfo in nodeInfo.userDataInfos do				(					if (userDataInfo.dataScript == undefined) then					( -- we have no script for this CA						continue;					)										if (userDataInfo.GetName() == scriptData.name) do					(						isUsedInThisNode = true;						exit;					)				)								if (isUsedInThisNode == true) then				(					isUsedNowhere = false;				)				else				(					isUsedEverywhere = false;				)			)						if (isUsedNowhere == true) then			(				item.ForeColor = (dotNetClass "System.Drawing.Color").Gray;			)			else 			(				if (isUsedEverywhere == true) then				( -- bucket is included in all nodes					item.ForeColor = (dotNetClass "System.Drawing.Color").Green;				)				else				( -- bucket is included in some (not in all) nodes					item.ForeColor = (dotNetClass "System.Drawing.Color").Black;				)			)		)		timer.stop();		local time = timer.print();		if (time > 0) do			writeStatus ("[SLOW] UpdateBucketColors() -> elapsed time : " + (time as string) + " sec");	)		-- collects data from selected nodes	fn PrepareTreeItems =	(		nodesCollector.Clear();		for node in selection do		(			-- build path to current node (it includes only nodes in selection). The path helps to sort the nodes.			local nodePath = node.name;			local treeLevel = 0;			local parent = node.parent;			while (parent != undefined) do			(				if (parent.isSelected) then				( -- add this node to the path					nodePath = parent.name + nodePath; -- we use no separator intentionally					treeLevel += 1;				)								parent = parent.parent;			)						nodesCollector.AddNode node treeLevel nodePath;		)		nodesCollector.SortInfos();	)		-- returns names of items selected in ListView	fn GetSelectedItemsNames lv =	(		selectedNodes = #();				for ctrlItemIdx = 0 to lv.SelectedItems.Count - 1 do		(			local listItem = lv.SelectedItems.Item[ctrlItemIdx];			append selectedNodes listItem.Text;		)				return selectedNodes;	)		-- returns nodes selected in ctrlNodes, array of sNodeInfo from nodesCollector	fn GetSelectedNodes =	(		selectedNodes = #();				for ctrlItemIdx = 0 to ctrlNodes.SelectedItems.Count - 1 do		(			local listItem = ctrlNodes.SelectedItems.Item[ctrlItemIdx];			local nodeInfo = nodesCollector.infos[listItem.Tag];			appendIfUnique selectedNodes nodeInfo;		)				return selectedNodes;	)		-- returns buckets selected in ctrlBuckets, array of sUserDataScript from scriptCollector	fn GetSelectedBuckets =	(		selectedBuckets	= #();				for ctrlItemIdx = 0 to ctrlBuckets.SelectedItems.Count - 1 do		(			local listItem = ctrlBuckets.SelectedItems.Item[ctrlItemIdx];			local scriptData = scriptCollector.scripts[listItem.Tag];			append selectedBuckets scriptData;		)				return selectedBuckets;	)		-- select buckets in ctrlBuckets according to "initialSelectedBuckets"	fn SelectBucketsByIniList =	(		-- transform names in currentSelectedBuckets to tags for ctrlBuckets		local currentSelectedBucketsTags = #();		local stringItems = filterString initialSelectedBuckets ",";		local scriptIdx = 0;		for stringItem in stringItems do		(			--print stringItem			--print scriptCollector			try 			(				scriptIdx = scriptCollector.GetScriptIndexByName stringItem				if (scriptIdx != 0) then				(					append currentSelectedBucketsTags scriptIdx;					scriptIdx = 0;				)			)			catch			(				print "----------------------------------------------------------------------------------------"				print "Chyba v scriptCollector.GetScriptIndexByName stringItem;"				format "scriptIdx = %\n" scriptIdx				format "stringItem = %\n" stringItem				format "currentSelectedBucketsTags = %\n" currentSelectedBucketsTags				--format "scriptCollector = %\n" scriptCollector				print "----------------------------------------------------------------------------------------"			)				)				SetListViewSelectionByTags ctrlBuckets currentSelectedBucketsTags;	)		-- remove selected buckets from selected nodes  (or test if it is possible to remove them). Return value is true in case removing was succesful (or can be succesful)	fn RemoveSelectedBuckets testOnly:false =	(		local returnValue = false;		local selectedBuckets = GetSelectedBuckets(); -- get bucket(s) from ctrlBuckets		if (selectedBuckets.count == 0) do		(			if (testOnly == false) then			(				writeStatus "[FAILED] no bucket is selected";			)			return false;		)				local selectedNodes = GetSelectedNodes(); -- get node(s) from ctrlNodes		if (selectedNodes.count == 0) do		(			if (testOnly == false) then			(				writeStatus "[FAILED] no node is selected";			)			return false;		)				-- remove each selected bucket from each selected node (buckets are selected as types)		local removedDataCount = 0;		for currentNode in selectedNodes do		(			for currentBucket in selectedBuckets do			(				local count = custAttributes.count currentNode.node;				for caIndex = 1 to count do				(					local ca = custAttributes.get currentNode.node caIndex;					if (ca.name == currentBucket.fullname) do					(						if (testOnly == false) then						(							custAttributes.delete currentNode.node caIndex;							writeStatus ("Bucket '" + currentBucket.name + "' has been removed from '" + currentNode.name);							removedDataCount += 1;						)						returnValue = true;						exit;					)				)			)		)				if (testOnly == false) then		(			writeStatus ("[OK] " + (removedDataCount as string) + " item(s) have been removed");		)				return returnValue;	)		-- remove all buckets from selected nodes  (or test if it is possible to remove them). Return value is true in case removing was succesful (or can be succesful).	-- ALL cuastom attributes are removed, not only known types	fn RemoveAllBuckets testOnly:false =	(		local returnValue = false;		local selectedNodes = GetSelectedNodes(); -- get node(s) from ctrlNodes		if (selectedNodes.count == 0) do		(			if (testOnly == false) then			(				writeStatus "[FAILED] no node is selected";			)			return false;		)				-- remove each all buckets from each selected node		local removedDataCount = 0;		for currentNode in selectedNodes do		(			if (testOnly == true) then			(				if (custAttributes.count currentNode.node > 0) then				(					return true;				)				continue;			)			while (custAttributes.count currentNode.node > 0) do			(				local caFullName = (custAttributes.get currentNode.node 1).name;				local names = filterString caFullName pathSeparator;				local caName = names[names.count];				custAttributes.delete currentNode.node 1;				writeStatus ("Bucket '" + caName + "' has been removed from '" + currentNode.name);				removedDataCount += 1;				returnValue = true;			)		)				if (testOnly == false) then		(			writeStatus ("[OK] " + (removedDataCount as string) + " item(s) have been removed");		)				return returnValue;	)		-- add bucket(s) to all selected nodes (or test if it is possible to add them). Return value is true in case adding was succesful (or can be succesful)	fn AddSelectedBuckets testOnly:false =	(		local returnValue = false;		local selectedBuckets = GetSelectedBuckets(); -- get bucket(s) from ctrlBuckets		if (selectedBuckets.count == 0) do		(			if (testOnly == false) then			(				writeStatus "[FAILED] no bucket is selected";			)			return false;		)				local selectedNodes = GetSelectedNodes() -- get node(s) from ctrlNodes		if (selectedNodes.count == 0) do		(			if (testOnly == false) then			(				writeStatus "[FAILED] no target (node) is selected";			)			return false;		)				-- add each selected bucket to each selected node		local addedDataCount = 0;		for currentNode in selectedNodes do		(			for currentBucket in selectedBuckets do			(				-- test if this bucket is added to the node alreday				local isExisting = false;				local count = custAttributes.count currentNode.node;				for caIndex = 1 to count do				(					local ca = custAttributes.get currentNode.node caIndex;					if (ca.name == currentBucket.fullName) do					(						isExisting = true;						exit;					)				) -- for caIndex								if (isExisting == false) then				( -- this bucket does not exist, let' create new one					if (testOnly == true) then					( -- we already know something would be changed						return true;					)					returnValue = true;										local newCA = AddCustomAttributeToNode currentBucket.sourceCode currentNode.node;					if (newCA == undefined) then					(						writeStatus ("[FAILED] to add bucket '" + currentBucket.name + "' to '" + currentNode.name);					)					else					(						caAggregator.SetAggregatedPropertiesToCA newCA;						writeStatus ("Bucket '" + currentBucket.name + "' has been added to '" + currentNode.name);						addedDataCount += 1;					)				)			) -- for currentBucket		) -- for currentNode				if (testOnly == false) then		(			writeStatus ("[OK] " + (addedDataCount as string) + " item(s) have been added");		)				 return returnValue;	)		-- enable/disable buttons according to current selection	fn UpdateDialogButtons =	(		btnAddBucket.enabled = AddSelectedBuckets testOnly:true;		btnRemoveBucket.enabled = RemoveSelectedBuckets testOnly:true;		btnRemoveAllBuckets.enabled = RemoveAllBuckets testOnly:true;				local selectedBuckets = GetSelectedBuckets();		btnSelectAllBuckets.enabled = selectedBuckets.count < ctrlBuckets.Items.Count; -- if not everything is selected		btnEditScript.enabled = selectedBuckets.count == 1; -- only one bucket script can be edited				btnCopyAll.enabled = caAggregator.CopyCAs &clipboard bucketFilter:undefined testOnly:true;		btnCopyFiltered.enabled =caAggregator.CopyCAs &clipboard bucketFilter:selectedBuckets testOnly:true;		local selectedNodes = GetSelectedNodes();		btnPaste.enabled = caAggregator.PasteCAs &clipboard targetNodes:selectedNodes testOnly:true;				btnSelectInMax.enabled = selectedNodes.count > 0;	)		-- removes all data rollouts from sub-rollout control	fn HideData =	(		while (dlgLS3DDataManager.sroProps.rollouts[1] != undefined) do			removeSubRollout dlgLS3DDataManager.sroProps dlgLS3DDataManager.sroProps.rollouts[1]	)	-- node and it's properties must be selected together	fn NormalizeSelection =	(		if (chkDisplayExpandedData.checked == true) then		( -- property items must be in the list			local lastClickedItem = ctrlNodes.FocusedItem; -- last clicked item			if (lastClickedItem != undefined) then			(								local willBeSelected = lastClickedItem.Selected;				local tag = lastClickedItem.Tag; -- node and it's properties share this tag				for ctrlItemIdx = 0 to ctrlNodes.Items.Count - 1 do				(					local item = ctrlNodes.Items.Item[ctrlItemIdx];					if (item.Tag != tag) then continue;										if (item.Selected != willBeSelected) then -- I'm not sure maxscript can supress setting of the same value					(						item.Selected = willBeSelected;					)				) -- for ctrlItemIdx			)		)		)		fn onNodesSelectionChange forceUpdate:false =	(		NormalizeSelection();				local doUpdate;		if (forceUpdate) then		(			doUpdate = true;		)		else		(			doUpdate = CompareListViewSelectionByTags  ctrlNodes currentSelectedNodesTags;		)					if (doUpdate) then		(			currentSelectedNodesTags = GetListViewSelectionTags ctrlNodes;						sroProps.enabled = false; -- prevent user from interaction, refreshing may take long time						local selectedNodes = GetSelectedNodes();			caAggregator.AggregateByNodes selectedNodes;			HideData();			caAggregator.ShowCustomAttributes sroProps;						sroProps.enabled = true;						UpdateDialogButtons();		)	)	-- collects all data scripts from disk	fn CollectScripts =	(		scriptCollector.clear();		scriptCollector.process("$scripts\\LS3DData");				if (scriptCollector.scripts.count == 0) then			writeStatus "[FAILED] No scripts loaded";		else			writeStatus "[OK] scripts loaded";	)		-- register callback we need	fn registerCallbacks =	(		callbacks.addScript #preNodesCloned "dlgLS3DDataManager.onPreCloneNodes()" id:#dlgLS3DDataManager;		callbacks.addScript #selectionSetChanged "dlgLS3DDataManager.onMAXSelectionChange()" id:#dlgLS3DDataManager;	)	-- unregisters useless callbacks	fn unregisterCallbacks =	(		callbacks.removeScripts id:#dlgLS3DDataManager;	)		-- load dialog settings from the ini file	fn LoadSettings =	(		writeStatus ("Settings will be loaded from '" + iniFile + "'");		local tmp = OK;				tmp = execute(getINISetting iniFile "NodeList" "ExpandedData"); -- "execute" transforms the string to value		if (tmp != OK) then			chkDisplayExpandedData.checked = tmp;				tmp = execute(getINISetting iniFile "NodeList" "Filter");		if (tmp != OK) then			ddlFilterNodes.selection = tmp;		tmp = getINISetting iniFile "BucketList" "Selection"; -- "execute" is not used here, because we want the string as it is		if (tmp != OK) then		(			initialSelectedBuckets = tmp; -- we will solve this string later, after loading of scripts		)	)		-- save dialog settings to the ini file	fn SaveSettings =	(		local pos = GetDialogPos dlgLS3DDataManager;		setINISetting iniFile "General" "Position" ("[" + pos.x as string + "," + pos.y as string + "]");		setINISetting iniFile "General" "Width" (dlgLS3DDataManager.width as string);		setINISetting iniFile "General" "Height" (dlgLS3DDataManager.height as string);		setINISetting iniFile "NodeList" "ExpandedData" (chkDisplayExpandedData.checked as string);		setINISetting iniFile "NodeList" "Filter" (ddlFilterNodes.selection as string);				-- save list of currently selected buckets		local selectedBucketsNames = "";		for bucketTag in currentSelectedBucketsTags do		(			local scriptData = scriptCollector.scripts[bucketTag];			if (selectedBucketsNames.count > 0) then			( -- next names, with separator				selectedBucketsNames += "," + scriptData.name;			)			else			( -- first name				selectedBucketsNames = scriptData.name;			)		) -- for bucket		setINISetting iniFile "BucketList" "Selection" selectedBucketsNames;	)		fn onBucketsSelectionchange =	(		if (CompareListViewSelectionByTags  ctrlBuckets currentSelectedBucketsTags) then		( -- the selection has been changed			currentSelectedBucketsTags = GetListViewSelectionTags ctrlBuckets;			UpdateDialogButtons();		)	)		-- updates list of nodes	fn RefreshNodeList forceUpdate:false =	(		-- prevent user from interaction, refreshing may take long time		sroProps.enabled = false;		ctrlNodes.enabled = false;				local selectedTags = GetListViewSelectionTags ctrlNodes; -- archive the selection		ClearListView ctrlNodes;		FillNodesList();		SetListViewSelectionByTags ctrlNodes selectedTags; -- restore the selection (maybe some of nodes are not displayed now, they will not be selected)		UpdateBucketColors();		AutosizeListViewColumn ctrlNodes;		onNodesSelectionChange forceUpdate:forceUpdate;		sroProps.enabled = true;		ctrlNodes.enabled = true;	)		-- updates list of available data buckets	fn RefreshBucketList =	(		local selectedTags = GetListViewSelectionTags ctrlBuckets; -- archive the selection		ClearListView ctrlBuckets;		FillBucketList();		SetListViewSelectionByTags ctrlBuckets selectedTags; -- restore the selection (maybe some of buckets are not displayed now, they will not be selected)		UpdateBucketColors();		AutosizeListViewColumn ctrlBuckets;		onBucketsSelectionchange();	)		------------------------------------------------------------------------------------	-- handler methods	fn onPreCloneNodes =	(		-- prevent from change selection when clone		preClone = 2	)		fn onMAXSelectionChange forceUpdate:true =	(		lblSelected.text = "Selected in MAX: " + selection.count as string + " node(s)";		local timer = sTimer(); -- the timer would report too long execution		timer.start();		local selectedNodesNames = GetSelectedItemsNames ctrlNodes; -- preserve the selection		--print selectedNodesNames;		PrepareTreeItems(); -- collects data from nodes selected in MAX		RefreshNodeList forceUpdate:forceUpdate;		SetListViewSelectionByNames ctrlNodes selectedNodesNames; -- restore the selection		NormalizeSelection();				-- if nothing is selected, select the first node		if ((ctrlNodes.SelectedItems.Count == 0) and (ctrlNodes.Items.Count > 0)) then		(			ctrlNodes.Items.Item[0].Selected = true;			onNodesSelectionChange forceUpdate:true;		)		else		(			onNodesSelectionChange forceUpdate:true;		)				EnsureListViewSelectionIsVisible ctrlNodes;				UpdateDialogButtons();				timer.stop();		local time = timer.print();		if (time > 0) do			writeStatus ("[SLOW] onMAXSelectionChange() -> elapsed time : " + (time as string) + " sec");	)		fn OnRefreshScripts =	(		CollectScripts(); -- collect scripts (bucket types) in the folder		RefreshBucketList(); -- if the scripts number has been changed, selection may not match the previous one ()		RefreshNodeList forceUpdate:true; -- update the nodes, because references to scripts must be updated	)		fn SelectAllBuckets =	(		SetListViewSelectionAll ctrlBuckets;		currentSelectedBucketsTags = GetListViewSelectionTags ctrlBuckets;		UpdateDialogButtons();	)		fn onEditScript =	(		local bucketSelection = GetSelectedBuckets();		if (bucketSelection.count != 1) then		(			writeStatus "[FAILED] just one bucket must be selected";			return();		)					local selectedBucket = bucketSelection[1];				-- check if the file does exist		if (doesFileExist selectedBucket.fileName == false) do		(			writeStatus ("[FAILED] File '" + selectedBucket.fileName + "' does not exist");			return();		)		-- open script in listener		edit selectedBucket.fileName;		writeStatus "[OK] script opened successfully";	)	fn onNodeClick node =	(		-- remove old rollouts		HideData();		-- add new rollouts		editData node;	)		fn onAddBucket =	(		local sceneIsChanged = AddSelectedBuckets testOnly:false;		if (sceneIsChanged) then		(			onMAXSelectionChange forceUpdate:true; -- rebuild tree		)	)		-- remove selected or all buckets from selected nodes	fn onRemoveBucket removeAll:false =	(		local sceneIsChanged;		if (removeAll) then		(			sceneIsChanged = RemoveAllBuckets testOnly:false;		)		else		(			sceneIsChanged = RemoveSelectedBuckets testOnly:false;		)		if (sceneIsChanged) then		(			onMAXSelectionChange forceUpdate:true; -- rebuild tree		)		setFocus ctrlNodes;	)		fn onCopyAllBuckets =	(		caAggregator.CopyCAs &clipboard bucketFilter:undefined;		UpdateDialogButtons();		writeStatus ("Copy - " + (clipboard.count as string) + " bucket(s) have been copied to clipboard");	)		fn onCopyFilteredBuckets =	(		local selectedBuckets = GetSelectedBuckets();		caAggregator.CopyCAs &clipboard bucketFilter:selectedBuckets;		UpdateDialogButtons();		writeStatus ("Copy - " + (clipboard.count as string) + " bucket(s) have been copied to clipboard");	)		fn onPasteBuckets =	(		local selectedNodes = GetSelectedNodes();		caAggregator.PasteCAs &clipboard targetNodes:selectedNodes;		onMAXSelectionChange forceUpdate:true; -- rebuild tree		setFocus ctrlNodes;		UpdateBucketColors();	)		fn ResizeDialog =	(		local dialogWidth = dlgLS3DDataManager.width;		local dialogHeight = dlgLS3DDataManager.height;				-- resize the main listViews		local listViewHeight = dlgLS3DDataManager.height - 158;		ctrlBuckets.Height = listViewHeight;		ctrlNodes.Height = listViewHeight;		sroProps.height = listViewHeight;		-- move the controls below the main listViews		lbxStatus.width	= dialogWidth - 16;		lbxStatus.pos = [lbxStatus.pos[1], dialogHeight - 50];				local buttonPosY = dialogHeight - 102;		btnRefreshScripts.pos = [btnRefreshScripts.pos[1], buttonPosY];		btnSelectAllBuckets.pos = [btnSelectAllBuckets.pos[1], buttonPosY];		btnEditScript.pos = [btnEditScript.pos[1], buttonPosY];		chkDisplayExpandedData.pos = [chkDisplayExpandedData.pos[1], buttonPosY + 2];		ddlFilterNodes.pos = [ddlFilterNodes.pos[1], buttonPosY];		btnCopyAll.pos = [btnCopyAll.pos[1], buttonPosY];		btnCopyFiltered.pos = [btnCopyFiltered.pos[1], buttonPosY];		btnPaste.pos = [btnPaste.pos[1], buttonPosY];		local buttonPosY2 = buttonPosY + 26;		btnSelectInMax.pos = [btnSelectInMax.pos[1], buttonPosY2];				local newSroPropsWidth = dialogWidth - dataX - 8;		if (sroProps.width != newSroPropsWidth) then		(			sroProps.width = dialogWidth - dataX - 8;						-- reAdd rollouts to update size of rollouts in sroProps			sroProps.enabled = false; -- prevent user from interaction, refreshing may take long time			HideData();			caAggregator.ShowCustomAttributes sroProps;			sroProps.enabled = true;		)	)		-- selection has been changed by the ctrlNodes	fn onNodesSelectionChangeByControl =	(		onNodesSelectionChange();		setFocus ctrlNodes; -- because ctrlNodes has lost focus while aggregated properties are updated	)		fn onAddBucketByButton =	(		onAddBucket();		setFocus ctrlNodes;	)		fn onSelectInMax =	(		local selectedNodes = GetSelectedNodes();		local selectedMctrlNodes = #();		for selectedNode in selectedNodes do		(			append selectedMctrlNodes selectedNode.node;		)		select selectedMctrlNodes;		setFocus ctrlNodes;	)		fn onExpandData =	(		RefreshBucketList(); -- because of adding/removing of short names to bucket list		RefreshNodeList();	)		------------------------------------------------------------------------------------	-- handlers	on edtFilterBuckets		changed text	do RefreshBucketList()	on btnRefreshScripts	pressed			do OnRefreshScripts()	on btnSelectAllBuckets	pressed			do SelectAllBuckets()	on btnEditScript			pressed			do onEditScript()		on btnAddBucket			pressed			do onAddBucketByButton();	on btnRemoveBucket	pressed			do onRemoveBucket removeAll:false;	on btnRemoveAllBuckets pressed 		do onRemoveBucket removeAll:true		on edtFilterNodes		changed text	do RefreshNodeList()	on ctrlNodes				Click				do onNodesSelectionChangeByControl();	on ctrlNodes				KeyUp keyCode shift	do onNodesSelectionChangeByControl();	on btnSelectInMax		pressed			do onSelectInMax();	on ctrlBuckets				Click				do onBucketsSelectionchange();	on ctrlBuckets				KeyUp keyCode shift	do onBucketsSelectionchange();	on ctrlBuckets				DoubleClick		do onAddBucket();		on btnCopyAll 			pressed			do onCopyAllBuckets();	on btnCopyFiltered 		pressed			do onCopyFilteredBuckets();	on btnPaste 				pressed			do onPasteBuckets();		on chkDisplayExpandedData changed state	do onExpandData()	on ddlFilterNodes		selected item		do RefreshNodeList()		on dlgLS3DDataManager open do	(		writeStatus "[OK] dialog opened";		LoadSettings();		-- init list views		InitImageList();		InitListView ctrlNodes;		InitListView ctrlBuckets;				dataManagerIndentator = sIndentator();		dataManagerIndentator.BuildIndentationStrings 8;						nodesCollector.dataScriptCollector	= scriptCollector;		caAggregator.dataScriptCollector	= scriptCollector;		-- collect user data scripts and fill ctrlBuckets window		OnRefreshScripts();		SelectBucketsByIniList(); -- restore selection (from the ini file)		-- setup nodes and data according to current selection in the MAX		onMAXSelectionChange();		-- update system resources		gLS3DDataManagerVersionUI = OK;		updateToolbarButtons();		lblCredits.text	= LS3DCopyright;		resizeDialog();		registerCallbacks();				writeStatus "[OK] initialized";	)		on dlgLS3DDataManager close do	(		unregisterCallbacks();		SaveSettings();		HideData();				-- update system resources		gLS3DDataManagerVersionUI = undefined;		updateToolbarButtons();	)		on dlgLS3DDataManager resized size do	(		resizeDialog();	)	)fn RestartAndCloseDM = (	if (gLS3DDataManagerVersionUI == undefined) then (		macros.run "LS3D Engine" "LS3DDataManager"	)	macros.run "LS3D Engine" "LS3DDataManager")-------------------------------------------------------------------------------------------------------------------------------------------------------------- MACRO SCRIPTS------------------------------------------------------------------------------macroScript LS3DDataManagercategory:"LS3D Engine" buttonText:"LS3D Data Manager" tooltip:"Data Manager"Icon:#("TrackViewTools",15)(	if (gLS3DDataManagerVersionUI == undefined) then	(		-- load size of dialog from the ini file		local iniFile = (LS3DGUP.LS3DGUP.UtilsPath + "\\LS3DDataManager.ini");		local savedPos = execute (getINISetting iniFile "General" "Position");  -- "execute" transforms the string to value		if (savedPos == OK) then 			savedPos = [-1, -1];		local savedWidth = execute (getINISetting iniFile "General" "Width");		if (savedWidth == OK) then 			savedWidth = 750;		if(savedWidth < 200) then 			savedWidth = 750;		local savedHeight = execute (getINISetting iniFile "General" "Height");		if (savedHeight == OK) then 			savedHeight = 620;		-- create dialog		createDialog dlgLS3DDataManager style:#(#style_toolwindow, #style_sysmenu, #style_resizing) pos:savedPos width:savedWidth height:savedHeight;	)	else		destroyDialog dlgLS3DDataManager;)