-- store the selected objectobj=selection[1]iterations = 2if classof obj == Editable_poly do (	planeRay = polyop.getSlicePlane obj	-- Check the radiobuttons state	increment = case direction.state of	(	1: [trans.value,0,0]	2: [0,trans.value,0]	3: [0,0,trans.value]	)	-- grab the face selection - if no faces selected operate on the whole object	sel=polyop.getFaceSelection obj	if sel.numberset==0 do sel=#{1..(polyop.getNumFaces obj)}	-- add an undo context, just in case ;)	With undo "Slice it" on	(	for i = 1 to iterations do	(		polyop.slice obj sel planeRay		planeRay.pos += increment	))obj=selection[1]iterations = 2direction = 1spacing = 10if classof obj == Editable_poly do (	planeRay = polyop.getSlicePlane obj	-- Check the radiobuttons state	increment = case direction of	(	1: [spacing,0,0]	2: [0,spacing,0]	3: [0,0,spacing]	)	-- grab the face selection - if no faces selected operate on the whole object	sel=polyop.getFaceSelection obj	if sel.numberset==0 do sel=#{1..(polyop.getNumFaces obj)}	-- add an undo context, just in case ;)	With undo "Slice it" on	(	for i = 1 to iterations do	(		polyop.slice obj sel planeRay		planeRay.pos += increment	))fn sliceSelectedFaces = (	local obj=selection[1]	if classof obj != Editable_poly or (subobjectlevel != 4 and subobjectlevel != 5) do return false	local fsel=polyop.getFaceSelection obj	if fsel.numberset == 0 do return false	if not (polyop.inSlicePlaneMode obj) do (obj.toggleCommandMode #SlicePlane) --enable sliceplane mode	planeRay = polyop.getSlicePlane obj	local faces_center = [0,0,0]	for f in fsel do faces_center += polyop.getFaceCenter obj f	faces_center /= fsel.numberset	--local bigest_face = 	planeRay.pos = faces_center	polyop.slice obj fsel planeRay	obj.toggleCommandMode #SlicePlane	completeRedraw())sliceSelectedFaces()--polyop.setSlicePlane obj ray_plane_and_dir float_sizefn moveSlicePlaneToSelectedFaces = (	local obj=selection[1]	if classof obj != Editable_poly or (subobjectlevel != 4 and subobjectlevel != 5) do return false	local fsel=polyop.getFaceSelection obj	if fsel.numberset == 0 do return false	if not (polyop.inSlicePlaneMode obj) do (obj.toggleCommandMode #SlicePlane) --enable sliceplane mode	local faces_center = [0,0,0]	for f in fsel do faces_center += polyop.getFaceCenter obj f	faces_center /= fsel.numbersetlocal objTM = obj.objectTransformlocal modTM = (polyop.getSlicePlane obj).pos	planeRay.pos = faces_center * modTM * (inverse objTM)	plane_normal = [0,0,1]	plane_center = faces_center	plane_size = 20	obj.setSlicePlane plane_normal plane_center plane_size	completeRedraw())moveSlicePlaneToSelectedFaces()pnt1 = pickPoint snap:#3Dif classof pnt1 == Point3 do( pnt2 = pickPoint snap:#3D rubberband:thePoint1 if classof pnt2 == Point3 and distance pnt1 pnt2 > 0 do (	 theRay = ray pnt1 (normalize (pnt2-pnt1))	 polyop.setSlicePlane obj theRay 100. ))fn getEdgeLength obj edge_index = (	local everts = (polyop.getEdgeVerts obj edge_index) as array	local p1 = polyop.getVert obj everts[1]	local p2 = polyop.getVert obj everts[2]		distance p1 p2)fn getLongestEdge obj edges = (	local longest_edge = (edges as array)[1]	local longest_len = getEdgeLength obj longest_edge	for ei in edges do (		local len  = getEdgeLength obj ei		if longest_len < len do (			longest_edge = ei			longest_len = len		)	) 	longest_edge)fn twoPointSlicePlane obj p1 p2 size:10 = if iskindof obj editable_poly do(	local dir = normalize (p2 - p1)	local center = (p1 + p2) / 2 	polyop.setSlicePlane obj (ray center (dir * obj.objectoffsetrot)) size	update obj)fn slicePlaneToEdge = (	local obj=selection[1]	if classof obj != Editable_poly do return false	local esel = #{}	local allow_progress = false	if subobjectlevel == 4 or subobjectlevel == 5 then (		local fsel = polyop.getFaceSelection obj		if fsel.numberset == 0 do return false 		esel = polyop.getEdgesUsingFace obj fsel		allow_progress = true	) else if subobjectlevel == 2 do (		esel = polyop.getEdgeSelection obj		allow_progress = true	) 	if not allow_progress or esel.numberset == 0 do return false	local longest_edge = getLongestEdge obj esel	if not (polyop.inSlicePlaneMode obj) do (obj.toggleCommandMode #SlicePlane) --enable sliceplane mode	local everts = (polyop.getEdgeVerts obj longest_edge) as array	local p1 = polyop.getVert obj everts[1]	local p2 = polyop.getVert obj everts[2]	twoPointSlicePlane obj p1 p2 size:(distance p1 p2))undo "SlicePlane2" on slicePlaneToEdge()