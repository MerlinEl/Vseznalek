(		if selection.count == 1 and classOf (curO = selection[1]) == Editable_Poly do	(		if (selFacesBA = polyop.getFaceSelection curO).numberset != 0 do		(			faceVertsBA = polyop.getVertsUsingFace curO selFacesBA			curOtransform = curO.transform			curO.rotation = quat 0 0 0 1			with redraw off 			(				tMesh = mesh mesh:curO.mesh				tMesh.pos = curO.pos				tMesh.objectOffsetPos = curO.objectOffsetPos				if faceVertsBA.count > 0 do 				(					delete tMesh.verts[((tMesh.verts as BitArray) - (faceVertsBA))]				)				c = snapshot tMesh				c.transform = matrix3 1-- 				d = dummy boxsize:(c.max - c.min)				size = (c.max - c.min)				d = Box lengthsegs:1 widthsegs:1 heightsegs:1 length:size[2] width:size[1] height:size[3]				centerPivot d				delete c				d.transform = tMesh.transform				d.pos = tMesh.center				d.name = tMesh.name + "_box"				--	very ugly, but skip all math operations				d.parent = curO				delete tMesh				curO.transform = curOtransform				d.parent = undefined			)		)	)) ( 	if selection.count == 1 and classof $ == Editable_Poly do 	( 		theObj = $ 		theVerts = polyop.getvertselection theObj as array 		xVals = #() 		yVals = #() 		zVals = #() 			    		for v in theVerts do 		( 			vertPos = polyop.getvert theObj v 			append xVals vertPos.x 			append yVals vertPos.y 			append zVals vertPos.z 		) 		 		theWidth = (amax xVals) - (amin xVals) 		theLength = (amax yVals) - (amin yVals) 		theHeight = (amax zVals) - (amin zVals) 		 		avgPos = [(((amax xVals) + (amin xVals)) / 2.),(((amax yVals) + (amin yVals)) / 2.),(((amax zVals) + (amin zVals)) / 2.)] 		theBox = box length:theLength width:theWidth height:theHeight xray:true 		theBox.pivot = theBox.center 		theBox.pos = avgPos 	) )       (  	if selection.count == 1 and classof $ == Editable_Poly do  	(  		theObj = $  		theVerts = polyop.getvertselection theObj as array  		vertLocs = for v in theVerts collect polyop.getvert theObj v  		vertAmount = theVerts.count  		avgPos = [0,0,0]  		zComp = #()  		xComp = #()  		yComp = #()  		zComp[vertAmount] = xComp[vertAmount] = yComp[vertAmount] = undefined  		local zMax, zMin, xMax, xMin, yMax, yMin, xVect, yVect, zVect, theMatrix,  			  theLength, theWidth, theHeight, xAmt, yAmt, zAmt, zMaxHold, zMinHold  		  		--Get average position  		for v in vertLocs do avgPos += v  		avgPos /= vertAmount  		  		--Get farthest vert  		for x = 1 to vertAmount do  			zComp[x] = distance avgPos vertLocs[x]  		  		zMaxHold = theVerts[(finditem zComp (amax zComp))]  		zMax = polyop.getvert theObj zMaxHold  		  		--Get farthest vert from farthest vert (the 2 extremes)  		for x = 1 to vertAmount do  			zComp[x] = distance zMax vertLocs[x]  		  		zMinHold = theVerts[(finditem zComp (amax zComp))]  		zMin = polyop.getvert theObj zMinHold  		  		--Construct matrix from vectors  		zVect = normalize (zMax - zMin)  		xVect = normalize (cross [0,0,1] zVect)  		yVect = normalize (cross xVect zVect)  		theMatrix = matrix3 xVect yVect zVect [0,0,0]  		  		--Determine dimensions and construct box  		in coordsys theMatrix  		(		  			for x = 1 to vertAmount do  			(  				thePos = polyop.getvert theObj theVerts[x]  				xComp[x] = thePos.x  				yComp[x] = thePos.y  			)  			  			xMax = polyop.getvert theObj theVerts[(finditem xComp (amax xComp))]  			xMin = polyop.getvert theObj theVerts[(finditem xComp (amin xComp))]  			yMax = polyop.getvert theObj theVerts[(finditem yComp (amax yComp))]  			yMin = polyop.getvert theObj theVerts[(finditem yComp (amin yComp))]  			zMax = polyop.getvert theObj zMaxHold  			zMin = polyop.getvert theObj zMinHold  			  			xAmt = ((xMax + xMin) / 2.).x  			yAmt = ((yMax + yMin) / 2.).y  			zAmt = ((zMax + zMin) / 2.).z  			  			theWidth = xMax.x - xMin.x  			theLength = yMax.y - yMin.y  			theHeight = distance zMax zMin  		)  		  		theBox = box width:theWidth length:theLength height:theHeight xray:true  		theBox.pivot = theBox.center  		theBox.transform = theMatrix  		  		in coordsys theMatrix(move theBox [xAmt, yAmt, zAmt])  		completeredraw()  	)  )      				c = snapshot i				c.transform = matrix3 1				bb = c.max - c.min				b = box width:bb[1] length:bb[2] height:bb[3]				CenterPivot b				delete c				b.transform = i.transform				b.pos = i.center				b.pivot = i.pivot				b.name = i.name + "_box"          mcQuickMaterialsDialog.rdo_axis.stateu= 1subobjectLevel = if u == undefined then 1 else 2fn alignUVGizmo theObj theFace = (	-- First get the face normal vector.	-- It is shown in BLUE on the image	faceNormal = in coordsys theObj (polyOp.getFaceNormal theObj theFace)	-- This is the desired up vector in world space	-- It is shown in YELLOW on the image	worldUpVector = [0,0,1]	-- Now get the cross-product of the face normal and the up vector.	-- This will give you a vector that is perpendicular to the plane defined	-- by the normal and the up vector. Normalize it to get a normal vector	-- pointing to the right.	-- It is shown in RED on the image	rightVector = normalize (cross worldUpVector faceNormal)	-- Now using the face normal and the new vector,	-- get a vector that is perpendicular to the plane defined by the two.	-- This is the "local up vector", the vector that is the projection of	-- the world up vector on the face you selected. This one is perpendicular	-- to both the face normal and the right vector, and you have 3 normals now	-- that define the X, Y and Z of your new orthogonal coordinate system	-- for the UVW gizmo!	-- Note that this new vector can be seen as the SHADOW of the World Up vector	-- on the face of the object in the above image.	-- It is now displayed in green in the image below:	upVector = normalize ( cross rightVector faceNormal )	-- Using the 3 vectors, define a matrix3 value which represents the	-- coordinate system of the gizmo. The face normal is the Z axis,	-- the right vector is the X axis, and the local up vector is the Y axis:	theMatrix = matrix3 rightVector upVector faceNormal [0,0,0]	theMap = Uvwmap()	modPanel.addModToSelection theMap ui: on	theMap.gizmo.transform = theMatrix)alignUVGizmo $ 7fn AlignBBoxToFirstNormal theObject = ( theCurrentTM = theObject.transform theMesh = snapshotasmesh theObject theZ = normalize (getFaceNormal theMesh 1) theFace = getFace theMesh 1 theY = normalize ((getVert theMesh theFace.y)-(getVert theMesh theFace.x)) theX = normalize (cross theY theZ) theTM = matrix3 theX theY theZ theCurrentTM.row4 theObject.transform *= inverse theTM resetXForm theObject convertToMesh theObject theObject.transform = theTM  )