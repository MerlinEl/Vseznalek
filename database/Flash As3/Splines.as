http://www.timotheegroleau.com/Flash/articles/cubic_bezier_in_flash.htmvar cir_sp:Sprite;var ar_ob:Array, i:int, j:int = 1, t:Number;ar_ob = new Array();ar_ob[0] = new Object();graphics.lineStyle(0);for (i=0;i<10;i++){ ar_ob[i] = new Object(); ar_ob[i].x1 = i*50; ar_ob[i].y1 = -uint(i/2)*50+200;  ar_ob[i].x2 = i*50+100; ar_ob[i].y2 = uint(i/2)*50+350;  graphics.curveTo( ar_ob[i].x2, ar_ob[i].y2, ar_ob[i].x1, ar_ob[i].y1);}cir_sp = new Sprite();cir_sp.graphics.beginFill(0xff00aa);cir_sp.graphics.drawCircle(5,5,5);addChild(cir_sp);addEventListener(Event.ENTER_FRAME, enterFramFunc)function enterFramFunc(evt:Event):void { if (j>=ar_ob.length) j=1; i++; t = i/100; cir_sp.x = сurve_to(ar_ob[j-1].x1, ar_ob[j].x2, ar_ob[j].x1, t)-2.5; cir_sp.y = сurve_to(ar_ob[j-1].y1, ar_ob[j].y2, ar_ob[j].y1, t)-2.5; graphics.lineTo(cir_sp.x+2.5, cir_sp.y+2.5);  if (i>100) {    j++;  graphics.clear();  graphics.lineStyle(0);  for (i=0;i<j;i++){   graphics.curveTo( ar_ob[i].x2, ar_ob[i].y2, ar_ob[i].x1, ar_ob[i].y1);  } i=0; }}function сurve_to(p0:int,p1:int,p2:int,t:Number) { return (1-t)*(1-t)*p0+2*t*(1-t)*p1+t*t*p2;}//I made this stuff a few a years ago and thought it might help you.//This adjust the control of a curve based on the position of the mouse on the x axis. Of course the variable could come from anywhere. Requires twomovieclips on the stage named a and b.function getControl(a:Object, b:Object, h:Number):Object {	var midX:Number = (a.x + b.x) / 2;	var midY:Number = (a.y + b.y) / 2;	var t:Number = Math.atan(-1 / ((b.y - a.y) / (b.x - a.x)));	return {x:Math.cos(t) * h + midX, y:Math.sin(t) * h + midY};	}function onEnterFrame():Void {	clear();	lineStyle(1);	var c:Object = this.getControl({x:a._x, y:a._y}, {x:b._x, y:b._y}, this._xmouse);	moveTo(a._x, a._y);	curveTo(c.x, c.y, b._x, b._y);	}a.onPress = b.onPress = startDrag;a.onRelease = b.onRelease = stopDrag;//Drawing a curve progressively. Could also be used for movement on a curve.var anchor1:Object = {x:0, y:0};var anchor2:Object = {x:100, y:100};var control:Object = {x:100, y:0};lineStyle(1);drawCurve(this.anchor1, this.anchor2, this.control, this);function drawCurve(a1:Object, a2:Object, c:Object, mc:MovieClip):Void {	var t:Number = 0;	mc.moveTo(a1.x, a1.y);	mc.onEnterFrame = function():Void {		this.lineTo(Math.pow(1 - t, 2) * a1.x + 2 * t * (1 - t) * c.x + Math.pow(t, 2) * a2.x, Math.pow(1 - t, 2) * a1.y + 2 * t * (1 - t) * c.y + Math.pow(t, 2) * a2.y)		t += 0.01;		if(t >= 1) {			delete this.onEnterFrame;		}	}}//---------------------------------------------//Here's some quadratic bezier related functions://------------------------------------------//parametric function of a quadratic curve; both x and y will equal this, depending on which component you passfunction quadBezCurve(p0:Number, p1:Number, p2:Number, t:Number):Number {	var d:Number = 1 - t;	return d * d * p0 + 2 * t * d * p1 + t * t * p2;}//derivative function of quadratic curvefunction quadBezCurveDeri(p0:Number, p1:Number, p2:Number, t:Number):Number {	return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));}//quadratic formulafunction quadForm(a:Number, b:Number, c:Number):Number {	return (-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);}//---------------------------------------------//Here's some quadratic bezier related functions://------------------------------------------//parametric function of a quadratic curve; both x and y will equal this, depending on which component you passfunction quadBezCurve(p0:Number, p1:Number, p2:Number, t:Number):Number {	var d:Number = 1 - t;	return d * d * p0 + 2 * t * d * p1 + t * t * p2;}//derivative function of quadratic curvefunction quadBezCurveDeri(p0:Number, p1:Number, p2:Number, t:Number):Number {	return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));}//quadratic formulafunction quadForm(a:Number, b:Number, c:Number):Number {	return (-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);}And here's some different approaches to drawing cubic bezier curves. I'd probably redo the first one to avoid the Point class which unnecessarily bloats things if you know how to do the math (which is actually fairly simple). I think Math.pow is slower than just writing the multiplication out too but I'm not sure.Code://MovieClip prototypes for approximating Cubic Bezier Curvesimport flash.geom.Point;//Generic Mid-Point ApproachMovieClip.prototype.drawMPCubicCurve = function(a1:Point, a2:Point, c1:Point, c2:Point):Void  {	var m1:Point = Point.interpolate(a1, c1, 0.5);	var m2:Point = Point.interpolate(c1, c2, 0.5);	var m3:Point = Point.interpolate(a2, c2, 0.5);	var m4:Point = Point.interpolate(m1, m2, 0.5);	var m5:Point = Point.interpolate(m2, m3, 0.5);	var ta2:Point = Point.interpolate(m4, m5, 0.5);	var tc1:Point = Point.interpolate(Point.interpolate(a1, m1, 0.5), m1, 0.5);	var tc2:Point = Point.interpolate(Point.interpolate(ta2, m4, 0.5), m4, 0.5);	var tc3:Point = Point.interpolate(Point.interpolate(ta2, m5, 0.5), m5, 0, 5);	var tc4:Point = Point.interpolate(Point.interpolate(a2, m3, 0.5), m3, 0.5);	var ta1:Point = Point.interpolate(tc1, tc2, 0.5);	var ta3:Point = Point.interpolate(tc3, tc4, 0.5);	this.moveTo(a1.x, a1.y);	this.curveTo(tc1.x, tc1.y, ta1.x, ta1.y);	this.curveTo(tc2.x, tc2.y, ta2.x, ta2.y);	this.curveTo(tc3.x, tc3.y, ta3.x, ta3.y);	this.curveTo(tc4.x, tc4.y, a2.x, a2.y);};//BSpline ApproachMovieClip.prototype.drawBSCubicCurve = function(a1:Point, a2:Point, c1:Point, c2:Point):Void  {	var a3:Point = Point.interpolate(c1, c2, 0.5);	this.moveTo(a1.x, a1.y);	this.curveTo(c1.x, c1.y, a3.x, a3.y);	this.curveTo(c2.x, c2.y, a2.x, a2.y);};//Iterated Equation ApproachMovieClip.prototype.drawIteratedCubicCurve = function(a1:Point, a2:Point, c1:Point, c2:Point):Void  {	this.moveTo(a1.x, a1.y);	var cx:Number = 3 * (c1.x - a1.x);	var bx:Number = 3 * (c2.x - c1.x) - cx;	var ax:Number = a2.x - a1.x - cx - bx;	var cy:Number = 3 * (c1.y - a1.y);	var by:Number = 3 * (c2.y - c1.y) - cy;	var ay:Number = a2.y - a1.y - cy - by;	for (var t:Number = 0; t <= 1; t += 0.01) {		this.lineTo(ax * Math.pow(t, 3) + bx * Math.pow(t, 2) + cx * t + a1.x, ay * Math.pow(t, 3) + by * Math.pow(t, 2) + cy * t + a1.y);	}	this.lineTo(a2.x, a2.y);};//ok- so curveTo creates a Bezier curve. A point on a bezier curve can be parameterized by t, provided 0 <= t <= 1. X(0) is equal to your first anchor point and X(1) is equal to the end anchor point. curveTo takes 3 points which means it's a quadratic Bezier curve.function getPointOnBezier( t:Number, p0:Point, p1:Point, p2:Point ) : Point {    t = Math.max( Math.min( 1, t ), 0 );    var tSq:Number = t * t;    var diff:Number = 1 - t;    var diffSq:Number = diff * diff;    diff *= 2 * t; //don't need to recalculate this for x and y    var point:Point = new Point();                            point.x = diffSq * p0.x + diff * p1.x + tSq * p2.x;    point.y = diffSq * p0.y + diff * p1.y + tSq * p2.y;    return point; }