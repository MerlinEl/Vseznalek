/*** fitImage* @ARG_object   the display object to work with* @ARG_width    width of the box to fit the image into* @ARG_height   height of the box to fit the image into* @ARG_center   should it offset to center the result in the box* @ARG_fillBox  should it fill the box, may crop the image (true), or fit the whole image within the bounds (false)**/ private function fitImageProportionally( ARG_object:DisplayObject, ARG_width:Number, ARG_height:Number, ARG_center:Boolean = true, ARG_fillBox:Boolean = true ):Bitmap {     var tempW:Number = ARG_object.width;    var tempH:Number = ARG_object.height;     ARG_object.width = ARG_width;    ARG_object.height = ARG_height;     var scale:Number = (ARG_fillBox) ? Math.max(ARG_object.scaleX, ARG_object.scaleY) : Math.min(ARG_object.scaleX, ARG_object.scaleY);     ARG_object.width = tempW;    ARG_object.height = tempH;     var scaleBmpd:BitmapData = new BitmapData(ARG_object.width * scale, ARG_object.height * scale);    var scaledBitmap:Bitmap = new Bitmap(scaleBmpd, PixelSnapping.ALWAYS, true);    var scaleMatrix:Matrix = new Matrix();    scaleMatrix.scale(scale, scale);    scaleBmpd.draw( ARG_object, scaleMatrix );     if (scaledBitmap.width > ARG_width || scaledBitmap.height > ARG_height) {         var cropMatrix:Matrix = new Matrix();        var cropArea:Rectangle = new Rectangle(0, 0, ARG_width, ARG_height);         var croppedBmpd:BitmapData = new BitmapData(ARG_width, ARG_height);        var croppedBitmap:Bitmap = new Bitmap(croppedBmpd, PixelSnapping.ALWAYS, true);         if (ARG_center) {            var offsetX:Number = Math.abs((ARG_width -scaleBmpd.width) / 2);            var offsetY:Number = Math.abs((ARG_height - scaleBmpd.height) / 2);             cropMatrix.translate(-offsetX, -offsetY);        }         croppedBmpd.draw( scaledBitmap, cropMatrix, null, null, cropArea, true );        return croppedBitmap;     } else {        return scaledBitmap;    } }package { 	import flash.display.BitmapData;	import flash.geom.ColorTransform;	import flash.geom.Matrix; 	/**	 * @author Maxime Cousinou	 */	public class BitmapManager { 		public static function reduceBitmapData(bmp:BitmapData, ratio:Number, transparent:Boolean = true):BitmapData { 			var bmpData:BitmapData = new BitmapData(Math.round(bmp.width * ratio), Math.round(bmp.height * ratio), transparent, 0x00FFFFFF);			var scaleMatrix:Matrix = new Matrix(bmpData.width / bmp.width, 0, 0, bmpData.height / bmp.height, 0, 0);			bmpData.draw(bmp, scaleMatrix); 			return bmpData;		} 		public static function resizeBitmapData(bmp:BitmapData, ratio:Number, transparent:Boolean = true):BitmapData { 			var bmpData:BitmapData = new BitmapData(Math.round(bmp.width * ratio), Math.round(bmp.height * ratio), transparent, 0x00FFFFFF);			var scaleMatrix:Matrix = new Matrix(bmpData.width / bmp.width, 0, 0, bmpData.height / bmp.height, 0, 0);			var colorTransform:ColorTransform = new ColorTransform();			bmpData.draw(bmp, scaleMatrix, colorTransform, null, null, true); 			return bmpData;		} 		public static function resampleBitmapData(bmp:BitmapData, ratio:Number, transparent:Boolean = true):BitmapData { 			if (ratio >= 1) {				return BitmapManager.resizeBitmapData(bmp, ratio, transparent);			} else {				var bmpData:BitmapData = bmp.clone();				var appliedRatio:Number = 1; 				do {					if (ratio < 0.5 * appliedRatio) {						bmpData = BitmapManager.resizeBitmapData(bmpData, 0.5, transparent);						appliedRatio = 0.5 * appliedRatio;					} else {						bmpData = BitmapManager.resizeBitmapData(bmpData, ratio / appliedRatio, transparent);						appliedRatio = ratio;					}				} while (appliedRatio != ratio); 				return bmpData;			}		}	}}