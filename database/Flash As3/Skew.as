function isFlippedHorizontally( obj:DisplayObject ):Boolean{    return obj.transform.matrix.a / obj.scaleX == -1;}trace( isFlippedHorizontally( yourObject ) );import fl.motion.MatrixTransformer;function isFlippedHorizontally( obj:DisplayObject ):Boolean{    return MatrixTransformer.getSkewYRadians( obj.transform.matrix ) / Math.PI == 1;}trace( isFlippedHorizontally( yourObject ) );function skewObj (obj, mcW, mcH, pt0, ptH, ptW){    function distance (pt1, pt2)	{        var dy = pt2.y-pt1.y;        var dx = pt2.x-pt1.x;        var side = Math.sqrt(dy*dy+dx*dx);        return side;    }    obj._x = pt0.x;    obj._y = pt0.y;    obj._yscale = 100;    var angleP2 = Math.atan2(ptW.y-pt0.y, ptW.x-pt0.x);    var angleP1 = Math.atan2(ptH.y-pt0.y, ptH.x-pt0.x);    var dAngle = (angleP1-angleP2)/2;    var arm = Math.sqrt(2)/2/Math.cos(dAngle);	    // original a 100x100 model, now use 1x1 model    obj._rotation = (180/Math.PI)*(angleP1-dAngle);    obj.mc._rotation = -45;    obj._yscale = 100*Math.tan(dAngle);    obj.mc._xscale = distance(ptW, pt0)*100/arm/mcW;    obj.mc._yscale = distance(ptH, pt0)*100/arm/mcH;}		H = obj.mc._height;W = obj.mc._width;function updateSkew (){    pt0 = {x:p0._x, y:p0._y};    ptH = {x:pH._x, y:pH._y};    ptW = {x:pW._x, y:pW._y};    skewObj(obj, W, H, pt0, ptH, ptW);}updateSkew();