/** * Makes an object inherit from a class. * Modifies the inheritance chain and calls the class constructor. * Commonly used to make a movie clip such as the root timeline * inherit from a custom class, e.g. * // on main timeline or in MTASC main() entry point: * applyClassToInstance(MyDocumentClass, this); * Works for AVM1 only, i.e. AS1 and AS2. * @param	theClass * @param	theInstance * @param	constructorArgs An optional Array of parameters for the class constructor. */function applyClassToInstance(theClass:Function, theInstance:Object, constructorArgs:Array):Void {	theInstance.__proto__ = theClass.prototype;  	theInstance.__constructor__ = theClass;	// run the constructor	theClass.apply(theInstance, constructorArgs);}class HashTable{    //list of entries    private var m_Items:Object;    //tracks total number of entries    private var m_length:Number;    //used to keep indexes of items based on class    private var m_Indexes:Object;    //setters & getters    public function get Items():Object    {        return this.m_Items;    }    public function set Items(value:Object)    {        this.m_Items = value;    }    public function get length():Number    {        return this.m_length;    }    //constructor    public function HashTable()    {        this.m_Items = new Object();        this.m_length = 0;        this.m_Indexes = new Object();    }    //Add an entry to the table    public function Add(key, value)    {        //checks to see if the key has already been defined so it doesn't double-count        if (this.m_Items[key] == undefined)        {            this.m_length++;        }        this.m_Items[key] = value;        //if there are any indexes created checks to see if the new item should be added to the index        for (var i in this.m_Indexes)        {            //if the value is an instance of the index type, add the key, otherwise remove old references if they no longer match            if (value instanceof this.m_Indexes[i].type)            {                this.m_Indexes[i].index[key] = key;            }            else            {                if (this.m_Indexes[i].index[key] != undefined)                {                    this.m_Indexes[i].index[key] = undefined;                    delete this.m_Indexes[i].index[key];                }            }        }    }    //remove an entry & any indexes    public function Remove(key)    {        if (this.m_Items[key] != null)        {            for (var i in this.m_Indexes)            {                if (this.m_Items[key] instanceof this.m_Indexes[i].type)                {                    this.m_Indexes[i].index[key] = undefined;                    delete this.m_Indexes[i].index[key];                }            }            this.m_Items[key] = undefined;            delete this.m_Items[key];            this.m_length--;        }    }    //clears all entries.  If optional WipeIndexes is true, then it deletes all index types    public function Clear(WipeIndexes:Boolean)    {        this.m_length = 0;        this.m_Items = new Object();        if (WipeIndexes)        {            this.m_Indexes = new Object();        }        else        {            for (var i in this.m_Indexes)            {                this.m_Indexes[i].index = new Object();            }        }    }    //removes the indexes    public function RemoveIndexes()    {        this.m_Indexes = new Object();    }    //removes the specified index    public function RemoveIndex(IndexString:String)    {        if (this.m_Indexes[IndexString] != undefined)        {            this.m_Indexes[IndexString] = undefined;            delete this.m_Indexes[IndexString];        }    }    //creates a copy of the HashTable    public function Clone(WithIndexes:Boolean):HashTable    {        var h:HashTable = new HashTable();        for (var i in this.m_Items)        {            h.Add(i, this.m_Items[i]);        }        if (WithIndexes)        {            for (var i in this.m_Indexes)            {                h.CreateIndexByType(this.m_Indexes[i].type, i);            }        }        return h;    }    //checks if the HashTable contains the specified key    public function ContainsKey(key):Boolean    {        return (this.m_Items[key] != undefined);    }    //checks if the HashTable contains the specified value    public function ContainsValue(value):Boolean    {        for (var i in this.m_Items)        {            if (this.m_Items[i] == value)            {                return true;            }        }        return false;    }    //creates an index for the passed class. Type is the class, typestring is the identifier to be called by the API    public function CreateIndexByType(type, typestring:String)    {        this.m_Indexes[typestring] = new Object();        this.m_Indexes[typestring].type = type;        this.m_Indexes[typestring].index = new Object();        for (var i in this.m_Items)        {            if (this.m_Items[i] instanceof type)            {                this.m_Indexes[typestring].index[i] = i;            }        }    }    //returns an object listing of all entries matching the index    public function GetByIndex(IndexString:String):Object    {        var o:Object = new Object();        for (var i in this.m_Indexes[IndexString].index)        {            o[i] = this.m_Items[i];        }        return o;    }}  