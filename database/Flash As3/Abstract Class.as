package com.joshtynjala.abstract{	import flash.errors.IllegalOperationError;	import flash.utils.describeType;	import flash.utils.getQualifiedClassName;	public class MyAbstractType	{		public function MyAbstractType(self:MyAbstractType)		{			if(self != this)			{				//only a subclass can pass a valid reference to self				throw new IllegalOperationError("Abstract class did not receive reference to self. MyAbstractType cannot be instantiated directly.");			}			//these functions MUST be implemented in subclasses			var unimplemented:Array = [mustBeOverridden];			//get the fully-qualified name the abstract class			var abstractTypeName:String = getQualifiedClassName(MyAbstractType);			//get a list of all the methods declared by the abstract class			//if a subclass overrides a function, declaredBy will contain the subclass name			var selfDescription:XML = describeType(this);			var methods:XMLList = selfDescription.method.(@declaredBy == abstractTypeName && unimplemented.indexOf(this[@name]) >= 0);			if(methods.length() > 0)			{				//we'll only get here if the function is still unimplemented				var concreteTypeName:String = getQualifiedClassName(this);				throw new IllegalOperationError("Function " + methods[0].@name + " from abstract class " + abstractTypeName + " has not been implemented by subclass " + concreteTypeName);			}		}		//implemented		public function alreadyImplemented():void		{			trace("Don't forget to list me in the Array of valid functions.");		}		//unimplemented		public function mustBeOverridden(param:String):void {};	}}package com.joshtynjala.abstract{	public class MyConcreteType extends MyAbstractType	{		public function MyConcreteType()		{			//pass "this" to clear the abstract check			super(this);		}		//implemented		override public function mustBeOverridden(param:String):void		{			trace("param:", param);		}	}}