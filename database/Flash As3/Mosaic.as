function Mosaic2(mc:MovieClip, blockSize:uint) {		//mc.cacheAsBitmap = true; 	ftrace("mc size:%w h:%", mc.width, mc.height)	var bd = new BitmapData(mc.mask_01.width, mc.mask_01.height, true, 0);	bd.draw(mc);		//var rect:Rectangle = bd.getColorBoundsRect(0xff000000,0xff000000,true);    //trace("rect:"+rect);		//var visibleRect:Rectangle = mc.getBounds(this).intersection(mc.mask_01.getBounds(this));	//trace("visrect:"+visibleRect);		ftrace("bd size:%w h:%", bd.width, bd.height)		var new_bd:BitmapData = getMosaic(bd, blockSize);	mc.addChild(new Bitmap(new_bd));}function getMosaic( source:BitmapData, blockSize:int ):BitmapData{	    var bitmap:Bitmap = new Bitmap( source );    bitmap.smoothing = true;  // blends pixels values    var smaller:BitmapData = new BitmapData( source.width  / blockSize, source.height / blockSize );    var matrix:Matrix = new Matrix();    matrix.scale( 1 / blockSize, 1 / blockSize );    smaller.draw( bitmap, matrix );    bitmap = new Bitmap( smaller );    //  Avoid "bitmap.smoothing = true" here to keep it blocky    var blocky:BitmapData = new BitmapData( source.width, source.height );    matrix.invert();  //  gives the opposite effect from before    blocky.draw( bitmap, matrix );    smaller.dispose();  //  always dispose BitmapData no longer needed    return blocky;}function crop( Mask:DisplayObject, Image:DisplayObject):BitmapData{	var cropArea:Rectangle = new Rectangle( 0, 0, Mask.width, Mask.height );	var croppedBitmap:Bitmap = new Bitmap( new BitmapData( Mask.width, Mask.height ), PixelSnapping.ALWAYS, true );	croppedBitmap.bitmapData.draw(Image, new Matrix(Image.scaleX, 0, 0, Image.scaleY, -Mask.x, -Mask.y) , null, null, cropArea, true );	trace("Mask.x = ",Mask.x);	trace("Mask.y = ",Mask.y);	return croppedBitmap.bitmapData;}/*import eff.Mosaic;import flash.utils.Timer;import flash.events.TimerEvent;//mosaicvar myMoz:Mosaic = new Mosaic(images_02);myMoz.x = 501;myMoz.pixelSize = 3;addChild(myMoz);var myTimer:Timer = new Timer(100, 10);myTimer.addEventListener(TimerEvent.TIMER, rend);myTimer.start();function rend(e:TimerEvent){	if ( myTimer.currentCount == myTimer.repeatCount){		myTimer.reset();		myTimer.start();	}else{		myMoz.pixelSize = myTimer.currentCount * 3;		myMoz.render();	}}*/import com.greensock.TweenLite;import flash.display.Sprite;var sc:Number = 1;var tmp_sprite:Sprite = new Sprite();addChild(tmp_sprite);TweenLite.to(tmp_sprite,1,{x:sc,onUpdate:rescale,onComplete:inDone});function rescale():void{	ftrace("sc:%", sc)}function inDone():void{	ftrace("transition done!")	removeChild(tmp_sprite)}