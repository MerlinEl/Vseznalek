package {	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.Loader;	import flash.display.LoaderInfo;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.ProgressEvent;	import flash.events.IOErrorEvent;	import flash.net.FileReference;	import flash.text.TextField;	import flash.text.TextFieldAutoSize;	import flash.utils.ByteArray;		import com.adobe.images.PNGEncoder;		import me.cosmodro.smuggle.PNGSmuggler;		/**	 * ...	 * @author srs	 */	public class Main extends Sprite 	{				private var fr:FileReference;		private var frv:FileReference;		private var fileref:FileReference;		private var progText:TextField;		private var tf2:TextField;		private var export:ByteArray;		private var filename:String;				private var vt:TextField;				public function Main():void 		{			if (stage) init();			else addEventListener(Event.ADDED_TO_STAGE, init);		}				private function init(e:Event = null):void 		{			removeEventListener(Event.ADDED_TO_STAGE, init);			// entry point						var tf:TextField = new TextField();			tf.text = "Encode File";			tf.selectable = false;			tf.autoSize = TextFieldAutoSize.LEFT;			tf.addEventListener(MouseEvent.CLICK, browseForFile);			tf.x = stage.stageWidth / 2 - tf.textWidth / 2;			tf.y = stage.stageHeight / 2 - 40;			addChild(tf);						tf2 = new TextField();			tf2.text = "Export";			tf2.selectable = false;			tf2.autoSize = TextFieldAutoSize.LEFT;			tf2.addEventListener(MouseEvent.CLICK, exportPNG);			tf2.x = stage.stageWidth / 2 - tf2.textWidth / 2;			tf2.y = stage.stageHeight / 2 + 40;						vt = new TextField();			vt.text = "Decode File";			vt.selectable = false;			vt.autoSize = TextFieldAutoSize.LEFT;			vt.addEventListener(MouseEvent.CLICK, browseForFileVerify);			vt.x = stage.stageWidth / 2 - tf.textWidth / 2;			vt.y = stage.stageHeight / 2;			addChild(vt);			progText = new TextField();			progText.text = "";			progText.selectable = false;			progText.x = 5;			progText.y = 5;			progText.autoSize = TextFieldAutoSize.LEFT;			addChild(progText);						fr = new FileReference();			fr.addEventListener(Event.SELECT, selectFile);			fr.addEventListener(ProgressEvent.PROGRESS, progress);			fr.addEventListener(Event.COMPLETE, fileUploadComplete);			fr.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);						frv = new FileReference();			frv.addEventListener(Event.SELECT, selectFile);			frv.addEventListener(ProgressEvent.PROGRESS, progress);			frv.addEventListener(Event.COMPLETE, fileUploadCompleteVerify);			frv.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);		}				private function browseForFile(event:MouseEvent):void {			fileref = fr;			fr.browse();		}				private function browseForFileVerify(event:MouseEvent):void {			fileref = frv;			frv.browse();		}				private function selectFile(event:Event):void {			progText.text = "Loading...";			fileref.load();		}				private function progress(event:ProgressEvent):void {			progText.text = Math.round((event.bytesLoaded / event.bytesTotal)*100) + "%";		}				private function fileUploadComplete(event:Event):void {			trace("upload complete");			progText.text = "Load Complete";			filename = fr.name+".png";			createPNG();		}				private function fileUploadCompleteVerify(event:Event):void {			trace("verify upload complete");			progText.text = "Load Complete";			filename = frv.name.substring(0, frv.name.length-4);			decodePNG();		}		private function ioErrorHandler(event:IOErrorEvent):void {			trace("aw snap!:", event);		}				private function createPNG():void {			var bytes:ByteArray = fr.data;			export = PNGSmuggler.createPNG(bytes);			trace("exported size: ", export.length);			addChild(tf2);		}				private function decodePNG():void {			var bytes:ByteArray = frv.data;			var loader:Loader = new Loader();			try{				loader.contentLoaderInfo.addEventListener(Event.COMPLETE, finishDecodePNG);				loader.loadBytes(bytes);			}catch (err:Error) {				trace("caught error: ", err);			}		}				private function finishDecodePNG(event:Event):void {			var bytes:ByteArray;			var bm:Bitmap = Bitmap(LoaderInfo(event.currentTarget).content);			export = PNGSmuggler.decodePNG(bm.bitmapData);			addChild(tf2);		}				private function exportPNG(event:MouseEvent):void {			trace("export");			var saveFr:FileReference = new FileReference();			saveFr.save(export, filename);			removeChild(tf2);			progText.text = "";		}			}	}package me.cosmodro.smuggle {	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.Loader;	import flash.events.Event;	import flash.geom.Rectangle;	import flash.utils.ByteArray;		import com.adobe.images.PNGEncoder;		import flash.display.LoaderInfo;		/**	 * ...	 * @author srs	 */	public class PNGSmuggler 	{		private static var origbytes:ByteArray;		private static var origbd:BitmapData;				public function PNGSmuggler() 		{					}				public static function createPNG(bytes:ByteArray):ByteArray {			origbytes = new ByteArray();			origbytes.writeBytes(bytes);						bytes.compress();			var bmp:BitmapData = byteArrayToBitmapData(bytes);			origbd = bmp;			return PNGEncoder.encode(bmp);		}				public static function decodePNG(bmp:BitmapData):ByteArray {			var bytes:ByteArray = bitmapDataToByteArray(bmp);			bytes.uncompress();			return bytes;		}						private static function byteArrayToBitmapData(bytes:ByteArray):BitmapData {			if (bytes.length > 0xffffff) {				throw new Error("bytearray too big!");			}			//can only store 2 bytes per pixel because of premultiplied bullshit.			//so, we need 1/2 as many pixels as bytes			var i:int;			var j:int;						var size:int = bytes.length + 4; //+4 for length pixel			if (size % 2 != 0) {				size += 1;			}			size = size / 3;			var sqrtsize:uint = Math.floor(Math.sqrt(size));			var tempBA:ByteArray = new ByteArray();			tempBA.position = 0;			var lengthBytes:uint = (0xff << 24) + bytes.length;			tempBA.writeUnsignedInt(lengthBytes);			bytes.position = 0;			var wholepx:int = Math.floor(bytes.length / 3);			var remaining:int = bytes.length % 3;			for (i = 0; i < wholepx; i++) {				tempBA.writeByte(0xff);				tempBA.writeByte(bytes.readUnsignedByte());				tempBA.writeByte(bytes.readUnsignedByte());				tempBA.writeByte(bytes.readUnsignedByte());			}			if (remaining == 2) {				tempBA.writeByte(0xff);				tempBA.writeByte(bytes.readUnsignedByte());				tempBA.writeByte(bytes.readUnsignedByte());				tempBA.writeByte(0xff);			}			if (remaining == 1) {				tempBA.writeByte(0xff);				tempBA.writeByte(bytes.readUnsignedByte());				tempBA.writeByte(0xff);				tempBA.writeByte(0xff);			}						var xsize:uint = sqrtsize;			var ysize:uint = sqrtsize;			if ((xsize * ysize) < size) {				xsize += 1;				if ((xsize * ysize) < size) {					ysize += 1;				}			}			var paddingSize:uint = (xsize * ysize)*4 - tempBA.length;			for (i = 0; i < paddingSize; i++) {				tempBA.writeByte(0); //randomize, for the hell of it?			}			var bmp:BitmapData = new BitmapData(xsize, ysize, true, 0x00000000);			tempBA.position = 0;			bmp.setPixels(bmp.rect, tempBA);			return bmp;		}				private static function bitmapDataToByteArray(bd:BitmapData):ByteArray {			var bytes:ByteArray = new ByteArray();			var bdbytes:ByteArray = bd.getPixels(bd.rect);			bdbytes.position = 0;			var length:int = bdbytes.readUnsignedInt() & 0xffffff;			var wholepx:int = Math.floor (length / 3);			for (var i:int = 0; i < wholepx; i ++) {			  var throwaway:uint = bdbytes.readUnsignedByte(); //throw away			  bytes.writeByte(bdbytes.readUnsignedByte());			  bytes.writeByte(bdbytes.readUnsignedByte());			  bytes.writeByte(bdbytes.readUnsignedByte());			}			var remaining:int = length % 3;			if (remaining == 2 ) {			  throwaway = bdbytes.readUnsignedByte(); //throw away			  bytes.writeByte(bdbytes.readUnsignedByte());			  bytes.writeByte(bdbytes.readUnsignedByte());			}			if (remaining == 1 ) {			  throwaway = bdbytes.readUnsignedByte(); //throw away			  bytes.writeByte(bdbytes.readUnsignedByte());			}			return bytes;		}				private static function compareByteArrays(origbytes:ByteArray, afterbytes:ByteArray):Boolean {			if (afterbytes.length != origbytes.length) {				return false;			}			origbytes.position = 0; 			afterbytes.position = 0;			for (var i:int = 0; i < origbytes.length; i++) {				var origByte:uint = origbytes.readUnsignedByte();				var otherByte:uint = afterbytes.readUnsignedByte();				if (origByte != otherByte) {					return false;				}			}			return true;					}				public static function test(bytes:ByteArray):void {			origbytes = bytes;			var loader:Loader = new Loader();			var pngbytes:ByteArray = createPNG(bytes);			loader.contentLoaderInfo.addEventListener(Event.COMPLETE, completeTest);			loader.loadBytes(pngbytes);		}				private static function completeTest(event:Event):void {			var bmp:Bitmap = Bitmap(LoaderInfo(event.currentTarget).content);			var k:int = 0;			for (var i:int = 0; i < bmp.height; i++) {				for (var j:int = 0; j < bmp.width; j++) {					var px1:uint = origbd.getPixel32(j, i);					var px2:uint = bmp.bitmapData.getPixel32(j, i);					if (px1 != px2) {						trace("px differ at index ", j, i, px1.toString(16), px2.toString(16));						k++;						if (k > 300) {							return;						}					}				}			}			trace("all px match!");			var afterbytes:ByteArray = decodePNG(bmp.bitmapData);			trace("bytearrays match?: " + compareByteArrays(origbytes, afterbytes));		}			}}