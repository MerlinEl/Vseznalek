mc.getBounds(targetCoordinateSpace)getBounds(this.parent);mc.getBounds(mc.parent);mc.getBounds(root);/*.getBounds "wrong" results.When getting bounds of an object relative to it's OWN coordinate system,those values will NOT be scaled. I was trying to figure out why my boundingboxes were off with the explosions in my game. I realized it was becauseI created the explosions by scaling the objects in the game, which madethe results of .getBounds unreliable.Solution:var oBnd:Rectangle = someObject.getBounds(someObject);var bLft:Number = oBnd.left   * someObject.scaleX;var bRgt:Number = oBnd.right  * someObject.scaleX;var bTop:Number = oBnd.top    * someObject.scaleY;var bBot:Number = oBnd.bottom * someObject.scaleY;//Now use bLft,bRgt,bTop & bBot to make your calculations.3HRS30MIN. Time For Bed.Sleep on why my collision checking is not working when trying to go from bounding box collision to circle-circle collision.*/var bounds = shape.getBounds(shape);Bound.graphics.drawRect(bounds.x, bounds.y, bounds.width, bounds.height);for (i = 0; i < 5; i++){    s = MovieClip(shape.getChildAt(i));	var b = s.getBounds(s);	s.graphics.lineStyle(1, 0xFF0000);	s.graphics.drawRect(b.x,b.y,b.width,b.height);}// ORpublic function getVisualBounds( p_source : DisplayObject ) : Rectangle  {    var rect : Rectangle;    var data : BitmapData;    const CANVAS_WIDTH : int = 2000;    const CANVAS_HEIGHT : int = 2000;    data = new BitmapData(CANVAS_WIDTH, CANVAS_HEIGHT, true, 0x00000000);    data.draw(p_source);    rect = data.getColorBoundsRect(0xff000000, 0x00000000, false);    if(rect == null) rect = new Rectangle;    data.dispose();    data = null;    return rect;  }