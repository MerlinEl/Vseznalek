(function(window, undefined) {      /*      a hash that accepts any object as a key.      keys are stored on itself, values go in the `values` property   */   function HashTable(arrayOfKeys, arrayOfValues) {      this.values = []      this._build(arrayOfKeys || null, arrayOfValues || null)   }   // extend Array   HashTable.prototype = new Array      HashTable.prototype._build = function(keys, values) {      if(keys && keys.length) {         values = values || []         for(var i = 0, n = keys.length; i < n; i++) {            this.push(keys[i], values[i])         }      }   }      // overrides   HashTable.prototype.push = function() {      if(arguments && arguments.length) {         for(var i=0, n = arguments.length; i < n; i++) {            // HashTable.push(key, "value", key2, "value2")            if(0 === i%2) {               // even i means it's a key               Array.prototype.push.call(this, arguments[i])            }else {               // odd i means it's a value               this.values.push(arguments[i])            }         }      }      return this.length   }      HashTable.prototype.pop = function() {      var // returns a new HashTable containing the popped key/value      poppedKey = Array.prototype.pop.call(this),      poppedValue = this.values.pop(),      r = new HashTable()      r.push(poppedKey, poppedValue)            return r   }      HashTable.prototype.unshift = function() {      if(arguments && arguments.length) {         for(var i=0, n = arguments.length; i < n; i++) {            if(0 === i%2) {               Array.prototype.unshift.call(this, arguments[i])            }else {               this.values.unshift(arguments[i])            }         }      }      return this.length   }      HashTable.prototype.shift = function() {      var // returns a new HashTable containing the shifted key/value      shiftedKey = Array.prototype.shift.call(this),      shiftedValue = this.values.shift(),      r = new HashTable()      r.push(shiftedKey, shiftedValue)            return r   }      HashTable.prototype.splice = function(index, howMany) {      index = isNaN(index) ? 0 : index      howMany = isNaN(howMany) ? 1 : howMany      var elements = Array.prototype.slice.call(arguments,2),      splicedKeys = Array.prototype.splice.call(this, index, howMany),      splicedValues = this.values.splice(index, howMany)            if(elements && elements.length) {         for(var i=0, n=elements.length; i < n; i++) {            if(0 === i%2) {               Array.prototype.splice.call(this, index, 0, elements[i])            }else {               this.values.splice(index, 0, elements[i])            }         }      }            return new HashTable(splicedKeys, splicedValues)   }      HashTable.prototype.slice = function(begin, end) {      begin = begin || 0      end = end || this.length            var       slicedKeys = Array.prototype.slice.call(this, begin, end),      slicedValues = this.values.slice(begin, end)            return new HashTable(slicedKeys, slicedValues)   }      HashTable.prototype.concat = function() {      var r = this.slice()      if(arguments && arguments.length) {         for(var i=0,n=arguments.length; i < n; i++) {            if(HashTable.isHashTable(arguments[i])) {               arguments[i].forEach(function(el) {                  r.push(el.key, el.value)               })            }else {               if(0 === i%2) {                  Array.prototype.push.call(this, arguments[i])               }else {                  this.values.push(arguments[i])               }            }         }      }            return r   }      HashTable.prototype.forEach = function(callback, thisArg) {      for(var i=0, n=this.length; i < n; i++) {         if(this[i] !== undefined) {            if(thisArg) {               callback.call(thisArg, {key:this[i], value:this.values[i]}, i, this)            }else {               callback({key:this[i], value:this.values[i]}, i, this)            }         }      }   }      HashTable.prototype.reverse = function() {       Array.prototype.reverse.call(this)      this.values.reverse()   }      // array methods that are not or yet to be implemented   HashTable.prototype.every = function() {       return this    }   HashTable.prototype.filter = function() {       return this    }   HashTable.prototype.find = function() {       return this    }   HashTable.prototype.findIndex = function() {       return this    }   HashTable.prototype.join = function() {       return this    }   HashTable.prototype.map = function() {       return this    }   HashTable.prototype.reduce = function() {       return this    }   HashTable.prototype.reduceRight = function() {       return this    }   HashTable.prototype.some = function() {       return this    }   HashTable.prototype.sort = function() {       return this    }         /* extensions   ----------------*/      // just an alias for indexOf   HashTable.prototype.indexOfKey = function(key) {      return this.indexOf(key)   }      HashTable.prototype.indexOfValue = function(value) {      return this.values.indexOf(value)   }      HashTable.prototype.lastIndexOfKey = function(key) {      return this.lastIndexOf(key)   }      HashTable.prototype.lastIndexOfValue = function(value) {      return this.values.lastIndexOf(value)   }      HashTable.prototype.getKeys = function() {      return Array.prototype.slice.call(this)   }      HashTable.prototype.getValues = function() {      return this.values.slice()   }      HashTable.prototype.fetch = function(index) {      return this.values[index]   }      HashTable.prototype.fetchObject = function(index) {      return { key: this[index], value: this.values[index] }   }      HashTable.prototype.fetchTo = function(index, array) {      array.push(this[index], this.values[index])      return array   }      HashTable.prototype.get = function(key) {      return this.values[this.indexOf(key)]   }      HashTable.prototype.set = function(key, value) {      var idx = this.indexOf(key)      if(-1 === idx) {         // set new         this.push(key, value)      }else {         this.values[idx] = value      }   }      Object.defineProperties(HashTable.prototype, {      _isHashTable: {         value: true,         writable: false,         configurable: false,         enumerable: false      }   })      // static   HashTable.isHashTable = function(obj) {      return obj._isHashTable || false   }      // expose   window.HashTable = HashTable   })(window)