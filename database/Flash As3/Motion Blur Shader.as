Hi All,I copied a motion blur filter from starling framework and I just tried to run it, but the output texture is distorted.  I donâ€™t know why ?// A simple vertex shader which does a 3D transformation   // for simplicity, it is used by all four shaders   var vertexShaderAssembler:AGALMiniAssembler =     new AGALMiniAssembler();   vertexShaderAssembler.assemble    (      Context3DProgramType.VERTEX,     // 4x4 matrix multiply to get camera angle      "m44 op, va0, vc0\n" +     // tell fragment shader about XYZ     "mov v0, va0\n" +     // tell fragment shader about UV     "mov v1, va1\n" +     // tell fragment shader about RGBA     "mov v2, va2\n"    );            var step:String =    "add ft0.xy, ft0.xy, fc0.xy \n"+    "tex ft2, ft0.xy, fs0<2d, clamp, linear, nomip> \n" +    "add ft1, ft1, ft2 \n"      var fragmentProgramCode:String =    "mov ft0.xy, v0.xy \n" +    "tex ft1, ft0.xy, fs0<2d, clamp, linear, nomip> \n"      var numSteps:int = mSteps - 1;   for (var i:int = 0; i < numSteps; i++)   {    fragmentProgramCode += step;   }      fragmentProgramCode += "div oc, ft1, fc0.zzz\n"         // textured using UV coordinates   var fragmentShaderAssembler1:AGALMiniAssembler    = new AGALMiniAssembler();   fragmentShaderAssembler1.assemble    (      Context3DProgramType.FRAGMENT,      fragmentProgramCode    );   // combine shaders into a program which we then upload to the GPU   shaderProgram1 = context3D.createProgram();   shaderProgram1.upload(    vertexShaderAssembler.agalcode,     fragmentShaderAssembler1.agalcode); In each framevar tSize:Number = (512+512) * .50;   mVars[0] = mAmount * Math.cos(mAngle) / tSize;   mVars[1] = mAmount * Math.sin(mAngle) / tSize;   mVars[2] = 4;      context3D.setProgramConstantsFromVector(Context3DProgramType.FRAGMENT, 0, mVars, 1);      context3D.setTextureAt(0, myTexture);   context3D.setProgram ( shaderProgram1 );         modelmatrix.appendRotation(t*0.7, Vector3D.Y_AXIS);   modelmatrix.appendRotation(t*0.6, Vector3D.X_AXIS);   modelmatrix.appendRotation(t*1.0, Vector3D.Y_AXIS);   modelmatrix.appendTranslation(-3, 3, 0);      // clear the matrix and append new angles   modelViewProjection.identity();   modelViewProjection.append(modelmatrix);   modelViewProjection.append(viewmatrix);   modelViewProjection.append(projectionmatrix);      // pass our matrix data to the shader program   context3D.setProgramConstantsFromMatrix(    Context3DProgramType.VERTEX,     0, modelViewProjection, true );      // associate the vertex data with current shader program   // position   context3D.setVertexBufferAt(0, vertexBuffer, 0,     Context3DVertexBufferFormat.FLOAT_3);   // tex coord   context3D.setVertexBufferAt(1, vertexBuffer, 3,     Context3DVertexBufferFormat.FLOAT_2);   // vertex rgba   context3D.setVertexBufferAt(2, vertexBuffer, 8,     Context3DVertexBufferFormat.FLOAT_4);      // finally draw the triangles   context3D.drawTriangles(    indexBuffer, 0, meshIndexData.length/3);      // present/flip back buffer   // now that all meshes have been drawn   context3D.present();  