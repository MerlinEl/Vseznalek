//I think disposable is for anything that GC can't take care of automatically, and event references count in my book. //Here is a helper class I came up with.public class DisposableEvent<T> : IDisposable    {        EventHandler<EventArgs<T>> Target { get; set; }        public T Args { get; set; }        bool fired = false;        public DisposableEvent(EventHandler<EventArgs<T>> target)        {            Target = target;            Target += new EventHandler<EventArgs<T>>(subscriber);        }        public bool Wait(int howLongSeconds)        {            DateTime start = DateTime.Now;            while (!fired && (DateTime.Now - start).TotalSeconds < howLongSeconds)            {                Thread.Sleep(100);            }            return fired;        }        void subscriber(object sender, EventArgs<T> e)        {            Args = e.Value;            fired = true;        }        public void Dispose()        {            Target -= subscriber;            Target = null;        }    }which lets you write this code :Class1 class1 = new Class1();            using (var x = new DisposableEvent<object>(class1.Test))            {                if (x.Wait(30))                {                    var result = x.Args;                }            }//One side effect, you must not use the event keyword on your events, //since that prevents passing them as a parameter to the helper constructor, //however, that seems to not have any ill effects.