--https://www.codeproject.com/Articles/11939/Evaluate-C-Code-Eval-Functiontry(destroyDialog uiGrabber)catch()rollout uiGrabber "UI Grabber"(	fn generateAssembly = 	(		str="using System;"		str+="using System.Runtime.InteropServices;"		str+="using System.Windows.Forms;"		str+="using System.Text;"		str+="using System.Collections.Generic;"				str+="namespace Win32Utils"		str+="{"		str+="class Win32Helper"		str+="{"					str+="[DllImport(\"user32.dll\", SetLastError = true, CharSet = CharSet.Auto)]"		str+="private static extern int GetClassName(IntPtr hWnd, StringBuilder lpClassName, int nMaxCount);"        str+="public static string GetClassName(IntPtr hWnd)"        str+="{"        str+=" 	  StringBuilder sb = new StringBuilder(255);"        str+="    GetClassName(hWnd, sb, 255);"        str+="    return sb.ToString();"        str+="}"				str+="[StructLayout(LayoutKind.Sequential)]"		str+="public struct POINT	{ public int X;	public int Y; }"				str+="public struct RECT { public int Left; public int Top; public int Right; public int Bottom; }"     				str+="[DllImport(\"user32.dll\")]"		str+="public static extern bool ScreenToClient(IntPtr hWnd, ref POINT lpPoint);"				str+="[DllImport(\"user32.dll\")]"		str+="public static extern bool ClientToScreen(IntPtr hWnd, ref POINT lpPoint);"				str+="[DllImport(\"user32.dll\")]"		str+="public static extern bool IsWindowVisible(IntPtr hWnd);" 				str+="[DllImport(\"user32.dll\")]"		str+="public static extern bool GetWindowRect(IntPtr hWnd, out RECT rect);" 				str+="public static int[] GetWindowRect(IntPtr hWnd)" 		str+="{"		str+="		RECT r = new RECT();"		str+="		GetWindowRect(hWnd, out r);"		str+="		return new int[] {r.Left, r.Top, r.Right - r.Left, r.Bottom - r.Top};"		str+="}"				str+="}"		str+="}"		local csharpProvider = dotnetobject "Microsoft.CSharp.CSharpCodeProvider"		local compilerParams = dotnetobject "System.CodeDom.Compiler.CompilerParameters"		compilerParams.ReferencedAssemblies.addRange #("System.dll","System.Windows.Forms.dll","System.Drawing.dll")		compilerParams.GenerateInMemory = on		local compilerResults = csharpProvider.CompileAssemblyFromSource compilerParams #(str)				for er =0 to compilerResults.errors.count-1 do print (compilerResults.errors.item[er].tostring())		return compilerResults.CompiledAssembly.createInstance "Win32Utils.Win32Helper"	)		local win32 = generateAssembly()	local controlStrings = stringStream ""	local numControls = 0	local parentRect				fn ToIntPtr hWnd =	(		return (dotnetObject "System.IntPtr" hWnd)	)		fn grabButton hWnd =	(		local rect = win32.GetWindowRect (ToIntPtr hWnd)		local txt = uiAccessor.getWindowText hWnd		local x = rect[1] - parentRect[1]		local y = rect[2] - parentRect[2]		format "Button btn% \"%\" pos:[%, %] width:% height:%" numControls txt x y rect[3] rect[4] to:controlStrings		numControls += 1	)		fn grabComboBox hWnd =	(		local rect = win32.GetWindowRect (ToIntPtr hWnd)		local txt = uiAccessor.getWindowText hWnd		local x = rect[1] - parentRect[1]		local y = rect[2] - parentRect[2]				local CB_GETCOUNT = 0x0146		local CB_GETLBTEXT = 0x0148		local numItems = windows.SendMessage hWnd CB_GETCOUNT 0 0		local marshal = dotnetClass "System.Runtime.InteropServices.Marshal"				format "DropDownList ddl% \"%\" pos:[%, %] width:% height:% items:#(" numControls txt x y rect[3] rect[4] to:controlStrings		numControls += 1				for i = 1 to numItems do		(			local ptr = marshal.AllocHGlobal 255 asDotNetObject:on			windows.sendMessage hWnd CB_GETLBTEXT (i-1) (ptr.ToInt64())			local str = marshal.PtrToStringANSI ptr			format "\"%\"" str to:controlStrings			if (i != numItems) do format "," str to:controlStrings			marshal.FreeHGlobal ptr		)				format ")" to:controlStrings		)		local controlTypes = #("CustButton", "ComboBox")	local controlFunctions = #(grabButton, grabComboBox)		fn grabControl hWnd =	(			local typeStr = UIAccessor.getWindowClassName hWnd		local typeIndex = findItem controlTypes typeStr		if (typeIndex > 0) do		(			controlFunctions[typeIndex] hWnd		)	)		fn grabUI hWnd =	(		numControls = 0		controlStrings = stringStream ""		parentRect = win32.getWindowRect (ToIntPtr hWnd)		format "rollout GrabbedRollout \"Grabbed Rollout\" width:% height:%(" parentRect[3] parentRect[4] to:controlStrings 		for w in windows.getChildrenHwnd hWnd where win32.IsWindowVisible (ToIntPtr w[1]) do grabControl w[1]		format ")" to:controlStrings		setClipBoardText (controlStrings as string)	)		editText txtHandle "Root Handle" width:150	button btnGrab "Grab!" width:70 height:25	on btnGrab pressed do	(		local hWnd = txtHandle.text as integer		if hWnd == undefined or not (UIAccessor.IsWindow hWnd) do return "Invalid window handle!"		grabUI hWnd	))createDialog uiGrabber