sel_obj = $export_node = $fn offsetRotateObject sel_obj export_node = (--start animate		sliderTime = 10f	set animate on	--select longest edge	sel_e = polyOp.getEdgeSelection sel_obj	e_verts = polyOp.getVertsUsingEdge sel_obj sel_e	p1 = polyOp.getVert sel_obj (e_verts as array)[1]	p2 = polyOp.getVert sel_obj (e_verts as array)[2]--calculate rotation Z	p3 = [p2.x, p1.y, p1.z] --[top right] point (from bounding box)	v1 = p2 - p1 --old vector	v2 = p3 - p1 --new vector--create dummy helper (oriented along edge p1 - p2)	du = dummy boxsize:[1000, 1000, 1000] pos:p1 dir:v1	export_node.parent = du	v_angle_z = getVectorsAngle v1 v2	du.rotation.z_rotation += v_angle_z--calculate rotation X	p2 = polyOp.getVert sel_obj (e_verts as array)[2]	p4 = [p2.x, p1.y, p1.z] --[front bottom] point (from bounding box)	v1 = p2 - p1 --old vector		v3 = p4 - p1 --new vector	v_angle_x = getVectorsAngle v1 v3	format "angles z:% x:%\n" v_angle_z v_angle_x--animate dummy	sliderTime = 20f	--tm_2 = (matrix3 [1,0,0] [0,1,0] [0,0,1] p4)	--tm_2 = matrix3 1	--preRotate tm_2  (eulertoquat (eulerAngles 0 0 -v_angle_z))	--tm_2 = m_2 = matrixFromNormal v1	--tm_2 = (matrix3 [1,0,0] [0,1,0] v3) --vectors x, y, z, pos	--tm_2 = (eulerAngles 0 0 -v_angle_z) as matrix3	--ang = tm_2.rotation as eulerAngles	--ang.x = 0	--tm_2 = du.transform.rotation as matrix3	--tm_2 = du.transform	--tm_2 = preRotate tm_2 (eulertoquat ((eulerAngles 0 0 -v_angle_z)))	--in coordsys tm_2 	du.rotation.x_rotation += v_angle_x--end animate		set animate off)offsetRotateObject $ $lh_51_tunnel_a_geometryv1 = p2 - p1dummy boxsize:[1000, 1000, 1000] pos:p3 dir:v1dummy boxsize:[1000, 1000, 1000] pos:p2 dir:v1dummy boxsize:[1000, 1000, 1000] pos:p4 dir:v1