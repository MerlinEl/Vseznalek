fn getFaceUVWverts gcofor v in (polyOp.getMapFace $ 1 3) do format "Vert #% UVW = %" v (polyOp.getMapVert $ 1 v)polyOp.setVertSelection $ 3gco = modpanel.getcurrentobject()	element_pos = gco.getPivotOffset()gco.selectVertices #{3, 35, 36}gco.selectFaces chosen_facesall_faces = gco.getSelectedFaces() struct VERTEX (geo_index, uv_index, pos, uvs)fn getObjectData obj = (		if superClassOf obj != GeometryClass do return #()	local smesh = snapshotAsMesh obj	local tricount = smesh.numFaces	local vertcount = tricount * 3	local vert = for a = 1 to vertcount collect (VERTEX())	for i = 0 to tricount-1 do ( -- for each triangle		vert[i*3+1].geo_index = i+1		vert[i*3+2].geo_index = i+2		vert[i*3+3].geo_index = i+3				local vtx = getFace smesh (i+1) -- vtx = a point3 containing 3 vertex indices		vert[i*3+1].pos = getVert smesh vtx.x -- copy to new vertex list		vert[i*3+2].pos = getVert smesh vtx.y		vert[i*3+3].pos = getVert smesh vtx.z		local uv = meshop.getMapFace smesh 1 (i+1) -- uv = an array of uv vertex indices				vert[i*3+1].uv_index = int(uv.x)		vert[i*3+2].uv_index = int(uv.y)		vert[i*3+3].uv_index = int(uv.z)				vert[i*3+1].uvs = meshop.getMapVert smesh 1 uv.x		vert[i*3+2].uvs = meshop.getMapVert smesh 1 uv.y		vert[i*3+3].uvs = meshop.getMapVert smesh 1 uv.z			)	delete smesh	vert)obj_data = getObjectData $obj_data[13]print obj_datafn getUVpos obj channel theVertex = (	local vertexFaces = polyOp.getFacesUsingVert obj #{theVertex}	local mapVertsArray = #() , mapVertsPosArray = #() , optimizedMapVertsArray = #() , optimizedMapVertsPosArray = #()	for currentFace in vertexFaces do (		local polyFace = polyOp.getFaceVerts obj currentFace		local mapFace = polyOp.getMapFace obj channel currentFace		local mapVertex = mapFace[findItem polyFace theVertex]		append mapVertsArray mapVertex		local mapVertexPos = polyOp.getMapVert obj channel mapVertex		append mapVertsPosArray mapVertexPos		if findItem optimizedMapVertsArray mapVertex == 0 do (			append optimizedMapVertsArray mapVertex			append optimizedMapVertsPosArray mapVertexPos			)		)	format "mapVertsArray=% " mapVertsArray	format "mapVertsPosArray=% " mapVertsPosArray	format "optimizedMapVertsArray=% " optimizedMapVertsArray	format "optimizedMapVertsPosArray=% " optimizedMapVertsPosArray	optimizedMapVertsPosArray	)clearListener()if selection.count!=0 and classof selection[1]==Editable_Poly 	do (		local obj=selection[1]		local channel=1		local theVertex=5		getUVpos obj channel theVertex		)Here is what you need to do Spirit Guide,There is a 1:1 relationship between then index you use to fetch the vertex information and the texture information. So use that index to fetch the texture coordinates via the getTVerts function. This will return a Point2 with an X,Y in the range of 0 to 1. Simply multiply the X and Y by the width and height of the map you are trying to generate!the_tvert = getTVert meshObject indexx_pos = (the_tvert.x * bmp_resolution)y_pos = (bmp_resolution-(the_tvert.y * bmp_resolution))Generally the Y is upside down, so you need to turn it around.     channel = 1;    local num_faces = polyop.getNumFaces $;    for f = 1 to num_faces do(    	uvF = polyOp.getMapFace $ channel f;    	    	uvVert1 = polyOp.getMapVert $ channel uvF[1];    	uvVert2 = polyOp.getMapVert $ channel uvF[2];    	uvVert3 = polyOp.getMapVert $ channel uvF[3];    	--manipulate each uvVert, like uvVert1.x = 0.5;     	--or like this: uvVert2.x+= 0.5;     	    	--store them back    	polyOp.setMapVert $ channel uvF[1] uvVert1;    	polyOp.setMapVert $ channel uvF[2] uvVert2;    	polyOp.setMapVert $ channel uvF[3] uvVert3;    )