-------------------------------------------------------------------/***@Author d3coy 2006*@Mod Merlin El 2020*/fn getBoundingBoxFromVerts obj verts = (	 	if classof obj != Editable_Poly do return false	verts  = verts as array		local verts_pos = for v in verts collect polyop.getvert obj v	local verts_count = verts.count	local avg_pos = [0,0,0]	local zComp = #()	local xComp = #()	local yComp = #()	zComp[verts_count] = xComp[verts_count] = yComp[verts_count] = undefined	local zMax, zMin, xMax, xMin, yMax, yMin, xVect, yVect, zVect, theMatrix,		  theLength, theWidth, theHeight, xAmt, yAmt, zAmt, zMaxHold, zMinHold		--Get average position	for v in verts_pos do avg_pos += v	avg_pos /= verts_count		--Get farthest vert	for x = 1 to verts_count do		zComp[x] = distance avg_pos verts_pos[x]		zMaxHold = verts[(finditem zComp (amax zComp))]	zMax = polyop.getvert obj zMaxHold		--Get farthest vert from farthest vert (the 2 extremes)	for x = 1 to verts_count do		zComp[x] = distance zMax verts_pos[x]		zMinHold = verts[(finditem zComp (amax zComp))]	zMin = polyop.getvert obj zMinHold		--Construct matrix from vectors	zVect = normalize (zMax - zMin)	xVect = normalize (cross [0,0,1] zVect)	yVect = normalize (cross xVect zVect)	theMatrix = matrix3 xVect yVect zVect [0,0,0]		--Determine dimensions and construct box	in coordsys theMatrix	(				for x = 1 to verts_count do		(			thePos = polyop.getvert obj verts[x]			xComp[x] = thePos.x			yComp[x] = thePos.y		)				xMax = polyop.getvert obj verts[(finditem xComp (amax xComp))]		xMin = polyop.getvert obj verts[(finditem xComp (amin xComp))]		yMax = polyop.getvert obj verts[(finditem yComp (amax yComp))]		yMin = polyop.getvert obj verts[(finditem yComp (amin yComp))]		zMax = polyop.getvert obj zMaxHold		zMin = polyop.getvert obj zMinHold				xAmt = ((xMax + xMin) / 2.).x		yAmt = ((yMax + yMin) / 2.).y		zAmt = ((zMax + zMin) / 2.).z				theWidth = xMax.x - xMin.x		theLength = yMax.y - yMin.y		theHeight = distance zMax zMin	)		theBox = box width:theWidth length:theLength height:theHeight xray:true	theBox.pivot = theBox.center	theBox.transform = theMatrix		in coordsys theMatrix(move theBox [xAmt, yAmt, zAmt])	completeredraw()	theBox)  obj = $esel =  polyOp.getEdgeSelection objverts = polyOp.getVertsUsingEdge obj eselbo = getBoundingBoxFromVerts obj verts-------------------------------------------------------------------(		if selection.count == 1 and classOf (curO = selection[1]) == Editable_Poly do	(		if (selFacesBA = polyop.getFaceSelection curO).numberset != 0 do		(			faceVertsBA = polyop.getVertsUsingFace curO selFacesBA			curOtransform = curO.transform			curO.rotation = quat 0 0 0 1			with redraw off 			(				tMesh = mesh mesh:curO.mesh				tMesh.pos = curO.pos				tMesh.objectOffsetPos = curO.objectOffsetPos				if faceVertsBA.count > 0 do 				(					delete tMesh.verts[((tMesh.verts as BitArray) - (faceVertsBA))]				)				c = snapshot tMesh				c.transform = matrix3 1-- 				d = dummy boxsize:(c.max - c.min)				size = (c.max - c.min)				d = Box lengthsegs:1 widthsegs:1 heightsegs:1 length:size[2] width:size[1] height:size[3]				centerPivot d				delete c				d.transform = tMesh.transform				d.pos = tMesh.center				d.name = tMesh.name + "_box"				--	very ugly, but skip all math operations				d.parent = curO				delete tMesh				curO.transform = curOtransform				d.parent = undefined			)		)	))----------------------------------------------------------------------test 01obj =  $mod_xform = XForm ()--addModifier obj mod_xform ui:on modPanel.addModToSelection mod_xform ui:onmod_xform.Gizmo.posmod_xform.Gizmo.transformverts = polyOp.getVertSelection objverts_center = [0,0,0]for v in verts do verts_center += polyop.getvert obj vcp64posL = verts_center / verts.numbersetobjTM=b.objecttransformmodTM=(getModContextTM obj mod_xform)*mod_xform.Gizmo.transformmodBBMin=getModContextBBoxMin obj mod_xformmodBBMax=getModContextBBoxMax obj mod_xformcp64posW=(modBBMin+(cp64posL*(modBBMax-modBBMin)))* (inverse modTM) * objTM--test 2-- return number of control points (doesn't check if they can be get/set)fn ffdNumCPs ffdmod = (	ffdmod["Master"].numSubs)-- convert FFD local (normalized) coordinates to world coordinates-- obj = object containing the modifier-- ffdmod = the actual modifier-- pos = the local coordinatefn ffdLocalToWorldPos obj ffdmod pos = (	objTM = obj.objecttransform	modTM = (getModContextTM obj ffdmod) * ffdmod.lattice_transform.value	modBBMin = getModContextBBoxMin obj ffdmod	modBBMax = getModContextBBoxMax obj ffdmod	(modBBMin + (pos * (modBBMax-modBBMin)) * (inverse modTM) * objTM))-- convert world coordinates to FFD local (normalized) coordinates-- obj = object containing the modifier-- ffdmod = the actual modifier-- pos = the world coordinatefn ffdWorldToLocalPos obj ffdmod pos = (	objTM = obj.objecttransform	modTM = (getModContextTM obj ffdmod) * ffdmod.lattice_transform.value	modBBMin = getModContextBBoxMin obj ffdmod	modBBMax = getModContextBBoxMax obj ffdmod	(pos - modBBMin) * (inverse objTM) * inverse modTM / (modBBMax-modBBMin))-- get an FFD mod's control point's world coordinate-- obj = object containing the modifier-- ffdmod = the actual modifier-- i = control point indexfn ffdGetWorldPos obj ffdmod i = (	cp = ffdmod["Master"][i]	ffdLocalToWorldPos obj ffdmod cp.value)-- set an FFD mod's control point's world coordinate-- obj = object containing the modifier-- ffdmod = the actual modifier-- i = control point index-- pos = new world positionfn ffdSetWorldPos obj ffdmod i pos = (	cp = ffdmod["Master"][i]	cp.value = ffdWorldToLocalPos obj ffdmod pos)