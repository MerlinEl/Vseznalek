---------------------------------------------------------------------------------------------------------------------struct sWaitAndRun (			 	fn performDelayedTask s a = (		s.enabled = off --stop timer		dotnet.RemoveEventHandler s "Tick" sWaitAndRun.performDelayedTask        		s.tag.runWorkerAsync()	),	fn run delay func = (		local wtimer = dotnetobject "Windows.Forms.Timer"		local thread = dotNetObject "system.componentModel.backgroundWorker"		dotnet.addEventHandler thread "DoWork" func		wtimer.tag = thread		wtimer.Interval = delay --set single tick delay		dotnet.AddEventHandler wtimer "Tick" performDelayedTask		wtimer.enabled = on --start timer	))ex = sWaitAndRun() --create instanceex.run 3000 ( --run delayed function	fn exportModel = ( format "Delayed message after:% ms\n" 3000 ))	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------MULTITHREADING DEFINITION--------------------------------------------------global  prog_rol, --#(progressform, #(progressbars))  tasks = #(), --array of tasks, every task'll be executed in separate thread  finished = 0, --finished tasks count  senders = #() --task sendersfn progcreate state =( hForm = dotNetObject "System.Windows.Forms.Form" hForm.clientsize = dotNetObject "System.Drawing.Size" 500 (20*tasks.count) hForm.FormBorderStyle = hForm.FormBorderStyle.FixedToolWindow hForm.StartPosition = hForm.StartPosition.CenterScreen hForm.TopMost = true hform.text = state bars = #() for i = 1 to tasks.count do (  prog = dotNetObject "System.windows.forms.ProgressBar"  prog.size = dotNetObject "System.Drawing.Size" 500 20  prog.location = dotNetObject "System.Drawing.Point" 0 (20*(i - 1))  prog.value = 0  hForm.controls.add prog  append bars prog ) hForm.show() progressStart state prog_rol = #(hForm,bars))fn progupdate sender task =(try --to avoid error if progressform's closed( overall = 0 for bid = 1 to prog_rol[2].count do (  bar = prog_rol[2][bid]  if bid == task.userstate then   bar.value = task.progresspercentage  overall += bar.value ) progressupdate (overall*100/(tasks.count*100)) --refresh global progress) catch())fn checkresult =(if finished == (tasks.count - 1) then( free tasks free senders prog_rol[1].close() progressend() messagebox "All tasks're finished!")else finished += 1)fn dowork processname =( senders = #() if tasks.count > 0 then (  progcreate processname  finished = 0  bwthreads = #()  for task in tasks do  (   thread = (dotnetobject "System.ComponentModel.BackGroundWorker")   thread.WorkerReportsProgress = true   dotNet.addEventHandler thread "DoWork" task[3]   dotNet.addEventHandler thread "ProgressChanged" progupdate   dotNet.addEventHandler thread "RunWorkerCompleted" checkresult   append bwthreads thread  )  for tid = 1 to bwthreads.count do   bwthreads[tid].RunWorkerAsync tid --run thread with thread ID as parameter  free bwthreads ))--------------------------------------------------USER FUNCTIONS--------------------------------------------------fn testfn1 endval taskid =(sender = senders[taskid]for i = 1 to endval do( --some work sender.ReportProgress ((i as float)/endval*100) taskid sleep 0.05))fn testfn1_prototype sender thread =(try( task = tasks[thread.argument] senders[thread.argument] = sender task[1] task[2][1] thread.argument --execute target function with 1 paramater and task ID)catch sender.ReportProgress 100 thread.argument --finish task on error)fn testfn2 endval freezetime taskid =(sender = senders[taskid]for i = 1 to endval do( --some work sender.ReportProgress ((i as float)/endval*100) taskid sleep freezetime))fn testfn2_prototype sender thread =(try( task = tasks[thread.argument] senders[thread.argument] = sender task[1] task[2][1] task[2][2] thread.argument --execute target function with 2 paramaters and task ID)catch sender.ReportProgress 100 thread.argument --finish task on error)--------------------------------------------------FUNCTION CALLS--------------------------------------------------task1 = #(testfn1,#(100),testfn1_prototype) --task syntax: #(<function name>, #(<function parameters>), <function prototype name>)task2 = #(testfn2,#(50,0.2),testfn2_prototype)tasks = #(task1,task2,task1,task2) --launch 4 threads(functions can repeat)dowork "Multithreading test" --launch tasksGlobal gDealyExecute			struct sDealyExecute (							run_fn,				fn performDelayedTasks s a = (					s.enabled = off --stop timer					dotnet.RemoveEventHandler s "Tick" gDealyExecute.performDelayedTasks        					gProgLog.msg ("Function executed after [ "+s.interval as String+"ms ]") ty:"proc"					gDealyExecute.run_fn()  				),				fn run delay func = (								run_fn = func					local t = dotnetobject "Windows.Forms.Timer"					t.Interval = delay --set single tick delay					dotnet.AddEventHandler t "Tick" performDelayedTasks					t.enabled = on --start timer				)			)			gDealyExecute = sDealyExecute()			gDealyExecute.run 3000 (							fn exportModel = ( format "Delayed message after:% ms\n" 3000 )			)local tmr_max_count = 0;local timerFunction;Timer timerDelay "Timer" pos:[716,16] width:24 height:24 enabled:true interval:200 active:falsefn do_something = (	tmr_max_count = 10		format "execute delayed fn:%\n" tmr_max_count		timerDelay.active = true		fn timerFunction = (						print "done"		))	on timerDelay tick do (			format "timer progress tick:% max:%\n" timerDelay.ticks tmr_max_count		tmr_max_count = tmr_max_count-1		if tmr_max_count <= 0 do (						timerDelay.active = false			tmr_max_count = 0			timerFunction()			format "timer stop at :%\n" timerDelay.ticks		)	)---ORfunction PerformDelayedTasks sender evt=(	-- important: don't repeat this timer event	sender.enabled = false	-- for sanity and cleanup	dotnet.RemoveEventHandler sender "Elapsed" PerformDelayedTasks        	-- put all your tasks below	macros.run "Track View" "LaunchFCurveEditor" -- Curve Editor Toggle	actionMan.executeAction 0 "50048" -- Tools: Material Editor Toggle         )delayTimer= dotnetobject "Windows.Forms.Timer"delayTimer.Interval=2000dotnet.AddEventHandler delayTimer "Tick" PerformDelayedTasksdelayTimer.enabled = true			fn delayedExportAndFinish = (							fn performDelayedTask s a = ( 					s.enabled = off --stop timer					dotnet.RemoveEventHandler s "Tick" performDelayedTask					---					gProgLog.msg "Exporting Max File...." ti:"3DsMax..." ty:"task_open"					gProgLog.msg ("Dealyed execute function after [ 3000ms ]") ty:"proc"					select (for o in objects where classof o == LS3DModel collect o) --select export niode(s)					macros.run "LS3D Engine" "LS3DSelExport" 					gProgLog.msg "Export Done!" ty:"task_close"					-- FINISH, ALL DONE					gProgLog.msg "ASSET BUILDER DONE:" ti:"Initialize...." ty:"new_task"					-- gProgLog.msg "Reload Material Database For Shader Update." ty:"proc"					gProgLog.focus() -- focus back to console					max tool zoomextents all					completeRedraw()				)				local wtimer = dotnetobject "Windows.Forms.Timer"				wtimer.Interval = 3000 --set single tick delay to 3sec				dotnet.AddEventHandler wtimer "Tick" performDelayedTask				wtimer.enabled = on --start timer			)			