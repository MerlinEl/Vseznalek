--This script combines code from other public scripts as well as original code to provide--a set of vertex color related tools, Vertex Color Blur, Adjust HSV, and Adjust Contrast.--Started: 11/28/00--Edited:  11/30/00--Edited:  03/19/01 -KS:Added Tolerance Select--Edited:  05/03/01 -KS:Added Copy/Paste Color--Edited:  05/04/01 -KS:Added Select ChangeHandler--Edited:  05/05/01 -KS:Removed changeHandler and added callBack instead					  --Code by Kelly Snapka--Additional code\help: Adam Pletcherglobal new_obj = undefinedglobal blurAmt = 0global originalVC = #()global useSelVerts = Trueglobal vertArray = #()global HSVCArray = #()global chkStandardTState = trueglobal chkHSVTState = falseglobal chkHueTState = falseglobal chkSatTState = falseglobal chkValTState = falseglobal chkVertSampleState = falseglobal chkColorSampleState = trueglobal roBlurVertexColors, selByTolfn blurGrpOn =	(	roBlurVertexColors.blurAmount.enabled = True	)	fn blurGrpOff =	(	roBlurVertexColors.blurAmount.enabled = False	roBlurVertexColors.blurMesh.enabled = False	roBlurVertexColors.Revert.enabled = False	roBlurVertexColors.bakeBlur.enabled = False	)	fn hSVGrpOn =	(	roBlurVertexColors.sldHue.enabled = True	--roBlurVertexColors.resHue.enabled = True	roBlurVertexColors.sldSat.enabled = True	--roBlurVertexColors.resSat.enabled = True	roBlurVertexColors.sldVal.enabled = True	--roBlurVertexColors.resVal.enabled = True	roBlurVertexColors.resHSV.enabled = False	roBlurVertexColors.bakeHSV.enabled = False	)fn hSVGrpOff =	(	roBlurVertexColors.sldHue.enabled = False	--roBlurVertexColors.resHue.enabled = False	roBlurVertexColors.sldSat.enabled = False	--roBlurVertexColors.resSat.enabled = False	roBlurVertexColors.sldVal.enabled = False	--roBlurVertexColors.resVal.enabled = False	roBlurVertexColors.resHSV.enabled = False	roBlurVertexColors.bakeHSV.enabled = False	)fn contrastGrpOn = 	(	roBlurVertexColors.spn_Contrast.enabled = True	roBlurVertexColors.btn_Contrast_Reset.enabled = False	roBlurVertexColors.bakeContrast.enabled = False	)fn contrastGrpOff = 	(	roBlurVertexColors.spn_Contrast.enabled = False	roBlurVertexColors.btn_Contrast_Reset.enabled = False	roBlurVertexColors.bakeContrast.enabled = False	)fn copyGrpOn =	(	roBlurVertexColors.cpColor.enabled = true	roBlurVertexColors.btnCopyColor.enabled = true	roBlurVertexColors.btnPasteColor.enabled = true	roBlurVertexColors.btnPasteBake.enabled = false	roBlurVertexColors.btnPasteUndo.enabled = false	)fn copyGrpOff =	(	roBlurVertexColors.cpColor.enabled = false	roBlurVertexColors.btnCopyColor.enabled = false	roBlurVertexColors.btnPasteColor.enabled = false	roBlurVertexColors.btnPasteBake.enabled = false	roBlurVertexColors.btnPasteUndo.enabled = false	)fn selGrpOn =	(	selByTol.chkColorSample.enabled = True	selByTol.chkColorSample.checked = chkColorSampleState	selByTol.lbColorSample.enabled = True	selByTol.cpColorSample.enabled = True	selByTol.chkVertSample.enabled = True	selByTol.chkVertSample.checked = chkVertSampleState	selByTol.btnVertSample.enabled = chkVertSampleState	)	fn selGrpOff =	(	selByTol.chkColorSample.enabled = False	selByTol.lbColorSample.enabled = False	selByTol.cpColorSample.enabled = False	selByTol.chkVertSample.enabled = False	selByTol.btnVertSample.enabled = False	)	fn tolGrpOn = 	(	selByTol.chkStandardT.enabled = True	selByTol.chkStandardT.checked = chkStandardTState	selByTol.spnStandardTAmount.enabled = chkStandardTState	selByTol.chkHSVT.enabled = True	selByTol.chkHSVT.checked = chkHSVTState	selByTol.chkHueT.enabled = chkHSVTState	selByTol.chkSatT.enabled = chkHSVTState	selByTol.chkValT.enabled = chkHSVTState	selByTol.chkHueT.checked = chkHueTState	selByTol.spnHueTAmount.enabled = chkHueTState	selByTol.chkSatT.checked = chkSatTState	selByTol.spnSatTAmount.enabled = chkSatTState	selByTol.chkValT.checked = chkValTState	selByTol.spnValTAmount.enabled = chkValTState	)fn tolGrpOff = 	(	selByTol.chkStandardT.enabled = False	selByTol.chkStandardT.checked = False	selByTol.spnStandardTAmount.enabled = False	selByTol.chkHSVT.enabled = False	selByTol.chkHSVT.checked = False	selByTol.chkHueT.enabled = False	selByTol.chkSatT.enabled = False	selByTol.chkValT.enabled = False	selByTol.chkHueT.checked = False	selByTol.spnHueTAmount.enabled = False	selByTol.chkSatT.checked = False	selByTol.spnSatTAmount.enabled = False	selByTol.chkValT.checked = False	selByTol.spnValTAmount.enabled = False	)fn disableBtns  =	(	roBlurVertexColors.selectMesh.text = "Select Mesh"	blurGrpOff ()	hSVGrpOff ()	contrastGrpOff ()	copyGrpOff ()	selGrpOff ()	tolGrpOff ()	)--Function for Pickbutton filterfn check_for_mesh obj =	superClassOf obj == GeometryClass--Function for Storing Selected Mesh's Vert Colors in an Arrayfn storeVertColors obj =	(	tempArray=#()	for i in 1 to getNumCPVVerts $ do		(		append tempArray (getVertColor $ i)		)	return tempArray	)--Main Function for FlattenVertexColors. Please feel free to reuse if needed.-----------------------------------------------------------------------------------------FlattenVertexColors --Version 0.1 for MAX 3.1 or higher--REQUIRES THE AVGUARD AVG.DLX EXTENSION UNDER MAX R3.1--Started: 11/29/2000--Edited:  11/29/2000--Code by Borislav Petrov--http://www.gfxcentral.com/bobo-----------------------------------------------------------------------------------------Reduces Vertex Colors by averaging multiple vertex colors per mesh vertex --to a single color vertex per mesh vertex.--Works great with round objects, will cause artifacts at edges of non-smooth objects.--Developed for Alex McLeod.---------------------------------------------------------------------------------------fn flattenVertexColors obj hide_old=(	--Make sure the object provided is geometry that can be collapsed to mesh and has vertex colors assigned.	if superclassof obj == GeometryClass and canConvertto obj Mesh and getNumCPVVerts obj.mesh > 0 then 		(		try	--catch any errors (no AVG.DLX under R3.1 etc.)			(			progressstart ("Processing "+obj.name+"...")	--start progress bar			st = timestamp()								--get time stamp			obj_mesh = obj.mesh 							--get the mesh from the object			new_colors_array = #()							--init an array to hold new (flatten) colors			new_face_index =#()								--init an array to hold new indices for the flatten version			for i = 1 to obj_mesh.numverts do				--loop through all mesh vertices of the original mesh			(	q = progressupdate (100.0*i / obj_mesh.numverts)	--update progress bar	average_color_r = 0									--init average color variable for red component	average_color_g = 0									--init average color variable for green component	average_color_b = 0									--init average color variable for blue component	average_counter = 0									--init counter to hold the number of colors averaged per vertex	array_of_faces = meshop.getFacesUsingVert obj_mesh i	--get a bitarray of all faces using the current vertex	for j = 1 to array_of_faces.count do					--loop through all faces in the array		(		if array_of_faces[j] == true then 					--if the face uses the current vertex...			(			get_face = getface obj_mesh j					--get the vertex indices of the face			if get_face.x == i then v_index = 1				--check which of the 3 vertices is the current one			if get_face.y == i then v_index = 2			if get_face.z == i then v_index = 3			get_color_face = getVCFace obj_mesh j			--get the corresponding color face (same index as mesh face)			case v_index of									--get the corresponding color vertex (same index as mesh vertex)				(				1: cv_index = get_color_face.x								2: cv_index = get_color_face.y				3: cv_index = get_color_face.z				)			get_color_vert = getVertColor obj_mesh cv_index			--get the color value of the color vertex			new_face_index[cv_index] = (new_colors_array.count+1)	--write the index of the NEW vertex to the array			average_color_r += get_color_vert.r						--store red, green and blue componentsin the average variables			average_color_g += get_color_vert.g			average_color_b += get_color_vert.b			average_counter += 1									--increase the count of colors to be averaged			)--end if		)--end j	average_color_r /= average_counter								--average the color components	average_color_g /= average_counter		average_color_b /= average_counter		average_color = color average_color_r average_color_g average_color_b	--build a new color from the averaged components	append new_colors_array average_color 									--append the new averaged color to the array	)--end i	progressend()															--end the progress display		new_obj = copy obj														--copy the object 	new_obj.name = uniquename ("FlatCPV_"+obj.name)							--add a new name	converttomesh new_obj													--convert the copy to Emesh	setNumCPVVerts new_obj new_colors_array.count false						--set the new number of vertex colors	buildVCFaces new_obj false												--build new color faces (same number as mesh faces)	for i = 1 to new_colors_array.count do									--loop through all new colors		(		setVertColor new_obj i new_colors_array[i]								--assign them to the new color vertices		)		progressstart ("Updating "+new_obj.name+"...")							--start new progress bar	for i = 1 to obj.mesh.numfaces do										--loop through all faces in the original object		(		progressupdate (100.0*i / obj.mesh.numfaces)							--update progress bar		old_vc_face = getVCFace obj.mesh i										--get old color face		--new color face will contain the new color vertex indices corresponding to the old ones. (kind of tricky to explain ;o)		new_vc_face = [new_face_index[old_vc_face.x], new_face_index[old_vc_face.y], new_face_index[old_vc_face.z]]   		setVCFace new_obj i new_vc_face 										--set the new color face to use the new indices to the new color verts.		)	update new_obj															--update the new mesh	new_obj.showVertexColors = true											--activate color vertex display	-- if hide_old then hide obj												--if hide requested, hide the original	progressend()															--end progress	et = timestamp()														--get an end time stamp	format "FlattenVertexColors: Reduced % to % CPVs in % seconds.\n" (getNumCPVVerts obj.mesh) (getNumCPVVerts new_obj.mesh) ((et-st)/1000.0)		--display time	OK		)	catch(format "FlattenVertexColors: Some error occured. \nPlease make sure you have Avguard Extensions installed\nor contact the author if you need assistance.\n")	new_obj.name = obj.name	delete obj	select new_obj		)	else	(	format "FlattenVertexColors: Invalid Object!\n"	))--end fn-- function killDups (array)-- removes duplicate elements from an array, returns fixed arrayfn killDups thisArray =	(	newArray = #()	for s = 1 to thisArray.count do		(		ch = true		for z = 1 to newArray.count do			(			if (thisArray[s] == newArray[z]) then				ch = false			)		if (ch == true) then			newArray[newArray.count+1] = thisArray[s]		)	return newArray	)-- function getVertList (array) (int)-- "Unrolls" the string/vertex data created in fillVertArray (see below)fn getVertList myArray idx =	(	tempArray = filterstring myArray[idx] ","	newArray = #()	for i = 1 to tempArray.count do		(		append newArray (tempArray[i] as integer)		)	tempArray = killDups newArray	return tempArray	)-- function fillVertArray (object)-- Runs through faces in object and creates array, one element per-- vertex.  Each element is a string, "2,5,8,32, ..." with indices of vertices-- adjacent to that vertex.  GetVertList function is needed to do anything useful with that.fn fillVertArray myObj =	(	myArray = #()	for i = 1 to myObj.numfaces do		(		thisFace = getface myObj i				-- initialize elements so they're not undefined		if myArray[thisFace.x] == undefined then myArray[thisFace.x] = ""		if myArray[thisFace.y] == undefined then myArray[thisFace.y] = ""		if myArray[thisFace.z] == undefined then myArray[thisFace.z] = ""				-- for each X, add Y and Z to its adj. list, do similar for Y and Z.  Ugly.		myArray[thisFace.x] += ((thisFace.y as integer) as string) + ","		myArray[thisFace.x] += ((thisFace.z as integer) as string) + ","		myArray[thisFace.y] += ((thisFace.x as integer) as string) + ","		myArray[thisFace.y] += ((thisFace.z as integer) as string) + ","		myArray[thisFace.z] += ((thisFace.y as integer) as string) + ","		myArray[thisFace.z] += ((thisFace.x as integer) as string) + ","		)	return myArray	)--function for averaging adjacent vertex colorsfn averageAdjacent vertNum =	(	adjacentArray = getVertList vertArray vertNum	avgColor = [0,0,0]	for i = 1 to adjacentArray.count do		(		avgColor += getVertColor new_obj adjacentArray[i]			)	return (avgColor/adjacentArray.count))--Hue Change Functionfn changeHue hue = 	(	if useSelVerts == true then 		(		HSVCArray = #()		for i = 1 to $.selectedVerts.count do 			(			a=$.selectedVerts[i].index			append HSVCArray a			)		)	else 		(		HSVCArray = #()		for i = 1 to getNumVerts($) do			(append HSVCArray i)		)	for i in 1 to HSVCArray.count do		(		col=getVertColor $ HSVCArray[i]		hueInt = originalVC[HSVCArray[i]].h+(hue)		if hueInt < 0 then			(hueInt+=255)		else if hueInt > 255 then			(hueInt+=(-255))		col.h=hueInt		setVertColor $ HSVCArray[i] col		)	)fn changeSat sat = 	(	if useSelVerts == true then 		(		HSVCArray = #()		for i = 1 to $.selectedVerts.count do 			(			a=$.selectedVerts[i].index			append HSVCArray a			)		)	else 		(		HSVCArray = #()		for i = 1 to getNumVerts($) do			(append HSVCArray i)		)	for i in 1 to HSVCArray.count do		(		col=getVertColor $ HSVCArray[i]		satInt = originalVC[HSVCArray[i]].s+(sat)		if satInt < 0 then			(satInt=0)		else if satInt > 255 then			(satInt=255)		col.s=satInt		setVertColor $ HSVCArray[i] col		)	)fn changeVal val = 	(	if useSelVerts == true then 		(		HSVCArray = #()		for i = 1 to $.selectedVerts.count do 			(			a=$.selectedVerts[i].index			append HSVCArray a			)		)	else 		(		HSVCArray = #()		for i = 1 to getNumVerts($) do			(append HSVCArray i)		)	for i in 1 to HSVCArray.count do		(		col=getVertColor $ HSVCArray[i]		valInt = originalVC[HSVCArray[i]].v+(val)		if valInt < 0 then			(valInt=0.001)		else if valInt > 255 then			(valInt=255)		col.v=valInt		setVertColor $ HSVCArray[i] col		)	)fn Paste val = 	(	if useSelVerts == true then 		(		HSVCArray = #()		for i = 1 to $.selectedVerts.count do 			(			a=$.selectedVerts[i].index			append HSVCArray a			)		)	else 		(		HSVCArray = #()		for i = 1 to getNumVerts($) do			(append HSVCArray i)		)	for i in 1 to HSVCArray.count do		(		    setVertColor new_obj HSVCArray[i] val		)	)fn changeContrast val = 	(	if useSelVerts == true then 		(		HSVCArray = #()		for i = 1 to $.selectedVerts.count do 			(			a=$.selectedVerts[i].index			append HSVCArray a			)		)	else 		(		HSVCArray = #()		for i = 1 to getNumVerts($) do			(append HSVCArray i)		)	--Adjust saturation amount	for i in 1 to HSVCArray.count do		(			col=originalVC[HSVCArray[i]]		con=(.5+(val/200))		col=(128*(1-2*con)+col*(2*con))		setVertColor new_obj HSVCArray[i] col		)	)--Creates rollout interface for scriptrollout roBlurVertexColors "Vertex Color Toolset"(			--Button for selecting mesh to run script on	pickbutton selectMesh "Select Mesh" width:110 filter:check_for_mesh toolTip:"Select Mesh To Blur" 	--Warning 	label lbl_Warning "WARNING:"	label lbl_GeoCollapse "Geometry will be collapsed."	--Use selected verts toggle checkbox	checkbox use_sel_vert "Use Selected Verts" align:#center enabled:True checked:true	--Blur Interface	group "Blur Vertex Colors"		(		spinner blurAmount "Blur Amount: " range:[0,1,0] type:#float fieldwidth:40 align:#center enabled:False		button blurMesh "Blur" width:60 enabled:False		button Revert "Reset" width:60 enabled:False Across:2		button bakeBlur "Bake Blur" enabled:False		progressBar pb_blur width:150 height:10		)		--HSV Interface	group "Adjust HSV" 		(	    --label Adjust_Temp "Under Construction"		spinner sldHue "Hue: " range:[-127,127,0] fieldwidth:35 type:#integer enabled:False  --offset:[-20,0]  -- across:2 		--button resHue "Reset" align:#right enabled:False		spinner sldSat "Saturation: " fieldwidth:35 range:[-255,255,0] type:#integer enabled:False --offset:[-20,0]-- across:2 		--button resSat "Reset" align:#right enabled:False		spinner sldVal "Value: " range:[-255,255,0] fieldwidth:35 type:#integer enabled:False  --offset:[-20,0] --across:2 		--button resVal "Reset" align:#right enabled:False		button resHSV " Reset All " enabled:False Across:2		button bakeHSV " Bake HSV " enabled:False		)	--Contrast Interface	group "Adjust Contrast"	(		spinner spn_Contrast "Contrast: " fieldwidth:45 range:[-100,100,0] align:#center enabled:False		button btn_Contrast_Reset " Reset " enabled:False  offset:[-10,0] across:2		button bakeContrast " Bake Contrast " enabled:False offset:[-10,0]	)		--Copy/Paste Vertex Colors Interface	group "Copy/Paste Color"	(	colorPicker cpColor color:white width:50 height:46 offset:[-6,0] across:3 enabled:false	button btnCopyColor "Copy"  width:50 enabled:False	button btnPasteColor "Paste"  width:50 offset:[4,0] enabled:False	button btnPasteUndo "Undo"  width:50 offset:[36,-26] enabled:False across:2	button btnPasteBake "Bake"  width:50 offset:[18,-26] enabled:False	)	 		on selectMesh picked obj do		(		new_obj = undefined		originalVC = #()		vertArray = #()		HSVCArray = #()		callbacks.removeScripts id:#disBtns		--Runs Flatten Vertex Function		select obj		convertToMesh obj		if (getNumCPVVerts obj) == 0 then			(			messageBox "Object has no Vertex Colors to blur!" beep:true			)		else 			(			selectMesh.text = obj.name			if (getNumVerts obj) != (getNumCPVVerts obj) then				(				flattenVertexColors obj true				)			new_obj = $						--Capturing original vertex colors			originalVC = storeVertColors $			--Enabling rest of interface			blurGrpOn ()			hSVGrpOn ()			contrastGrpOn ()			copyGrpOn ()			selGrpOn ()			tolGrpOn ()			callbacks.addscript #selectionSetChanged "disableBtns ()" id:#disBtns			)		)			on use_sel_vert changed state do		(		if use_sel_vert.state == true then 			(			useSelVerts = true			)		else 			(			useSelVerts = false			)		)		on blurAmount changed val do		(		blurAmt = val		if blurAmt > 0 then			(			blurMesh.enabled = true			hSVGrpOff ()			contrastGrpOff ()			copyGrpOff ()			)		else			(			blurMesh.enabled = false			hSVGrpOn ()			contrastGrpOn ()			copyGrpOn ()			)		)		on revert pressed do		(		for i in 1 to (getNumCPVVerts $) do 			(			setVertColor $ i (originalVC[i])			)		update $		revert.enabled = False		--originalVC = #()		blurAmount.value = 0		blurGrpOff ()		blurGrpOn ()				hSVGrpOn ()		contrastGrpOn ()		copyGrpOn ()		)		-- For each vertex, finds and averages adjacent vertexes together.	-- Then it mixes the original vertex color value with the adjacent	-- vertexes value at the amount specified by the spinner.	on blurMesh pressed do		(		originalVC = storeVertColors $		revert.enabled = true		bakeBlur.enabled = true		blurAmt = blurAmount.value		-- main		pb_blur.value = 0				vertArray = fillVertArray selection[1]		if useSelVerts == true then 			(			HSVCArray = #()			for i = 1 to $.selectedVerts.count do 				(				a=$.selectedVerts[i].index				append HSVCArray a				)			)		else 			(			HSVCArray = #()			for i = 1 to getNumVerts($) do				append HSVCArray i			)			local newVertColors = #()				for i in 1 to HSVCArray.count do			(			vertListArray = getVertList vertArray HSVCArray[i]			-- Here's where you process your vertex data.  In each iteration of this			-- loop, vertListArray will contain one element per vertex that's adjacent			-- to vertex i.			--			-- Example, say vertex #11 in the mesh is adjacent to vertices 5,18,105, and 64.			-- When i = 11 above, vertListArray will contain #(5,18,105,64).  Not necessarily			-- in that order, but it will not include duplicates.			--			newcolor = (averageAdjacent i)*(blurAmt)+(getVertColor new_obj i)*(blurAmt)			newcolor = (getVertColor new_obj (HSVCArray[i])) + (((averageAdjacent (HSVCArray[i])) - (getVertColor new_obj (HSVCArray[i]))) * blurAmt)						newVertColors[i] = newcolor						pb_blur.value = 100.*(HSVCArray[i])/vertArray.count			)		for i = 1 to HSVCArray.count do			setVertColor new_obj HSVCArray[i] newVertColors[i]		update new_obj		pb_blur.value = 0		)		--Bake Blur button action	on bakeBlur pressed do		(		originalVC = storeVertColors new_obj		blurAmount.value = 0		blurGrpOff ()		blurGrpOn ()				hSVGrpOn ()		contrastGrpOn ()		copyGrpOn ()		)	--Reset button actions	--on resSat pressed do 	--	(	--	sldSat.value = 0	--	changeSat 0	--	update new_obj	--	)	--on resVal pressed do 	--	(	--	sldVal.value = 0	--	changeVal 0	--	update new_obj	--	)	on resHSV pressed do 		(		sldHue.value = sldSat.value = sldVal.value = 0		changeHue 0		changeSat 0		changeVal 0		update new_obj		blurGrpOn ()		contrastGrpOn ()		copyGrpOn ()		resHSV.enabled = false		bakeHSV.enabled = false		)		--Bake HSV	on bakeHSV pressed do		(		originalVC = storeVertColors new_obj		sldHue.value = sldSat.value = sldVal.value = 0		blurGrpOn ()		contrastGrpOn ()		copyGrpOn ()		resHSV.enabled = false		bakeHSV.enabled = false		)		--Hue Slider	on sldHue changed val do		(		blurGrpOff ()		contrastGrpOff ()		copyGrpOff ()		resHSV.enabled = true		bakeHSV.enabled = true		changeHue sldHue.value		changeSat sldSat.value		changeVal sldVal.value		update new_obj		)			--Saturation Slider	on sldSat changed val do		(		blurGrpOff ()		contrastGrpOff ()		copyGrpOff ()		resHSV.enabled = true		bakeHSV.enabled = true		changeHue sldHue.value		changeSat sldSat.value		changeVal sldVal.value		update new_obj		)		--Value Slider	on sldVal changed val do		(		blurGrpOff ()		contrastGrpOff ()		copyGrpOff ()		resHSV.enabled = true		bakeHSV.enabled = true		changeHue sldHue.value		changeSat sldSat.value		changeVal sldVal.value		update new_obj		)	--Adjust Contrast Slider	on spn_Contrast changed val do		(		changeContrast spn_Contrast.value		update new_obj		blurGrpOff ()		hSVGrpOff ()		copyGrpOff ()		btn_Contrast_Reset.enabled = true		bakeContrast.enabled = true		)		--Contrast Reset Button	on btn_Contrast_Reset pressed do		(		spn_Contrast.value = 0		changeContrast spn_Contrast.value		update new_obj		blurGrpOn ()		hSVGrpOn ()		copyGrpOn ()		btn_Contrast_Reset.enabled = false		bakeContrast.enabled = false		)		--Bake Contrast	on bakeContrast pressed do		(		originalVC = storeVertColors new_obj		spn_Contrast.value = 0		blurGrpOn ()		hSVGrpOn ()		copyGrpOn ()		btn_Contrast_Reset.enabled = false		bakeContrast.enabled = false		)		on btnCopyColor pressed do		(			originalVC = storeVertColors new_obj			if $.selectedVerts.count != 1 then			(			 	messagebox "Select a single vertex" beep:true			)			else 			(				cpColor.color = (getVertColor $ $.selectedVerts[1].index)			)			blurGrpOff ()			hSVGrpOff ()			contrastGrpOff ()			btnPasteUndo.enabled = true			btnPasteBake.enabled = true		)	on btnPasteColor pressed do		(			if $.selectedVerts.count < 1 then			(			 	messagebox "Select some verts" beep:true			)			else 			( 			blurGrpOff ()			hSVGrpOff ()			contrastGrpOff ()			Paste cpColor.color			btnPasteUndo.enabled = True			btnPasteBake.enabled = True			update new_obj 			)		)	on btnPasteBake pressed do		(		originalVC = storeVertColors new_obj		blurGrpOn ()		hSVGrpOn ()		contrastGrpOn ()		copyGrpOn ()		)			on btnPasteUndo pressed do		(		for i in 1 to (getNumCPVVerts $) do 			(			setVertColor $ i (originalVC[i])			)		update $		blurGrpOn ()		hSVGrpOn ()		contrastGrpOn ()		copyGrpOn ()		--originalVC = #()		)				--callbacks)rollout selByTol "Tolerance Select" width:200 height:300(	local varSampleColor = white	group "Selection Source:"	(	checkbox chkColorSample "" across:3 enabled:false checked:true	label lbColorSample "Color Sample: " offset:[-10,0] enabled:false	colorPicker cpColorSample color:white width:50 height:14 offset:[0,0] enabled:false		checkbox chkVertSample "" across:2 enabled:false checked:false --off	button btnVertSample "Vertex Sample" width:120 offset:[-40,0] enabled:false --off	)		group "Tolerance Type:"	(	checkbox chkStandardT "Standard" checked:true across:2 enabled:false	spinner spnStandardTAmount fieldwidth:40 range:[0,255,0] type:#integer enabled:false	checkbox chkHSVT "HSV Tolerance:" enabled:false	checkbox chkHueT "Hue: " offset:[16,0] across:2 enabled:false	spinner spnHueTAmount fieldwidth:40 range:[0,255,0] type:#integer enabled:false		checkbox chkSatT "Saturation: " offset:[16,0] across:2 enabled:false	spinner spnSatTAmount  fieldwidth:40 range:[0,255,0] type:#integer enabled:false		checkbox chkValT "Value: " offset:[16,0] across:2 enabled:false	spinner spnValTAmount  fieldwidth:40 range:[0,255,0] type:#integer enabled:false		)	on chkVertSample changed state do		(			if chkVertSample.checked == true then 				(					chkVertSampleState = true					chkColorSampleState = false					chkColorSample.checked = false					btnVertSample.enabled = true					btnVertSample.caption = "Sample Selected Vertex"					cpColorSample.enabled = false					lbColorSample.enabled = false				)			else				(					chkVertSampleState = false					chkColorSampleState = true					btnVertSample.enabled = false					btnVertSample.caption = "Vertex Sample"				)		)			on chkColorSample changed state do		(			if chkColorSample.checked == true then 				(					chkVertSampleState = false					chkColorSampleState = true					varSampleColor = cpColorSample.color					chkVertSample.checked = false					cpColorSample.enabled = true					lbColorSample.enabled = true					btnVertSample.enabled = false					btnVertSample.caption = "Vertex Sample"				)			else				(					chkVertSampleState = true					chkColorSampleState = false										cpColorSample.enabled = false					lbColorSample.enabled = false				)		)		on chkStandardT changed state do		(			if chkStandardT.checked == true then				(					chkStandardTState = true					chkHSVTSate = false					spnStandardTAmount.enabled = true					chkHSVT.checked = false					chkHueT.enabled = false					chkSatT.enabled = false					chkValT.enabled = false					spnHueTAmount.enabled = false					spnSatTAmount.enabled = false					spnValTAmount.enabled = false				)			else 			(			spnStandardTAmount.enabled = false			chkStandardTState = false			chkHSVTState = true			)		)			on chkHSVT changed state do		(			if chkHSVT.checked == true then				(					chkHSVTState = true					chkStandardTState = false					chkStandardT.checked = false					spnStandardTAmount.enabled = false					chkHueT.enabled = True					spnHueTAmount.enabled = true					chkSatT.enabled = True					spnSatTAmount.enabled = true					chkValT.enabled = True					spnValTAmount.enabled = true				)			else				(					chkHSVTState = false					chkStandardTState = True					chkHueT.enabled = false					chkSatT.enabled = false					chkValT.enabled = false					spnHueTAmount.enabled = false					spnSatTAmount.enabled = false					spnValTAmount.enabled = false				)		)		on cpColorSample changed new_col do varSampleColor = new_col		on btnVertSample pressed do		(			-- messagebox (varSampleColor as string) beep:true			if $.selectedVerts.count != 1 then			(			 	messagebox "Select a single vertex" beep:true			)			else 			(				btnVertSample.caption = ("Vertex "+($.selectedVerts[1].index as string)+" sampled.")				varSampleColor = (getVertColor $ $.selectedVerts[1].index)				cpColorSample.color = varSampleColor				-- messagebox (varSampleColor as string) beep:true				-- setVertColor $ $.selectedverts[1].index cpColorSample.color			)		)		on spnStandardTAmount changed val do 			(			local selectionArray = #()			for i in 1 to $.numverts do					(					if  (getVertColor $ i).r < (varSampleColor.r + spnStandardTAmount.value + .001) and						(getVertColor $ i).r > (varSampleColor.r - spnStandardTAmount.value - .001) and						(getVertColor $ i).g < (varSampleColor.g + spnStandardTAmount.value + .001) and						(getVertColor $ i).g > (varSampleColor.g - spnStandardTAmount.value - .001) and						(getVertColor $ i).b < (varSampleColor.b + spnStandardTAmount.value + .001) and						(getVertColor $ i).b > (varSampleColor.b - spnStandardTAmount.value - .001) then 							(								append selectionArray i							)					)			select $.verts[selectionArray]			)				on spnHueTAmount changed val do		(		local selectionArray = #()		local oneA = #()		local twoA = #()		local threeA = #()		for i in 1 to $.numverts do			(				if  (getVertColor $ i).h < (varSampleColor.h + spnHueTAmount.value + .001) and					(getVertColor $ i).h > (varSampleColor.h - spnHueTAmount.value - .001) then					(append oneA i)			)			if chkSatT.checked == false and chkValT.checked == false then selectionArray = oneA		if chkSatT.checked == true and chkValT.checked == true then					(						for i in 1 to oneA.count do						(						if  (getVertColor $ oneA[i]).s < (varSampleColor.s + spnSatTAmount.value + .001) and							(getVertColor $ oneA[i]).s > (varSampleColor.s - spnSatTAmount.value - .001) then								(append twoA oneA[i])						)					for i in 1 to twoA.count do						(						if  (getVertColor $ oneA[i]).v < (varSampleColor.v + spnValTAmount.value + .001) and							(getVertColor $ oneA[i]).v > (varSampleColor.v - spnValTAmount.value - .001) then								(append threeA twoA[i])						)										selectionArray = threeA					)		if chkSatT.checked == true and chkValT.checked == false then			(				for i in 1 to oneA.count do					(						if  (getVertColor $ oneA[i]).s < (varSampleColor.s + spnSatTAmount.value + .001) and							(getVertColor $ oneA[i]).s > (varSampleColor.s - spnSatTAmount.value - .001) then								(append twoA oneA[i])					)				selectionArray = twoA			)		if chkValT.checked == true and chkSatT.checked == false then			(				for i in 1 to oneA.count do					(						if  (getVertColor $ oneA[i]).v < (varSampleColor.s + spnValTAmount.value + .001) and							(getVertColor $ oneA[i]).v > (varSampleColor.s - spnValTAmount.value - .001) then								(append twoA oneA[i])					)				selectionArray = twoA			)				select $.verts[selectionArray]		)		on spnSatTAmount changed val do		(		local selectionArray = #()		local oneA = #()		local twoA = #()		local threeA = #()		for i in 1 to $.numverts do			(				if  (getVertColor $ i).s < (varSampleColor.s + spnSatTAmount.value + .001) and					(getVertColor $ i).s > (varSampleColor.s - spnSatTAmount.value - .001) then					(append oneA i)			)			if chkHueT.checked == false and chkValT.checked == false then selectionArray = oneA		if chkHueT.checked == true and chkValT.checked == true then					(						for i in 1 to oneA.count do						(						if  (getVertColor $ oneA[i]).h < (varSampleColor.h + spnHueTAmount.value + .001) and							(getVertColor $ oneA[i]).h > (varSampleColor.h - spnHueTAmount.value - .001) then								(append twoA oneA[i])						)					for i in 1 to twoA.count do						(						if  (getVertColor $ oneA[i]).v < (varSampleColor.v + spnValTAmount.value + .001) and							(getVertColor $ oneA[i]).v > (varSampleColor.v - spnValTAmount.value - .001) then								(append threeA twoA[i])						)										selectionArray = threeA					)		if chkHueT.checked == true and chkValT.checked == false then			(				for i in 1 to oneA.count do					(						if  (getVertColor $ oneA[i]).h < (varSampleColor.h + spnHueTAmount.value + .001) and							(getVertColor $ oneA[i]).h > (varSampleColor.h - spnHueTAmount.value - .001) then								(append twoA oneA[i])					)				selectionArray = twoA			)		if chkValT.checked == true and chkHueT.checked == false then			(				for i in 1 to oneA.count do					(						if  (getVertColor $ oneA[i]).v < (varSampleColor.s + spnValTAmount.value + .001) and							(getVertColor $ oneA[i]).v > (varSampleColor.s - spnValTAmount.value - .001) then								(append twoA oneA[i])					)				selectionArray = twoA			)				select $.verts[selectionArray]		)	on spnValTAmount changed val do		(		local selectionArray = #()		local oneA = #()		local twoA = #()		local threeA = #()		for i in 1 to $.numverts do			(				if  (getVertColor $ i).v < (varSampleColor.v + spnValTAmount.value + .001) and					(getVertColor $ i).v > (varSampleColor.v - spnValTAmount.value - .001) then					(append oneA i)			)			if chkSatT.checked == false and chkHueT.checked == false then selectionArray = oneA		if chkSatT.checked == true and chkHueT.checked == true then					(						for i in 1 to oneA.count do						(						if  (getVertColor $ oneA[i]).s < (varSampleColor.s + spnSatTAmount.value + .001) and							(getVertColor $ oneA[i]).s > (varSampleColor.s - spnSatTAmount.value - .001) then								(append twoA oneA[i])						)					for i in 1 to twoA.count do						(						if  (getVertColor $ oneA[i]).h < (varSampleColor.h + spnHueTAmount.value + .001) and							(getVertColor $ oneA[i]).h > (varSampleColor.h - spnHueTAmount.value - .001) then								(append threeA twoA[i])						)										selectionArray = threeA					)		if chkSatT.checked == true and chkHueT.checked == false then			(				for i in 1 to oneA.count do					(						if  (getVertColor $ oneA[i]).s < (varSampleColor.s + spnSatTAmount.value + .001) and							(getVertColor $ oneA[i]).s > (varSampleColor.s - spnSatTAmount.value - .001) then								(append twoA oneA[i])					)				selectionArray = twoA			)		if chkHueT.checked == true and chkSatT.checked == false then			(				for i in 1 to oneA.count do					(						if  (getVertColor $ oneA[i]).h < (varSampleColor.s + spnHueTAmount.value + .001) and							(getVertColor $ oneA[i]).h > (varSampleColor.s - spnHueTAmount.value - .001) then								(append twoA oneA[i])					)				selectionArray = twoA			)				select $.verts[selectionArray]		)				on chkHueT changed state do			(			if chkHueT.checked == true then chkHueTState = true			else chkHueTState = false			)					on chkSatT changed state do			(			if chkSatT.checked == true then chkSatTState = true			else chkSatTState = false			)					on chkValT changed state do			(			if chkValT.checked == true then chkValTState = true			else chkValTState = false			))vcToolsFloater = (newRolloutFloater "V-VC-Tools" 200 758)addRollout roBlurVertexColors vcToolsFloateraddRollout selByTol vcToolsFloater -- rolledup:true