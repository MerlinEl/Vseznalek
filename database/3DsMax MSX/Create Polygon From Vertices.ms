		fn isClockwise vertices = (		local sum = 0.0		for i = 1 to vertices.count do (						local p1 = vertices[i]			---local p2 = vertices[(i + 1) % vertices.count]			local p2 = if i < vertices.count then vertices[i+1] else vertices[1]			sum += (p2.x - p1.x) * (p2.y + p1.y)		)		sum > 0.0	)			/*	fn sortVertsPos p1 p2 center:[0,0,0] = (		local a1 = radToDeg ( atan2 (p1.x - center.x) (p1.y - center.y) )		local a2 = radToDeg ( atan2 (p2.x - center.x) (p2.y - center.y) )		a1 = mod (a1+360) 360			a2 = mod (a2+360) 360			case of(		 (a1 > a2)	: 1		 (a1 < a2)	: -1		 default	    : 0		)	)*/				fn sortVertsPos p1 p2 center:[0,0,0] p:[0,0,0] = (		format "p1:% p2:%\n" p1 p2		local a1 = mcMath.getLinesAngle center p1 center p		local a2 = mcMath.getLinesAngle center p2 center p 		/*local a1 = mcMath.getVectorsAngle vect (p1 - center)		local a2 = mcMath.getVectorsAngle vect (p2 - center)*/		case of(		 (a1 > a2)	: 1		 (a1 < a2)	: -1		 default	    : 0		)	)	fn createPolygonObj verts_pos obj_name = (		local new_obj = Editable_mesh()		convertToPoly new_obj		for p in verts_pos do polyop.createVert new_obj p		polyop.createPolygon new_obj (for i = 1 to verts_pos.count collect i)		new_obj.pivot = (new_obj.min + new_obj.max) / 2 --center pivot		new_obj.name = obj_name		update new_obj		new_obj	)	fn createPolygonBetweenTwoEdges obj = (				if classOf obj != Editable_Poly do return false		esel = polyOp.getEdgeSelection obj		everts = polyOp.getVertsUsingEdge obj esel		verts_pos = for v in everts collect (polyOp.getVert obj v) 		points_center = [0,0,0]		for p in verts_pos do points_center += p		points_center /= verts_pos.count		point size:10 pos:points_center wirecolor:red		v1 = verts_pos[1] - points_center 		qsort verts_pos sortVertsPos center:points_center vect:verts_pos[1]		verts_pos		local normal_angle = cross (verts_pos[1] - verts_pos[2]) (verts_pos[3] - verts_pos[2]) 		if normal_angle.z > 0 do verts_pos = mcArray.reverseArray verts_posformat "normal:%\n"	normal_angle		--ifverts_pos[2].x < verts_pos[1].x or verts_pos[2].y < verts_pos[1].y do  verts_pos = mcArray.reverseArray verts_pos		--vykresleni + info		vcolors = #(red, green, blue, yellow)		for i=1 to verts_pos.count do (			local p1 = verts_pos[i]			local p2 = if i < verts_pos.count then verts_pos[i+1] else verts_pos[1]			local v1 = p1 - points_center			local v2 = p2 - points_center			ang = mcMath.getVectorsAngle v1 v2			format "verts a:% b:% angle:%\n" i (if verts_pos.count then i+1 else 1) ang 			local te = text size:11 kerning:0 leading:0 pos:p1 wirecolor:vcolors[i]			te.text = i as string			te.rotation.x_rotation += 90			te.rotation.z_rotation -= 90			mcSpline.drawArrow points_center p1 head_size:1 clr:vcolors[i]		)		new_name = uniqueName (obj.name+"stairs_coll_")		new_obj = createPolygonObj verts_pos new_name		select new_obj				--isClockwise verts_pos			)	undo "Create Polygon Between Two Edges" on createPolygonBetweenTwoEdges $	------------------------------------------------------------------------------------------------------------------------	------------------------------------------------------------------------------------------------------------------------	------------------------------------------------------------------------------------------------------------------------(	--https://www.geeksforgeeks.org/find-simple-closed-path-for-a-given-set-of-points/	-- A global point needed for  sorting points with reference 	-- to the first point. Used in compare function of qsort() 	local p0; 	-- A utility function to swap two points 	fn swapPoints &p1  &p2 = (				local temp = p1		p1 = p2		p2 = temp	)	 	/**		A utility function to return square of distance between 		p1 and p2 	*/	fn dist  p1  p2 = (		(p1.x - p2.x)*(p1.x - p2.x) + (p1.y - p2.y)*(p1.y - p2.y)	)	/**		To find orientation of ordered triplet (p, q, r). 		The function returns following values 		0 --> p, q and r are colinear 		1 --> Clockwise 		2 --> Counterclockwise 	*/	fn orientation  p  q  r = (				local val = (q.y - p.y) * (r.x - q.x) -  (q.x - p.x) * (r.y - q.y);		case of (			(val > 0) 	: 2 -- clockwise			(val < 0) 	: 1 -- counterclock wise 			default		: 0 -- colinear 		)	)	/**		A function used by library function qsort() to sort 		an array of points with respect to the first point 	*/	fn compare vp1 vp2  = (		local p1 = vp1		local p2 = vp2		-- Find orientation 		local o = orientation p0 p1 p2		case of (			(o == 0)	: (				if (dist p0 p2) >= (dist p0 p1) then  -1 else 1			)			(o == 2)	: -1			default		: 1		)	)	-- Prints simple closed path for a set of cnt points. 	fn printClosedPath points cnt = (	   -- Find the bottommost point 	   local ymin = points[1].y 	   local min = 0	   for i = 1 to cnt  do (	   		 local y = points[i].y		 -- Pick the bottom-most. In case of tie, chose the 		 -- left most point 		 if ((y < ymin) or (ymin == y and points[i].x < points[min].x)) do (		 			ymin = points[i].y			min = i		 )	   ) 	  	   -- Place the bottom-most point at first position 	   swap points[0] points[min] 	  	   -- Sort cnt-1 points with respect to the first point. 	   -- A point p1 comes before p2 in sorted ouput if p2 	   -- has larger polar angle (in counterclockwise 	   -- direction) than p1 	   p0 = points[0]	   qsort &points[1] ( cnt-1 ) p0.count compare	  	   -- Now stack has the output points, print contents 	   -- of stack 	   for i=1 to cnt do (	   		   cout << "(" << points[i].x << ", " << points[i].y <<"), "		)	)	  	-- Driver program to test above functions 	points = #([0, 3], [1, 1], [2, 2], [4, 4], [0, 0], [1, 2], [3, 1], [3, 3]) 	local cnt = points.count / points[0].count	printClosedPath points cnt	------------------------------------------------------------------------------------------------------------------------	------------------------------------------------------------------------------------------------------------------------	------------------------------------------------------------------------------------------------------------------------