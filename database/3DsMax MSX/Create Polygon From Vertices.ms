(	--https://www.geeksforgeeks.org/find-simple-closed-path-for-a-given-set-of-points/	-- A global point needed for  sorting points with reference 	-- to the first point. Used in compare function of qsort() 	local p0; 	-- A utility function to swap two points 	fn swapPoints &p1  &p2 = (				local temp = p1		p1 = p2		p2 = temp	)	 	/**		A utility function to return square of distance between 		p1 and p2 	*/	fn dist  p1  p2 = (		(p1.x - p2.x)*(p1.x - p2.x) + (p1.y - p2.y)*(p1.y - p2.y)	)	/**		To find orientation of ordered triplet (p, q, r). 		The function returns following values 		0 --> p, q and r are colinear 		1 --> Clockwise 		2 --> Counterclockwise 	*/	fn orientation  p  q  r = (				local val = (q.y - p.y) * (r.x - q.x) -  (q.x - p.x) * (r.y - q.y);		case of (			(val > 0) 	: 2 -- clockwise			(val < 0) 	: 1 -- counterclock wise 			default		: 0 -- colinear 		)	)	/**		A function used by library function qsort() to sort 		an array of points with respect to the first point 	*/	fn compare vp1 vp2  = (		local p1 = vp1		local p2 = vp2		-- Find orientation 		local o = orientation p0 p1 p2		case of (			(o == 0)	: (				if (dist p0 p2) >= (dist p0 p1) then  -1 else 1			)			(o == 2)	: -1			default		: 1		)	)	// Prints simple closed path for a set of n points. 	void printClosedPath(Point points[], int n) 	{ 	   // Find the bottommost point 	   int ymin = points[0].y, min = 0; 	   for (int i = 1; i < n; i++) 	   { 		 int y = points[i].y; 	  		 // Pick the bottom-most. In case of tie, chose the 		 // left most point 		 if ((y < ymin) || (ymin == y && 			 points[i].x < points[min].x)) 			ymin = points[i].y, min = i; 	   } 	  	   // Place the bottom-most point at first position 	   swap(points[0], points[min]); 	  	   // Sort n-1 points with respect to the first point. 	   // A point p1 comes before p2 in sorted ouput if p2 	   // has larger polar angle (in counterclockwise 	   // direction) than p1 	   p0 = points[0]; 	   qsort(&points[1], n-1, sizeof(Point), compare); 	  	   // Now stack has the output points, print contents 	   // of stack 	   for (int i=0; i<n; i++) 		   cout << "(" << points[i].x << ", "				<< points[i].y <<"), "; 	} 	  	// Driver program to test above functions 	int main() 	{ 		Point points[] = {{0, 3}, {1, 1}, {2, 2}, {4, 4}, 						   {0, 0}, {1, 2}, {3, 1}, {3, 3}}; 		int n = sizeof(points)/sizeof(points[0]); 		printClosedPath(points, n); 		return 0; 	} 	------------------------------------------------------------------------------------------------------------------------	------------------------------------------------------------------------------------------------------------------------	------------------------------------------------------------------------------------------------------------------------		fn isClockwise vertices = (		local sum = 0.0		for i = 1 to vertices.count do (						local p1 = vertices[i]			---local p2 = vertices[(i + 1) % vertices.count]			local p2 = if i < vertices.count then vertices[i+1] else vertices[1]			sum += (p2.x - p1.x) * (p2.y + p1.y)		)		sum > 0.0	)			fn sortVertsPos p1 p2 center:[0,0,0] = (		local a1 = radToDeg ( atan2 (p1.x - center.x) (p1.y - center.y) )		local a2 = radToDeg ( atan2 (p2.x - center.x) (p2.y - center.y) )		a1 = mod (a1+360) 360			a2 = mod (a2+360) 360			case of(		 (a1 > a2)	: 1		 (a1 < a2)	: -1		 default	    : 0		)	)	fn createPolygonObj verts_pos obj_name = (		local new_obj = Editable_mesh()		convertToPoly new_obj		for p in verts_pos do polyop.createVert new_obj p		polyop.createPolygon new_obj (for i = 1 to verts_pos.count collect i)		new_obj.pivot = (new_obj.min + new_obj.max) / 2 --center pivot		new_obj.name = obj_name		update new_obj		new_obj	)	obj = $	esel = polyOp.getEdgeSelection obj	everts = polyOp.getVertsUsingEdge obj esel	verts_pos = for v in everts collect (polyOp.getVert obj v) 	isClockwise verts_pos	points_center = [0,0,0]	for p in verts_pos do points_center += p	points_center /= verts_pos.count	sphere radius:1 pos:points_center wirecolor:red	qsort verts_pos sortVertsPos center:points_center	verts_pos	--vykresleni	vector_angles = for i=1 to verts_pos.count collect (		local p1 = verts_pos[i]		local p2 = if i < verts_pos.count then verts_pos[i+1] else verts_pos[1]		local v1 = p1 - points_center		local v2 = p2 - points_center		mcMath.getVectorsAngle v1 v2		local te = text size:11 kerning:0 leading:0 pos:p1 wirecolor:green		te.text = i as string		sphere radius:1 pos:(v1+p1) wirecolor:yellow	)	/*	new_name = uniqueName (obj.name+"stairs_coll_")	new_obj = createPolygonObj verts_pos new_name	select new_obj*/)