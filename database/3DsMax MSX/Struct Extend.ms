fn getStructFnArr theStructDef =(	local fnNames = #()	global getStructFnArr_fnStr = stringStream ""	local exStr = "print (" + theStructDef + " as string) to:getStructFnArr_fnStr"	execute exStr	seek getStructFnArr_fnStr 0	while (not eof getStructFnArr_fnStr) do	(		local l = (readLine getStructFnArr_fnStr) as string		local isFn = matchPattern l pattern:"*<fn>*"		if isFn == true then		(			local fnName = (filterString l ":")[1]			append fnNames (trimLeft fnName)		)	)	(fnNames))--EXTENDING LVOPS/*we need to initialize a struct with DATA member names the same as our listviewops structwe will then fill in the data with references to the struct functions, for example:struct testDef (d1, d2)testInst = testDef listViewOps.clearColumnstestInst.d1()*/fn extendStruct refName def1 def2 =(	--first get an array of all the function names in the original struct, and the one we are adding to it	global fnNames = getStructFnArr def1	local fnNames2 = getStructFnArr def2 -- we need to use seperate arrays for the reference part, in our refStr execute	fnNames	--create our alternative struct definition	local autoStructName = refName + "AutoStruct"	local structStr = "struct " + autoStructName + "("	for a in fnNames do	(		local str = "	" + a + ","		append structStr str	)	for a in fnNames2 do	(		local str = "	" + a + ","		append structStr str	)	structStr = trimRight structStr ","	append structStr ")"	execute structStr	--create an instance of the struct, and we set the data members in the for loop	execute ("global " + refName + " = " + autoStructName + "()")	for a in fnNames do	(		local refStr = refName + "." + a + " = " + def1 as string + "." + a		execute refStr	)	for a in fnNames2 do	(		local refStr = refName + "." + a + " = " + def2 as string + "." + a		execute refStr	)	execute refName)--and to use it...extendstruct "lvOps" "ListViewOps" "robg3d_lvOps"