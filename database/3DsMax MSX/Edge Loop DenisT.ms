	fn getVertEdges obj vert = (		edges = #{}		for k=1 to obj.GetVertexEdgeCount vert do append edges (obj.GetVertexEdge vert k)		edges	)	fn getEdgeSecondVert obj edge_index first asPoint:on = 	(		vv = polyop.getEdgeVerts obj edge_index 		if (k = finditem vv first) != 0 do deleteitem vv k		v = vv[1]		if asPoint then as_point4 (polyop.getvert obj v) v else v 	)	fn searchLoopConnection obj first second = 	(		first_edges = getVertEdges obj first				__verts = #()		__edges = #()				for edge_index in first_edges while not first_edges.isempty do		(			obj.selectededges = #{edge_index}			obj.SelectEdgeLoop()			edges = obj.selectededges as bitarray			verts = polyop.getvertsusingedge obj edges			if verts[second] do			(				for edge_index in (first_edges * edges) do				(					_verts = #(first)					_edges = #{e}										out = off					vert = first					while not (out or keyboard.escpressed) do					(						vert = getEdgeSecondVert obj edge_index vert asPoint:off						append _verts vert												append _edges edge_index						if vert == second then out = on						else						(							edge_index = (getVertEdges obj vert - _edges) * edges							edge_index = (edge_index as array)[1]						)					)					append __verts _verts					append __edges _edges					first_edges -= _edges				)			)		)		if __edges.count == 0 then		(			obj.selectededges = #{}			undefined		)		else		(			len = __verts[1].count			best = 1			for k=2 to __verts.count where __verts[k].count < len do			(				len = __verts[k].count				best = k			)			obj.selectededges = __edges[best]			__verts[best]		)	)first = $.selectedverts[1].indexsecond = $.selectedverts[2].indexverts = searchLoopConnection $ first second