function polygon_offset(pointList, offset){	// Scale up the path so it is easier to see	//var scale = 100;	//ClipperLib.JS.ScaleUpPath(holePointList, scale);	// Possibly ClipperLib.Clipper.SimplifyPolygons() here	// Possibly ClipperLib.Clipper.CleanPolygons() here	// MiterLimit: http://sourceforge.net/p/jsclipper/wiki/documentation/#clipperlibclipperoffsetmiterlimit	// roundPrecision	var co = new ClipperLib.ClipperOffset(20, 0.25);	co.AddPath(pointList, ClipperLib.JoinType.jtMiter, ClipperLib.EndType.etClosedPolygon);	var offsetted_paths = new ClipperLib.Paths();	co.Execute(offsetted_paths, offset);	if(offsetted_paths.length)	{		var resultant_point_list = [];		offsetted_paths[0].forEach(function(point, index, array) {			// Clipper uses a slightly differnt format			resultant_point_list.push(new Vector2(point.X, point.Y));		});	}	return resultant_point_list || false;}function Vector2(x, y) {	this.x = x;	this.X = x;	this.y = y;	this.Y = y;}Vector2.prototype.add = function(other) {	return new Vector2(this.x + other.x, this.y + other.y);}Vector2.prototype.subtract = function(other) {	return new Vector2(this.x - other.x, this.y - other.y);}Vector2.prototype.scale = function(scalar) {	return new Vector2(this.x*scalar, this.y*scalar);}Vector2.prototype.normalized = function() {	var magnitude = Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2));	return new Vector2(this.x/magnitude, this.y/magnitude);}Vector2.prototype.dot = function(other) {	return this.x*other.x + this.y*other.y;}Vector2.prototype.closestPointOnLine = function(pt1, pt2){	var A = this.subtract(pt1);	var u = pt2.subtract(pt1).normalized();		return pt1.add(u.scale(A.dot(u)));}Vector2.prototype.vector2Args = function(x, y) {	x = x || 0;	y = y || 0;	return [this.x + x, this.y + y];}		function Rect(position, width, height){	this.position = position;	this.width = width;	this.height = height;}Rect.prototype.rectArgs = function(x, y, width, height) {	x = x || 0;	y = y || 0;	width = width || 0;	height =  height || 0;	return [this.position.x + x, this.position.y + y, this.width + width, this.height + height];};function Shape(shapePointList, holePointList){	// Array of Vector2	this.pointList = shapePointList;	this.holePointList = holePointList;    }Shape.prototype._drawInternal = function(context, position, pointList){	context.moveTo.apply(context, pointList[0].add(position).vector2Args());	pointList.forEach(function(point, index, array) {		context.lineTo.apply(context, point.add(position).vector2Args());	});  };Shape.prototype.draw = function(context, position, drawReverse) {	// You will probably put a `context.beginPath();` before this call to `draw`	this.drawShape(context, position, drawReverse);	if(this.holePointList && this.holePointList.length > 0)	{		context.closePath();		this.drawHole(context, position, drawReverse);	}	// You will probably put a `context.closePath();` after this call to `draw`};Shape.prototype.drawShape = function(context, position, drawReverse) {	var pointList = drawReverse ? this.pointList.reverse() : this.pointList;	this._drawInternal(context, position, pointList);};// Since holes are always drawn in reverse (ccw), specify if we should draw it normally// Note: this is opposite of `drawShape`Shape.prototype.drawHole = function(context, position, drawNormal) {	var pointList = drawNormal ?  this.holePointList : this.holePointList.reverse();	this._drawInternal(context, position, pointList);};// Draws a only a inner shadowShape.prototype.drawShapeInnerShadow = function(context, position, shadowColor, shadowBlur){	// We must have a context to do anything	if(context)	{		position = position || new Vector2(0, 0);		shadowColor = shadowColor || '#000000'		shadowBlur = shadowBlur || 0;		context.save();		/* */		// Add in the clip for the shape inner shadow		context.beginPath();		this.draw(context, position);		context.closePath();		context.clip();		// Used for lineWidth and somehow affects the intensity of that shadow		// 5 is a good value		var shadowIntensity = shadowBlur/3;		context.beginPath();		context.strokeStyle = '#000000'; // doesn't matter		context.lineWidth = shadowIntensity;		context.shadowBlur = shadowBlur;		context.shadowColor = shadowColor; // inset border color		context.shadowOffsetX = 0;		context.shadowOffsetY = 0;		context.beginPath();		new Shape(polygon_offset(this.pointList, shadowIntensity)).drawShape(context, position);		context.closePath();		context.stroke();		/* */		context.restore();		context.save();		// If this shape has a hole		if(this.holePointList && this.holePointList.length > 0)		{			/* */			// Create a cache element to draw the hole shadow on			var _scratchCanvas = document.createElement('canvas');			_scratchCanvas.width = context.canvas.width;			_scratchCanvas.height = context.canvas.height;			var _scratchCanvasContext = _scratchCanvas.getContext('2d');			// Draw the hole shadow box			_scratchCanvasContext.beginPath();			myShape.drawHole(_scratchCanvasContext, position, true);			_scratchCanvasContext.closePath();			_scratchCanvasContext.shadowBlur = shadowBlur;			_scratchCanvasContext.shadowColor = shadowColor; // inset border color			_scratchCanvasContext.shadowOffsetX = 0;			_scratchCanvasContext.shadowOffsetY = 0;			_scratchCanvasContext.fill();			// Cut hole in the cache canvas			// This leaves only the shadow left			_scratchCanvasContext.beginPath();			this.drawHole(_scratchCanvasContext, position, true);			_scratchCanvasContext.closePath();			_scratchCanvasContext.globalCompositeOperation = 'destination-out';			_scratchCanvasContext.fill();			// Copy it over to the main canvas			context.drawImage(_scratchCanvas, 0, 0);			// Debug the cache canvas			//var new_image_url = _scratchCanvas.toDataURL(); var img = document.createElement('img'); img.src = new_image_url;			//document.body.appendChild(img);			/* */		}		// Restore the canvas to what we were given.		context.restore();	}}var canvas = $('.main-canvas')[0];var context = canvas.getContext('2d');context.save();var myRect = new Rect(new Vector2(75, 50), 75, 50);context.beginPath();context.rect.apply(context, myRect.rectArgs());context.fillStyle = '#cc6262';context.closePath();context.fill();context.beginPath();context.rect.apply(context, myRect.rectArgs());context.clip();var shadowIntensity = 5;context.beginPath();context.strokeStyle = '#ff0000'; // doesn't mattercontext.lineWidth = shadowIntensity;context.shadowBlur = 15;context.shadowColor = '#000000'; // inset border colorcontext.shadowOffsetX = 0;context.shadowOffsetY = 0;context.rect.apply(context, myRect.rectArgs(-(shadowIntensity/2), -(shadowIntensity/2), shadowIntensity, shadowIntensity));context.stroke();context.restore();// Custom Shape// -----------------context.save();var shapePointList = [	new Vector2(0, 0),	new Vector2(40, 50),	new Vector2(70, 20),	new Vector2(160, 10),	new Vector2(220, 65),	new Vector2(205, 150),	new Vector2(140, 130),	new Vector2(100, 150),	new Vector2(20, 100)];/* * /// Rectanglevar holePointList = [	new Vector2(0, 0),	new Vector2(75, 0),	new Vector2(75, 50),	new Vector2(0, 50)];/* *//* */var holePointList = [	new Vector2(0, 20),	new Vector2(30, 0),	new Vector2(52, 30),	new Vector2(80, 20),	new Vector2(60, 60),	new Vector2(42, 80),	new Vector2(0, 50)];/* */var translatedHolePointList = [];holePointList.forEach(function(point, index, array) {	translatedHolePointList.push(point.add(new Vector2(80, 50)));});var myShape = new Shape(shapePointList, translatedHolePointList);context.beginPath();myShape.draw(context, new Vector2(200, 0));context.closePath();// Base custom shapecontext.fillStyle = '#62cc62';/* * /context.shadowBlur = 15;context.shadowColor = '#000000'; // inset border colorcontext.shadowOffsetX = 0;context.shadowOffsetY = 0;/* */context.fill();myShape.drawShapeInnerShadow(context, new Vector2(200, 0), '#000000', 15);/* * /// Base custom plain versioncontext.beginPath();myShape.draw(context, new Vector2(180, 200), 0, 0);context.closePath();context.fillStyle = 'rgba(255, 0, 0, .5)';context.fill();/* */