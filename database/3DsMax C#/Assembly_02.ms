 ---here I have one visual studio C# class lib project with this code   ---what I'm compiling as MYLib.dll      /* using System;   * using System.Windows.Forms;   * namespace MYLib   * {   *	    *	 /// <summary>   *	 /// First version   *	 /// </summary>   *	 //public class MyClass   *	 //{   *	 //	public void Call()   *	 //	{   *	 //		MessageBox.Show("Say First");   *	 //	}   *	 //}   *    *	 /// <summary>   *	 /// Second version   *	 /// </summary>   *	 public class MyClass   *	 {   *		 public void Call()   *		 {   *			 MessageBox.Show("Say Second");   *		 }   *	 }   * }   */      ------------Now in Maxscript----------------------------      ---Create dotnet class to use some useful static functions   AppDomain = dotNetClass "System.AppDomain"   Assembly = dotNetClass "System.Reflection.Assembly"   AssemblyName = dotNetClass "System.Reflection.AssemblyName"      ---set the shadow copy so actually original assembly file can be overriten...SetShadowCopyFiles is obsoluted according to MSDN   ---but that is the only way to enable ShadowCopy option for current AppDomain. Because through Maxscript   ---creation of new appdomain is not possible so we have to use current AppDoamin and for 3dsMax2009 ShadowCopy for current Appdomain is false bydefault   --- whatever the dir we use with SetShadowCopyPath, all assembly loaded later from this directory automatically will be shadow copied by .net runtime   ---I'm for demonstartion using "C:\Release" but you can use directly use yourVCSharpProject/Bin/Release or Debug folder   ---make sure everytime you have differnt version number, In case of Visual Studio 2008 C# project version settings   ---under project settings -> Application-->Assembly Information or you can change AssemblyInfo.cs file of your project manually   ----or the addin I have specified for visual studio to autoincrement it you can use http://www.codeplex.com/autobuildversion      ---using default cache path ensure delete of shadow copy files will be  handle by runtime automatically   ---if you use your own cache path using AppDomain.CurrentDomain.SetCachePath then you have delete them manually   ---So I'm not using that      AppDomain.CurrentDomain.SetShadowCopyPath (@"C:\Release\")   AppDomain.CurrentDomain.SetShadowCopyFiles()         ----load the first version...again don't forget to use different version for every compile in visual studio   ----AssemblyName.GetAssemblyName using this method we can query to the dll what the version number we have setted in visual studio   assemName = AssemblyName.GetAssemblyName(@"C:\Release\MYLib1.dll")   print assemName.FullName   ---result "MYLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=d8101bd49700bbd5"      ----Now load it using assembly name, don't use LoadFromFile   assem = Assembly.Load assemName   print assem.Location   ---will print the temp file path runtime used for shadow copy  somthing like "\Application Data\assembly\dl3\OAV6J36X.Q9J\1Z7DWQ44.552\0f496cae\004a3872_967cc901\MYLib1.dll"      ---use this way to create object of sepcific version instead of (dotNetObject "MYLib.MyClass")   myObj = assem.CreateInstance "MYLib.MyClass" ---create object of first version of MYLib.MyClass   myObj.Call() --- call the first version of the method      assemName = AssemblyName.GetAssemblyName(@"C:\Release\MYLib2.dll")   print assemName.FullName   ---result "MYLib, Version=1.1.0.0, Culture=neutral, PublicKeyToken=d8101bd49700bbd5"      assem = Assembly.Load assemName   print assem.Location   --- show the temp file path runtime used for shadow copy  somthing like "\Application Data\assembly\dl3\OAV6J36X.Q9J\1Z7DWQ44.552\3da67b63\00d97aa5_967cc901\MYLib2.dll"      myObj = assem.CreateInstance "MYLib.MyClass" ---create object of second version of MYLib.MyClass   myObj.Call()--- call the second version of the method