Here's an excerpt of code to dock a .NET form inside a viewport:[Flags]        internal enum WindowStyles : uint        {            WS_OVERLAPPED = 0x00000000,            WS_POPUP = 0x80000000,            WS_CHILD = 0x40000000,            WS_MINIMIZE = 0x20000000,            WS_VISIBLE = 0x10000000,            WS_DISABLED = 0x08000000,            WS_CLIPSIBLINGS = 0x04000000,            WS_CLIPCHILDREN = 0x02000000,            WS_MAXIMIZE = 0x01000000,            WS_BORDER = 0x00800000,            WS_DLGFRAME = 0x00400000,            WS_VSCROLL = 0x00200000,            WS_HSCROLL = 0x00100000,            WS_SYSMENU = 0x00080000,            WS_THICKFRAME = 0x00040000,            WS_GROUP = 0x00020000,            WS_TABSTOP = 0x00010000,            WS_MINIMIZEBOX = 0x00020000,            WS_MAXIMIZEBOX = 0x00010000,            WS_CAPTION = WS_BORDER | WS_DLGFRAME,            WS_TILED = WS_OVERLAPPED,            WS_ICONIC = WS_MINIMIZE,            WS_SIZEBOX = WS_THICKFRAME,            WS_TILEDWINDOW = WS_OVERLAPPEDWINDOW,            WS_OVERLAPPEDWINDOW = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX,            WS_POPUPWINDOW = WS_POPUP | WS_BORDER | WS_SYSMENU,            WS_CHILDWINDOW = WS_CHILD,        }        public const Int32 GWL_STYLE = -16;        [DllImport( "user32.dll", CharSet = CharSet.Auto, ExactSpelling = true )]        internal static extern IntPtr SetParent( IntPtr hWnd, IntPtr hWndParent );        [DllImport( "user32.dll", CharSet = CharSet.Auto, ExactSpelling = true )]        internal static extern IntPtr GetParent( IntPtr hWnd );        [DllImport( "user32.dll" )]        internal static extern WindowStyles GetWindowLong( IntPtr hWnd, Int32 nIndex );        [DllImport( "user32.dll" )]        internal static extern UInt32 SetWindowLong( IntPtr hWnd, Int32 nIndex, UInt32 dwNewLong );        //[DllImport( "user32.dll" )]        //internal static extern IntPtr SetParent( IntPtr child, IntPtr newParent );        internal static WindowStyles GetWindowStyle( IntPtr hWnd )        {            return (WindowStyles)GetWindowLong( hWnd, GWL_STYLE );        }        internal static void SetWindowStyle( IntPtr hWnd, WindowStyles windowStyle )        {            SetWindowLong( hWnd, GWL_STYLE, (UInt32)windowStyle );        }        class MainViewWindow : global::Autodesk.Max.Plugins.ViewWindow        {            IntPtr previousParent;            WindowStyles previousStyle;            public override IntPtr CreateViewWindow( IntPtr hParent, int x, int y, int w, int h )            {                this.previousParent = GetParent( Plugin.Instance.MainFrame.Handle );                this.previousStyle = GetWindowStyle( Plugin.Instance.MainFrame.Handle );                MainFrame mainFrame = Plugin.Instance.LaunchDefault_( hParent, Plugin.LayoutType.General );                SetWindowStyle( mainFrame.Handle, WindowStyles.WS_CHILD | WindowStyles.WS_VISIBLE | WindowStyles.WS_CLIPCHILDREN );                SetParent( mainFrame.Handle, hParent );                mainFrame.dockedInsideExtendedView = true;                return mainFrame.Handle;            }            public override void DestroyViewWindow( IntPtr hWnd )            {                Plugin.Instance.MainFrame.dockedInsideExtendedView = false;                SetWindowStyle( Plugin.Instance.MainFrame.Handle, this.previousStyle );                SetParent( Plugin.Instance.MainFrame.Handle, this.previousParent );                Plugin.Instance.MainFrame.FormBorderStyle = FormBorderStyle.Sizable;                // NOTE: Do not call close here because when resetting a scene the layout is saved correctly, then this                // method is called by Max and Close(...) here saves the layuout again, with an empty view thus causing                // a blank layout to be saved                Plugin.Instance.MainFrame.Hide();            }            public override string Name            {                get { return ProjectName + " Main Window"; }            }            /// <summary>            /// Can only have one mainframe!            /// </summary>            public override int NumberCanCreate            {                get { return 1; }            }            public override bool CanCreate            {                get                {                    // Cannot put Mainframe into another view without first undocking it from the previous one                    return !Plugin.Instance.MainFrame.dockedInsideExtendedView;                }            }        }Marsel Khadiyev (Software Developer, EPHERE Inc.)