(	fn compileCString =	(		SuperCubeClassName = "PathScripts.SuperCube"		classStr = (		"using System;		using Autodesk.Max;		using System.Collections.Generic;		namespace PathScripts		{			class SuperCube			{				static public IGlobal global = GlobalInterface.Instance;				static public IInterface14 ip = global.COREInterface14;				static public void createSuperCube(int numCubes)				{					int[][] Faces = new int[12][] { new int[3] { 0, 2, 3 }, new int[3] { 3, 1, 0 }, new int[3] { 4, 5, 7 }, new int[3] { 7, 6, 4 },																new int[3] { 0, 1, 5 }, new int[3] { 5, 4, 0 }, new int[3] { 1, 3, 7 }, new int[3] { 7, 5, 1 },																new int[3] { 3, 2, 6 }, new int[3] { 6, 7, 3 }, new int[3] { 2, 0, 4 }, new int[3] { 4, 6, 2 }};					float[][] Verts = new float[8][] { new float[3] { -0.5f, -0.5f, -0.5f }, new float[3] { 0.5f, -0.5f, -0.5f }, new float[3] { -0.5f, 0.5f, -0.5f }, new float[3] { 0.5f, 0.5f, -0.5f },																   new float[3] { -0.5f, -0.5f, 0.5f }, new float[3] { 0.5f, -0.5f, 0.5f }, new float[3] { -0.5f, 0.5f, 0.5f }, new float[3] { 0.5f, 0.5f, 0.5f }};					uint[] theElementSmooth = new uint[12] { 2, 2, 4, 4, 8, 8, 16, 16, 32, 32, 64, 64 };					IClass_ID cid = global.Class_ID.Create((uint)BuiltInClassIDA.EDITTRIOBJ_CLASS_ID, 0);					// Create a new TriObject.					object objectEditMesh = ip.CreateInstance(SClass_ID.Geomobject, cid as IClass_ID);					// Create a new node to hold it in the scene.					IObject objBaseObject = (IObject)objectEditMesh;					IINode node = global.COREInterface.CreateObjectNode(objBaseObject);					// Name it unique.					string newName = \"SuperCube\";								//ip.MakeNameUnique(ref newName);					node.Name = newName;					// Cast to TriObject					ITriObject triNew = objBaseObject as ITriObject;					int nTotal = numCubes * numCubes * numCubes;					Random r = new Random();					int countVerts = 0;					int actualVert = 0;					int actualFace = 0;					double range = 1.0 - 0.1;					double rangeUV = 0.0 - 1.0;					IMesh TMESH = triNew.Mesh;					TMESH.ApplyUVWMap(0, 1, 1, 1, 0, 0, 0, 0, global.Matrix3.Create(true), 1);					// Setup the new TriObject with number of faces and verts					TMESH.SetNumFaces(12 * nTotal, false, false);					TMESH.SetNumVerts(8 * nTotal, false, false);					TMESH.SetNumTVFaces(12 * nTotal, false, 0);					TMESH.SetNumTVerts(8 * nTotal, false);					IList<IFace> MESH_FACES = TMESH.Faces;					IList<ITVFace> theTFaces = TMESH.TvFace;					for (int z = 0; z < numCubes; z++)					{						for (int y = 0; y < numCubes; y++)						{							for (int x = 0; x < numCubes; x++)							{								actualVert = (8 * countVerts);								actualFace = (12 * countVerts);								float rng = (float)(r.NextDouble() * range + 0.1);								float rng2 = (float)(r.NextDouble() * rangeUV);								for (int v = 0; v < 8; v++)								{									TMESH.SetVert(v + actualVert, Verts[v][0] * rng + x, Verts[v][1] * rng + y, Verts[v][2] * rng + z);									TMESH.SetTVert(v + actualVert, rng2, rng2, 0);								}								for (int f = 0; f < 12; f++)								{									IFace FACE = MESH_FACES[f + actualFace];									ITVFace TVFACE = theTFaces[f + actualFace];									FACE.SetVerts(Faces[f][0] + actualVert, Faces[f][1] + actualVert, Faces[f][2] + actualVert);									TVFACE.SetTVerts(Faces[f][0] + actualVert, Faces[f][1] + actualVert, Faces[f][2] + actualVert);									FACE.SetEdgeVisFlags(EdgeVisibility.Vis, EdgeVisibility.Vis, EdgeVisibility.Invis);									FACE.SmGroup = theElementSmooth[f];								}								countVerts++;							}						}					}					TMESH.InvalidateGeomCache();				}			}		}		"		)			compilerParams = dotnetobject "System.CodeDom.Compiler.CompilerParameters"		dotnet.setlifetimecontrol compilerParams #dotnet		compilerParams.ReferencedAssemblies.Add("System.dll");		compilerParams.ReferencedAssemblies.Add( getdir #maxroot + "Autodesk.Max.dll");		compilerParams.GenerateInMemory = on		csharpProvider = dotnetobject "Microsoft.CSharp.CSharpCodeProvider"		compilerResults = csharpProvider.CompileAssemblyFromSource compilerParams #(classStr)		dotnet.setlifetimecontrol compilerResults #dotnet				----	CHECK COMPILE		if (compilerResults.Errors.Count > 0 ) then		(			local errs = stringstream ""			for i = 0 to (compilerResults.Errors.Count-1) do			(				local err = compilerResults.Errors.Item				format "Error:% Line:% Column:% %\n" err.ErrorNumber err.Line err.Column err.ErrorText to:errs			)			format "%\n" errs			return undefined		)					----			else		(			compilerResults.CompiledAssembly		)	)		global assembly = compileCString()	SuperCube = assembly.CreateInstance "PathScripts.SuperCube"			/* TEST */			delete objects	gc()	st=timestamp(); sh=heapfree	SuperCube.createSuperCube 15	format "time:% heap:%\n" (timestamp()-st) (sh-heapfree)		local pmat = StandardMaterial name:"pMat" 	local ramp = Gradient_Ramp() 	ramp.Gradient_Ramp.Flag__1.color = [255,0,0]	ramp.Gradient_Ramp.Flag__2.color = [0,255,0]	ramp.Gradient_Ramp.Flag__3.color = [0,0,255]	pmat.diffuseMap = ramp	showTextureMap pMat on	$SuperCube.material = pMat	)