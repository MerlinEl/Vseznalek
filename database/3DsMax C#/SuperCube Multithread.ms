(	fn compileCString =	(		SuperCubeClassName = "PathScripts.SuperCube"		classStr = (		"using System;using System.Threading.Tasks;using System.Threading;using Autodesk.Max;using System.Collections.Generic;namespace PathScripts{    public static class StaticRandom    {        static int seed = Environment.TickCount;        static readonly ThreadLocal<Random> random =            new ThreadLocal<Random>(() => new Random(Interlocked.Increment(ref seed)));        public static int Rand()        {            return random.Value.Next();        }    }    class SuperCube    {        static public IGlobal global = GlobalInterface.Instance;        static public IInterface14 ip = global.COREInterface14;        static public void createSuperCube(int numCubes)        {            int[][] Faces = new int[12][] { new int[3] { 0, 2, 3 }, new int[3] { 3, 1, 0 }, new int[3] { 4, 5, 7 }, new int[3] { 7, 6, 4 },                                                                new int[3] { 0, 1, 5 }, new int[3] { 5, 4, 0 }, new int[3] { 1, 3, 7 }, new int[3] { 7, 5, 1 },                                                                new int[3] { 3, 2, 6 }, new int[3] { 6, 7, 3 }, new int[3] { 2, 0, 4 }, new int[3] { 4, 6, 2 }};            float[][] Verts = new float[8][] { new float[3] { -0.5f, -0.5f, -0.5f }, new float[3] { 0.5f, -0.5f, -0.5f }, new float[3] { -0.5f, 0.5f, -0.5f }, new float[3] { 0.5f, 0.5f, -0.5f },                                                                   new float[3] { -0.5f, -0.5f, 0.5f }, new float[3] { 0.5f, -0.5f, 0.5f }, new float[3] { -0.5f, 0.5f, 0.5f }, new float[3] { 0.5f, 0.5f, 0.5f }};            uint[] theElementSmooth = new uint[12] { 2, 2, 4, 4, 8, 8, 16, 16, 32, 32, 64, 64 };            IClass_ID cid = global.Class_ID.Create((uint)BuiltInClassIDA.EDITTRIOBJ_CLASS_ID, 0);            // Create a new TriObject.            object objectEditMesh = ip.CreateInstance(SClass_ID.Geomobject, cid as IClass_ID);            // Create a new node to hold it in the scene.            IObject objBaseObject = (IObject)objectEditMesh;            IINode node = global.COREInterface.CreateObjectNode(objBaseObject);            // Name it unique.            string newName = \"SuperCube\";                    //ip.MakeNameUnique(ref newName);            node.Name = newName;            // Cast to TriObject            ITriObject triNew = objBaseObject as ITriObject;            int nTotal = numCubes * numCubes * numCubes;            IMesh TMESH = triNew.Mesh;            // Setup the new TriObject with number of faces and verts            TMESH.SetNumFaces(12 * nTotal, false, false);            TMESH.SetNumVerts(8 * nTotal, false, false);            IList<IFace> MESH_FACES = TMESH.Faces;            Parallel.For(0, numCubes, z => setMesh(TMESH, numCubes, Verts, Faces, MESH_FACES, theElementSmooth, z));            TMESH.InvalidateGeomCache();        }        static public void setMesh(IMesh TMESH, int numCubes, float[][] Verts, int[][] Faces, IList<IFace> MESH_FACES, uint[] theElementSmooth, int z)        {            Random r = new Random(StaticRandom.Rand());            int countVerts = ((numCubes * numCubes) * z);            int actualVert = ((numCubes * numCubes) * z);            int actualFace = 0;            double range = 1.0 - 0.1;            for (int y = 0; y < numCubes; y++)            {                for (int x = 0; x < numCubes; x++)                {                    actualVert = ((8 * countVerts));                    actualFace = ((12 * countVerts));                    float rng = (float)(r.NextDouble() * range + 0.1);                    for (int v = 0; v < 8; v++)                    {                        TMESH.SetVert(v + actualVert, Verts[v][0] * rng + x, Verts[v][1] * rng + y, Verts[v][2] * rng + z);                    }                    for (int f = 0; f < 12; f++)                    {                        IFace FACE = MESH_FACES[f + actualFace];                        FACE.SetVerts(Faces[f][0] + actualVert, Faces[f][1] + actualVert, Faces[f][2] + actualVert);                        FACE.SetEdgeVisFlags(EdgeVisibility.Vis, EdgeVisibility.Vis, EdgeVisibility.Invis);                        FACE.SmGroup = theElementSmooth[f];                    }                    countVerts++;                }            }        }    }}				"		)			compilerParams = dotnetobject "System.CodeDom.Compiler.CompilerParameters"		dotnet.setlifetimecontrol compilerParams #dotnet		compilerParams.ReferencedAssemblies.Add("System.dll");		compilerParams.ReferencedAssemblies.Add( getdir #maxroot + "Autodesk.Max.dll");		compilerParams.GenerateInMemory = on		csharpProvider = dotnetobject "Microsoft.CSharp.CSharpCodeProvider"		compilerResults = csharpProvider.CompileAssemblyFromSource compilerParams #(classStr)		dotnet.setlifetimecontrol compilerResults #dotnet				----	CHECK COMPILE		if (compilerResults.Errors.Count > 0 ) then		(			local errs = stringstream ""			for i = 0 to (compilerResults.Errors.Count-1) do			(				local err = compilerResults.Errors.Item				format "Error:% Line:% Column:% %\n" err.ErrorNumber err.Line err.Column err.ErrorText to:errs			)			format "%\n" errs			return undefined		)					----			else		(			compilerResults.CompiledAssembly		)	)		global assembly = compileCString()	SuperCube = assembly.CreateInstance "PathScripts.SuperCube"			/* TEST */			delete objects	gc()	st=timestamp(); sh=heapfree	SuperCube.createSuperCube 50			format "time:% heap:%\n" (timestamp()-st) (sh-heapfree)		)