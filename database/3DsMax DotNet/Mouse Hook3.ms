(	str="using System;"	str+="using System.Collections.Generic;"	str+="using System.Text;"	str+="using System.Runtime.InteropServices;"	str+="using System.Windows.Forms;"	str+="using System.Diagnostics;"	str+="using System.Drawing;"	str+="class InterceptMouse"	str+="{"	str+="    private static IntPtr _hookID = IntPtr.Zero;"	str+="public delegate void MouseDownHandler(object Sender, MouseEventArgs e);"	str+="public event MouseDownHandler MouseDown;"	str+="public delegate void MouseUpHandler(object Sender, MouseEventArgs e);"	str+="public event MouseUpHandler MouseUp;"	str+="public delegate void MouseMoveHandler(object Sender, MouseEventArgs e);"	str+="public event MouseMoveHandler MouseMove;"			str+="public InterceptMouse()"	str+="{"	str+="    _hookID = SetHook(HookCallback);"	str+="}"	str+="public void Release()"	str+="{"	str+="	UnhookWindowsHookEx(_hookID);"	str+="}"		str+="private static IntPtr SetHook(LowLevelMouseProc proc)"	str+="{"	str+="    using (Process curProcess = Process.GetCurrentProcess())"	str+="    using (ProcessModule curModule = curProcess.MainModule)"	str+="    {"	str+="        return SetWindowsHookEx(WH_MOUSE_LL, proc,"	str+="            GetModuleHandle(curModule.ModuleName), 0);"	str+="    }"	str+="}"	str+="private delegate IntPtr LowLevelMouseProc(int nCode, IntPtr wParam, IntPtr lParam);"	str+="private IntPtr HookCallback(int nCode, IntPtr wParam, IntPtr lParam)"	str+="{"	str+="   if (nCode >= 0)"	str+="	{"	str+="		MSLLHOOKSTRUCT hookStruct = (MSLLHOOKSTRUCT)Marshal.PtrToStructure(lParam, typeof(MSLLHOOKSTRUCT));"	str+="		if (MouseMessages.WM_LBUTTONDOWN == (MouseMessages)wParam)"	str+="		{"	str+="			MouseEventArgs e = new MouseEventArgs(MouseButtons.Left,1,hookStruct.pt.x,hookStruct.pt.y,0);"	str+="         	MouseDown(this, e);"	str+="		}"	str+="		else if (MouseMessages.WM_LBUTTONUP == (MouseMessages)wParam)"	str+="		{			"	str+="			MouseEventArgs e = new MouseEventArgs(MouseButtons.Left,1,hookStruct.pt.x,hookStruct.pt.y,0);"	str+="			MouseUp(this, e);"	str+="		}"	str+="		else if (MouseMessages.WM_MOUSEMOVE == (MouseMessages)wParam)"	str+="		{"	str+="				MouseEventArgs e = new MouseEventArgs(MouseButtons.None,0,hookStruct.pt.x,hookStruct.pt.y,0);"	str+="           	MouseMove(this, e);"	str+="		}"	str+="			else if (MouseMessages.WM_RBUTTONDOWN == (MouseMessages)wParam)"	str+="{"	str+="MouseEventArgs e = new MouseEventArgs(MouseButtons.Right,1,hookStruct.pt.x,hookStruct.pt.y,0);"	str+="            	MouseDown(this, e);"	str+="			}"	str+="			else if (MouseMessages.WM_RBUTTONUP == (MouseMessages)wParam)"	str+="			{			"	str+="				MouseEventArgs e = new MouseEventArgs(MouseButtons.Right,1,hookStruct.pt.x,hookStruct.pt.y,0);"	str+="				MouseUp(this, e);"	str+="			}"	str+="		}"	str+="       return CallNextHookEx(_hookID, nCode, wParam, lParam);"	str+="   }"	str+="   private const int WH_MOUSE_LL = 14;"	str+="   private enum MouseMessages"	str+="  {"	str+="      WM_LBUTTONDOWN = 0x0201,"	str+="       WM_LBUTTONUP = 0x0202,"	str+="      WM_MOUSEMOVE = 0x0200,"	str+="      WM_MOUSEWHEEL = 0x020A,"	str+="      WM_RBUTTONDOWN = 0x0204,"	str+="       WM_RBUTTONUP = 0x0205"	str+="   }"	str+="    [StructLayout(LayoutKind.Sequential)]"	str+="   private struct POINT"	str+="   {"	str+="       public int x;"	str+="        public int y;"	str+="    }"	str+="   [StructLayout(LayoutKind.Sequential)]"	str+="    private struct MSLLHOOKSTRUCT"	str+="   {"	str+="      public POINT pt;"	str+="      public uint mouseData;"	str+="     public uint flags;"	str+="     public uint time;"	str+="     public IntPtr dwExtraInfo;"	str+="   }"	str+="    [DllImport(\"user32.dll\", CharSet = CharSet.Auto, SetLastError = true)]"	str+="    private static extern IntPtr SetWindowsHookEx(int idHook,"	str+="       LowLevelMouseProc lpfn, IntPtr hMod, uint dwThreadId);"	str+="   [DllImport(\"user32.dll\", CharSet = CharSet.Auto, SetLastError = true)]"	str+="   [return: MarshalAs(UnmanagedType.Bool)]"	str+="   private static extern bool UnhookWindowsHookEx(IntPtr hhk);"	str+="   [DllImport(\"user32.dll\", CharSet = CharSet.Auto, SetLastError = true)]"	str+="   private static extern IntPtr CallNextHookEx(IntPtr hhk, int nCode,"	str+="       IntPtr wParam, IntPtr lParam);"	str+="   [DllImport(\"kernel32.dll\", CharSet = CharSet.Auto, SetLastError = true)]"	str+="  private static extern IntPtr GetModuleHandle(string lpModuleName);"			str+="}"	global mouseHook	struct mouseHookStr	(		mouseOps,				fn CreateWinAssembly =		(			local csharpProvider = dotnetobject "Microsoft.CSharp.CSharpCodeProvider"			local compilerParams = dotnetobject "System.CodeDom.Compiler.CompilerParameters"							compilerParams.ReferencedAssemblies.addRange #("System.dll","System.Windows.Forms.dll","System.Drawing.dll")			compilerParams.GenerateInMemory = on			local compilerResults = csharpProvider.CompileAssemblyFromSource compilerParams #(str)						for er =0 to compilerResults.errors.count-1 do print (compilerResults.errors.item[er].tostring())			mouseOps = compilerResults.CompiledAssembly.CreateInstance "InterceptMouse"		),				fn mouseDown s e = print "mouse down",		fn mouseUp s e = print "mouse up",		fn mouseMove s e = print "mouse move",		fn initStruct =		(			CreateWinAssembly()			dotNet.addEventHandler mouseOps "MouseDown" mouseDown			dotNet.addEventHandler mouseOps "MouseUp" mouseUp			dotNet.addEventHandler mouseOps "MouseMove" mouseMove		),				_init = initStruct()		))mouseHook = mouseHookStr()-- call mousehook.mouseops.release() to stop it