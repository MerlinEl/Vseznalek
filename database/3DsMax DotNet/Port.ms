fn createServer ipAddress port =  (		dotNetIPAddress = (DotNetClass "System.Net.IPAddress").Parse ipAddress	tcpListener = DotNetObject "System.Net.Sockets.TcpListener" dotNetIPAddress port	tcpListener.Start()	msgReceived = ""	print ("listening on " + (ipAddress as string) + ":" + (port as string))	while true do 	(		print("waiting for a client socket")		socket = tcpListener.AcceptSocket()		print("client socket accepted")		while msgReceived != "exit" do		(			sendByteStream = DotNetObject "System.Byte[]" 10000			socket.Receive sendByteStream			encoding = DotnetClass "System.Text.UTF8Encoding"			msgReceived = trimright (encoding.UTF8.GetString(sendByteStream))			if msgReceived == "socketClosing" then (				print("closing socket")				socket.Close()				exit			)			else (				if msgReceived != "" then (					print("execute : " + msgReceived)					-- execute msgReceived					try(						result = execute(msgReceived)					) catch (						error_str = "***" + getCurrentException() +"***\n" 						print(error_str)					)					-- send result					ascii_encoder = dotNetObject "System.Text.ASCIIEncoding"					bytes = ascii_encoder.GetBytes (result as string)					result = socket.Send bytes				)			)		)	))fn BackgroundTcpListenerDoWork theSender theEvent = (	ipAddress = "127.0.0.1"	port = 5688	try (		createServer ipAddress port		exit	)	catch(		print("server crashed or port " + (port as string) + " is already used")	))BackgroundWorker = DotNetObject "System.ComponentModel.BackgroundWorker"DotNet.AddEventHandler BackgroundWorker "DoWork" BackgroundTcpListenerDoWorkBackgroundWorker.WorkerSupportsCancellation = trueBackgroundWorker.RunWorkerAsync()/*# Python codeimport socketdef sendMessage(msg, socket):	socket.send(msg)	return s.recv(responseBufferSize)## connect to the serverresponseBufferSize = 1024s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect(('127.0.0.1', 7500))## send messagessendMessage('saveMaxFile \"C:/test.max\"', s)## close the socket from server and client sidesendMessage('socketClosing', s)s.shutdown(socket.SHUT_RDWR)s.close()*/