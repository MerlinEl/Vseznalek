_template_1 = (		"<?xml version='1.0' encoding='UTF-8'?>" +		"<bookstore>" +			"<book category='COOKING'>" +				"<title lang='en'>Everyday Italian</title>" +				"<author>Giada De Laurentiis</author>" +				"<year>2005</year>" +				"<price>30.00</price>" +			"</book>" +			"<book category='CHILDREN'>" +				"<title lang='en'>Harry Potter</title>" +				"<author>J K. Rowling</author>" +				"<year>2005</year>" +				"<price>29.99</price>" +			"</book>" +			"<book category='WEB'>" +				"<title lang='en'>XQuery Kick Start</title>" +				"<author>James McGovern</author>" +				"<author>Per Bothner</author>" +				"<author>Kurt Cagle</author>" +				"<author>James Linn</author>" +				"<author>Vaidyanathan Nagarajan</author>" +				"<year>2003</year>" +				"<price>49.99</price>" +			"</book>" +			"<book category='WEB'>" +				"<title lang='en'>Learning XML</title>" +				"<author>Erik T. Ray</author>" +				"<year>2003</year>" +				"<price>39.95</price>" +			"</book>" +			"<book genre='novel' ISBN='1-861001-57-5'>" +			"<title>Pride And Prejudice</title>" +			"</book>" +		"</bookstore>"	)		xmlDoc = dotNetObject "system.xml.xmlDocument"local sw = dotNetObject "System.IO.StringWriter"xmlDoc.LoadXml _template_1xmlDoc.Save(sw)sw.ToString()orpublic static string PrintXML(string xml){    string result = "";    MemoryStream mStream = new MemoryStream();    XmlTextWriter writer = new XmlTextWriter(mStream, Encoding.Unicode);    XmlDocument document = new XmlDocument();    try    {        // Load the XmlDocument with the XML.        document.LoadXml(xml);        writer.Formatting = Formatting.Indented;        // Write the XML into a formatting XmlTextWriter        document.WriteContentTo(writer);        writer.Flush();        mStream.Flush();        // Have to rewind the MemoryStream in order to read        // its contents.        mStream.Position = 0;        // Read MemoryStream contents into a StreamReader.        StreamReader sReader = new StreamReader(mStream);        // Extract the text from the StreamReader.        string formattedXml = sReader.ReadToEnd();        result = formattedXml;    }    catch (XmlException)    {        // Handle the exception    }    mStream.Close();    writer.Close();    return result;}string FormatXml(string xml){     try     {         XDocument doc = XDocument.Parse(xml);         return doc.ToString();     }     catch (Exception)     {         // Handle and throw if fatal exception here; don't just ignore them         return xml;     } }   static string PrettyXml(string xml){    var stringBuilder = new StringBuilder();    var element = XElement.Parse(xml);    var settings = new XmlWriterSettings();    settings.OmitXmlDeclaration = true;    settings.Indent = true;    settings.NewLineOnAttributes = true;    using (var xmlWriter = XmlWriter.Create(stringBuilder, settings))    {        element.Save(xmlWriter);    }    return stringBuilder.ToString();}	/**	Other methods Resources			--  .<System.Xml.XmlNode>SelectSingleNode <System.String>xpath		--			TODO finish it -Not Used	*@Example		xml = mcXML(Micra.TempDir + "xml_test_99.xml")		xml.fromString _template		xml.toString()		local nodes = mcXML.getChildrenAt "/bookstore/*"		mcXML.getChildrenAt "//book"		mcXML.getChildrenAt "//book/author" 		return list(dotNetObject:System.Xml.XPathNodeList) of nodes(mcXMLNode)		fn getChildrenAt node_path = (			--local nodes = #()		--node.init doc.selectNodes node_path				local itemIter = (doc.selectnodes node_path).GetEnumerator()		while itemIter.MoveNext() do (					local attrIter = itemIter.Current.Attributes.GetEnumerator()			--format "\nEntry:%\n" 			while attrIter.MoveNext() do (							format "  % = %\n" attrIter.current.Name attrIter.current.value			)		)	),*/	/**				/*foreach (XmlNode node in nodes)		{			listBox1.Items.Add(node["name"].InnerText);		}*/				/*		XmlDocument doc = new XmlDocument();    doc.Load("books.xml");    //Display all the book titles.    XmlNodeList elemList = doc.GetElementsByTagName("title");    for (int i=0; i < elemList.Count; i++)    {         Console.WriteLine(elemList[i].InnerXml);    }  	*@Example		mcXML.printTree "//bookstore"		mcXML.printTree "//Skeleton/Bone/Item"	/*fn printTree node_path = (			local itemIter = (doc.selectnodes node_path).GetEnumerator()		while itemIter.MoveNext() do (					format "\nEntry:\n" 			local attrIter = itemIter.Current.Attributes.GetEnumerator()			while attrIter.MoveNext() do (							format "  % = %\n" attrIter.current.Name attrIter.current.value			)		)	),*//* header =  xmlDoc.item["Autodesk_Cache_File"] --this is how you pull an element section by name  --elments can have children elements.. in this case we are quarying the value of the attribute "Type" inside the "cacheType" element which is of the "Autodesk_Cache_File"..  cacheType = (header.item["cacheType"].GetAttribute("Type"))  timePerFrame = (header.item["cacheTimePerFrame"].GetAttribute("TimePerFrame")) 		xmlDoc.load 		myNodes = xmlDoc.selectNodes "//Part"		myPartname=(for i = 0 to myNodes.count-1 collect (myNodes.itemOf[i].getElementsByTagName "PartName").itemOf[0].attributes.itemOf["name"].value) 		myDescrips = (for i = 0 to myNodes.count-1 collect (myNodes.itemOf[i].getElementsByTagName "PartName").itemOf[0].attributes.itemOf["Description"].value) 		myProject = (for i = 0 to myNodes.count-1 collect (myNodes.itemOf[i].getElementsByTagName "PartName").itemOf[0].attributes.itemOf["Project"].value) 		myDiffuse = (for i = 0 to myNodes.count-1 collect (myNodes.itemOf[i].getElementsByTagName "PartName").itemOf[0].attributes.itemOf[ "Diffuse"].value)		mySpec= (for i = 0 to myNodes.count-1 collect (myNodes.itemOf[i].getElementsByTagName "PartName").itemOf[0].attributes.itemOf["Spec"].value)		myNormal = (for i = 0 to myNodes.count-1 collect (myNodes.itemOf[i].getElementsByTagName "PartName").itemOf[0].attributes.itemOf["Normal"].value) 		myReflection = (for i = 0 to myNodes.count-1 collect (myNodes.itemOf[i].getElementsByTagName "PartName").itemOf[0].attributes.itemOf["Reflection"].value)				--FindCorrectItem (Gen_List.items[Gen_List.selection]) --Runs function to match xml to selected part				DescripArea.text = "--" + myDescrips[(FindCorrectItem myPartname (Gen_List.items[Gen_List.selection]))]		ProjectArea.text = "Project-- " + myProject[(FindCorrectItem myPartname (Gen_List.items[Gen_List.selection]))]		DiffuseArea.text = myDiffuse[(FindCorrectItem myPartname (Gen_List.items[Gen_List.selection]))]		SpecArea.text = mySpec[FindCorrectItem myPartname (Gen_List.items[Gen_List.selection])]				NormalArea.text = myNormal[(FindCorrectItem myPartname (Gen_List.items[Gen_List.selection]))]			ReflectionArea.text = myReflection[(FindCorrectItem myPartname (Gen_List.items[Gen_List.selection]))]doc = dotNetObject "System.Xml.XmlDocument"doc.LoadXml("<book genre='novel' ISBN='1-861001-57-5'>" +             "<title>Pride And Prejudice</title>" +			"</book>")--Create a new node and add it to the document.--The text node is the content of the price element.elem = doc.CreateElement("price")txt = doc.CreateTextNode("19.95")doc.DocumentElement.AppendChild(elem)doc.DocumentElement.LastChild.AppendChild(txt)XmlWriter = dotNetClass "System.Xml.XmlWriter"stringWriter = dotNetObject "System.IO.StringWriter"mlTextWriter = XmlWriter.Create stringWriterdoc.WriteTo xmlTextWriterxmlTextWriter.Flush()(stringWriter.GetStringBuilder()).ToString()--Create the XmlDocument.XmlDocument doc = new XmlDocument();doc.LoadXml("<item><name>wrench</name></item>");--Add a price element.XmlElement newElem = doc.CreateElement("price");newElem.InnerText = "10.95";doc.DocumentElement.AppendChild(newElem);XmlElement elem = doc.CreateElement("bk", "genre", "urn:samples");elem.InnerText = "fantasy";doc.DocumentElement.AppendChild(elem);And also to read an XML:fn recurseXML docElement =(	tempPTree = #(docElement.name)	tempLayerTree = #(docElement.getAttribute "layer")		for i = 0 to (docElement.childNodes.count - 1) do	(		tmp = (recurseXML docElement.childNodes.itemOf[i])		append tempPTree tmp[1]		append tempLayerTree tmp[2]	)	return #(tempPTree, tempLayerTree))global parentTreeXML = #()global layerTreeXML = #()fn readXML =(	xmlDoc = dotNetObject "System.Xml.XmlDocument"	xmlDoc.load ("C:\\temp\\test.xml") 		docElement = XmlDoc.documentElement		-- if we don't do this here we end up with the root node on parentTreeXML	-- which can be worked out in anoter way also, of course.	for i = 0 to (docElement.childNodes.count - 1) do	(		tmp = (recurseXML docElement.childNodes.itemOf[i])		append parentTreeXML tmp[1]		append layerTreeXML tmp[2]	))*//*<bookstore><book category="COOKING"><title lang="en">Everyday Italian</title><author>Giada De Laurentiis</author><year>2005</year><price>30.00</price></book><book category="CHILDREN"><title lang="en">Harry Potter</title><author>J K. Rowling</author><year>2005</year><price>29.99</price></book><book category="WEB"><title lang="en">XQuery Kick Start</title><author>James McGovern</author><author>Per Bothner</author><author>Kurt Cagle</author><author>James Linn</author><author>Vaidyanathan Nagarajan</author><year>2003</year><price>49.99</price></book><book category="WEB"><title lang="en">Learning XML</title><author>Erik T. Ray</author><year>2003</year><price>39.95</price></book></bookstore>xmlDoc = dotNetObject "system.xml.xmlDocument"xmlDoc.load @"somepathBookstore.xml"--1 Get all booksmyNodes = xmlDoc.selectNodes "//book"--2 Get all childnodes of the bookstore elementmyNodes = xmlDoc.selectNodes "/bookstore/*"--3 Get all authors of all booksmyNodes = xmlDoc.selectNodes "//book/author"--4 Get all authors of books from 2005myNodes = xmlDoc.selectNodes "//book[year='2005']/author"--4a do the same but the year is a variable yearVariable = 2005myNodes = xmlDoc.selectNodes ("//book[year='" + (yearVariable as string) + "']/author")--5 Get all books from 2005myNodes = xmlDoc.selectNodes "//book[year='2005']"--6 Get all books from 2003 cheaper than 45.00myNodes = xmlDoc.selectNodes "//book[year='2003' and price<'45']" --In examples 3 and 4 you do something like this to get the actual text of the xml-element in an arraymyAuthors = (for i = 0 to myNodes .count-1 collect myNodes .itemOf[i].innertext)--In examples 1, 2, 5 and 6 you get an xml-element with child-elements. Do something like this to get a specific child-elementmyPrices = (for i = 0 to myNodes.count-1 collect (myNodes.itemOf[i].getElementsByTagName "price").itemOf[0].innertext)*//*StringWriter = dotNetObject "System.IO.StringWriter"penDotNet.show StringWriter-- Create XmlWriterSettings and fill infoXmlWriterSettings = dotNetObject "System.Xml.XmlWriterSettings"XmlWriterSettings.Indent = trueXmlWriterSettings.indentChars="	"XmlWriterSettings.OmitXmlDeclaration = falseXmlWriterSettings.NewLineOnAttributes = false-- Create new XmlWriter in the StringWriter with the specified settingsXmlWriter=dotNetClass "system.xml.xmlWriter"Writer = XmlWriter.Create StringWriter XmlWriterSettings-- Write the documentWriter.WriteStartElement "XMLUI" 	Writer.WriteValue "This is a test" --COMMENT and re run	Writer.WriteStartElement "TAB"	Writer.WriteAttributeString "Name" "Temp"	Writer.WriteAttributeString "BackGround" ""		Writer.WriteStartElement "UI" ""		Writer.WriteAttributeString "Test" "12345"-- 	Writer.WriteEndElement() --Don't realy need to set the end element as it does it for you. -- Writer.WriteEndElement()-- Release Xml resourcesWriter.Flush()Writer.Close()xmlString=StringWriter.ToString()fn reformatXml xml Writer: =(	doFlush=false	if Writer==unsupplied do 	(		StringWriter=dotNetObject "System.IO.StringWriter"		XmlWriterSettings = dotNetObject "System.Xml.XmlWriterSettings"		XmlWriterSettings.Indent = true		XmlWriterSettings.indentChars="	"		XmlWriterSettings.OmitXmlDeclaration = false		XmlWriterSettings.NewLineOnAttributes = false		XmlWriter=dotNetClass "system.xml.xmlWriter"		Writer = XmlWriter.Create StringWriter XmlWriterSettings		doFlush=true	)		case xml.name of	(		"#document": () --Do nothing		"xml": () --Do nothing		"#comment":		(			Writer.WriteComment xml.value		)		"#text":		(			Writer.writeValue xml.value		)		default:		(			Writer.WriteStartElement xml.name			for i = 0 to xml.Attributes.count-1 do			(				val=xml.getAttribute xml.Attributes.item[i].name				Writer.WriteAttributeString xml.Attributes.item[i].name val			)		)	)		for i = 0 to xml.childNodes.count-1 do 	(		reformatXml xml.childNodes.item[i] Writer:writer StringWriter:StringWriter	)		if doFlush do	(		Writer.Flush()		Writer.Close()	)		StringWriter)--TestxmlDoc=dotNetObject "system.xml.xmlDocument"xmlStr="<?xml version=\"1.0\" encoding=\"UTF-8\"?>           <!--This is a comment--><XMLUI Name=\"Fred\"><TAB Name=\"Face\"><UI /><!--This is a Button below-->					<BUTTON Name=\"Reset\" /><INNERTEXT>This is Inner Text</INNERTEXT></TAB></XMLUI>"xmlDoc.loadXml xmlStrclearListener()xmlStr=reformatXml xmlDocxmlStr.toString()xdoc = (dotNetclass "System.Xml.Linq.XDocument").Parse xmlStrxdoc.ToString()(dotnetobject "system.xml.linq.XDeclaration" "1.0" "utf-8" "").tostring() + "" + xdoc.ToString()*/