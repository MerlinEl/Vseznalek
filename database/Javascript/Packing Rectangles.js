https://github.com/mapbox/potpack/blob/master/index.mjsexport default function potpack(boxes) {    // calculate total box area and maximum box width    let area = 0;    let maxWidth = 0;    for (const box of boxes) {        area += box.w * box.h;        maxWidth = Math.max(maxWidth, box.w);    }    // sort the boxes for insertion by height, descending    boxes.sort((a, b) => b.h - a.h);    // aim for a squarish resulting container,    // slightly adjusted for sub-100% space utilization    const startWidth = Math.max(Math.ceil(Math.sqrt(area / 0.95)), maxWidth);    // start with a single empty space, unbounded at the bottom    const spaces = [{x: 0, y: 0, w: startWidth, h: Infinity}];    let width = 0;    let height = 0;    for (const box of boxes) {        // look through spaces backwards so that we check smaller spaces first        for (let i = spaces.length - 1; i >= 0; i--) {            const space = spaces[i];            // look for empty spaces that can accommodate the current box            if (box.w > space.w || box.h > space.h) continue;            // found the space; add the box to its top-left corner            // |-------|-------|            // |  box  |       |            // |_______|       |            // |         space |            // |_______________|            box.x = space.x;            box.y = space.y;            height = Math.max(height, box.y + box.h);            width = Math.max(width, box.x + box.w);            if (box.w === space.w && box.h === space.h) {                // space matches the box exactly; remove it                const last = spaces.pop();                if (i < spaces.length) spaces[i] = last;            } else if (box.h === space.h) {                // space matches the box height; update it accordingly                // |-------|---------------|                // |  box  | updated space |                // |_______|_______________|                space.x += box.w;                space.w -= box.w;            } else if (box.w === space.w) {                // space matches the box width; update it accordingly                // |---------------|                // |      box      |                // |_______________|                // | updated space |                // |_______________|                space.y += box.h;                space.h -= box.h;            } else {                // otherwise the box splits the space into two spaces                // |-------|-----------|                // |  box  | new space |                // |_______|___________|                // | updated space     |                // |___________________|                spaces.push({                    x: space.x + box.w,                    y: space.y,                    w: space.w - box.w,                    h: box.h                });                space.y += box.h;                space.h -= box.h;            }            break;        }    }    return {        w: width, // container width        h: height, // container height        fill: (area / (width * height)) || 0 // space utilization    };}//https://blackpawn.com/texts/lightmaps/default.html//Pretty basic. The implementation of the tree is straightforward. Here it is in a C++ pseudocode hybrid:struct Node{    Node* child[2]    Rectangle rc    int imageID}    Node* Node::Insert(const Image& img)    if we're not a leaf then        (try inserting into first child)        newNode = child[0]->Insert( img )        if newNode != NULL return newNode                (no room, insert into second)        return child[1]->Insert( img )    else        (if there's already a lightmap here, return)        if imageID != NULL return NULL        (if we're too small, return)        if img doesn't fit in pnode->rect            return NULL        (if we're just right, accept)        if img fits perfectly in pnode->rect            return pnode                (otherwise, gotta split this node and create some kids)        pnode->child[0] = new Node        pnode->child[1] = new Node                (decide which way to split)        dw = rc.width - img.width        dh = rc.height - img.height                if dw > dh then            child[0]->rect = Rectangle(rc.left, rc.top,                                        rc.left+width-1, rc.bottom)            child[1]->rect = Rectangle(rc.left+width, rc.top,                                        rc.right, rc.bottom)        else            child[0]->rect = Rectangle(rc.left, rc.top,                                        rc.right, rc.top+height-1)            child[1]->rect = Rectangle(rc.left, rc.top+height,                                        rc.right, rc.bottom)                (insert into first child we created)        return Insert( img, pnode->child[0] )The insert function traverses the tree looking for a place to insert the lightmap. It returns the pointer of the node the lightmap can go into or null to say it can't fit. Note that you really don't have to store the rectangle for each node, really all you need is a split direction and coordinate like in a kd-tree, but it's more convenient with them.The code that calls Insert can then use the rectangle from the returned node to figure out where to place the lightmap in the texture and then update the node's imageID to use as a handle for future use.int32 TextureCache::Insert(const Image& img)    pnode = m_root->Insert(img)    if pnode != NULL        copy pixels over from img into pnode->rc part of texture        pnode->imageID = new handle    else       return INVALID_HANDLEOnce the lightmap is in the larger texture, you'll want to go through any meshes that use it and adjust their texture coordinates based on the lightmap's rectangle in the larger texture.And now your moment of zen://OR//https://observablehq.com/@mourner/simple-rectangle-packing//very nice oneboxes = Array(746) [  0: Object {w: 80, h: 400, hue: 200}  1: Object {w: 250, h: 250, hue: 127}  2: Object {w: 100, h: 100, hue: 136}  3: Object {w: 100, h: 100, hue: 42}  4: Object {w: 100, h: 100, hue: 335}  5: Object {w: 100, h: 100, hue: 356}  6: Object {w: 100, h: 100, hue: 209}  7: Object {w: 100, h: 100, hue: 155}  8: Object {w: 100, h: 100, hue: 268}  9: Object {w: 100, h: 100, hue: 350}  10: Object {w: 100, h: 100, hue: 259}  11: Object {w: 250, h: 100, hue: 182}  12: Object {w: 60, h: 60, hue: 49}  13: Object {w: 60, h: 60, hue: 200}  14: Object {w: 60, h: 60, hue: 197}  15: Object {w: 60, h: 60, hue: 307}  16: Object {w: 60, h: 60, hue: 289}  17: Object {w: 20, h: 50, hue: 51}  18: Object {w: 20, h: 50, hue: 303}  19: Object {w: 20, h: 50, hue: 289}  20: Object {w: 20, h: 50, hue: 273}  21: Object {w: 20, h: 50, hue: 296}  22: Object {w: 20, h: 50, hue: 135}  23: Object {w: 20, h: 50, hue: 40}  24: Object {w: 20, h: 50, hue: 197}  25: Object {w: 20, h: 50, hue: 229}  26: Object {w: 20, h: 50, hue: 311}  27: Object {w: 20, h: 50, hue: 160}  28: Object {w: 20, h: 50, hue: 53}  29: Object {w: 20, h: 50, hue: 191}  30: Object {w: 20, h: 50, hue: 232}  31: Object {w: 20, h: 50, hue: 207}  32: Object {w: 20, h: 50, hue: 66}  33: Object {w: 20, h: 50, hue: 116}  34: Object {w: 20, h: 50, hue: 166}  35: Object {w: 20, h: 50, hue: 231}  36: Object {w: 20, h: 50, hue: 356}  37: Object {w: 20, h: 50, hue: 163}  38: Object {w: 20, h: 50, hue: 295}  39: Object {w: 20, h: 50, hue: 314}  40: Object {w: 20, h: 50, hue: 236}....}result = {  // calculate total box area and maximum box width  let area = 0;  let maxWidth = 0;  for (const box of boxes) {    area += box.w * box.h;    maxWidth = Math.max(maxWidth, box.w);  }  // sort the boxes for insertion by height, descending  boxes.sort((a, b) => b.h - a.h);  // aim for a squarish resulting container,  // slightly adjusted for sub-100% space utilization  const startWidth = Math.max(Math.ceil(Math.sqrt(area / 0.95)), maxWidth);  // start with a single empty space, unbounded at the bottom  const spaces = [{x: 0, y: 0, w: startWidth, h: Infinity}];  const packed = [];  for (const box of boxes) {    // look through spaces backwards so that we check smaller spaces first    for (let i = spaces.length - 1; i >= 0; i--) {      const space = spaces[i];      // look for empty spaces that can accommodate the current box      if (box.w > space.w || box.h > space.h) continue;      // found the space; add the box to its top-left corner      // |-------|-------|      // |  box  |       |      // |_______|       |      // |         space |      // |_______________|      packed.push(Object.assign({}, box, {x: space.x, y: space.y}));      if (box.w === space.w && box.h === space.h) {        // space matches the box exactly; remove it        const last = spaces.pop();        if (i < spaces.length) spaces[i] = last;      } else if (box.h === space.h) {        // space matches the box height; update it accordingly        // |-------|---------------|        // |  box  | updated space |        // |_______|_______________|        space.x += box.w;        space.w -= box.w;      } else if (box.w === space.w) {        // space matches the box width; update it accordingly        // |---------------|        // |      box      |        // |_______________|        // | updated space |        // |_______________|        space.y += box.h;        space.h -= box.h;      } else {        // otherwise the box splits the space into two spaces        // |-------|-----------|        // |  box  | new space |        // |_______|___________|        // | updated space     |        // |___________________|        spaces.push({          x: space.x + box.w,          y: space.y,          w: space.w - box.w,          h: box.h        });        space.y += box.h;        space.h -= box.h;      }      break;    }    yield {packed, spaces};  }}