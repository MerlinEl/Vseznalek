private function processStandardOut():void{	// Check first 4 bytes for start code	var first4:int = process.standardOutput.readUnsignedInt(); 	if (first4 == PROCESS_STARTCODE)	{		// error check		if (process.standardOutput.bytesAvailable < 8) {			trace('Header appears to be split between packets. Ignoring rather than writing extra logic.');			return;		}				_startReceiveTimestamp = new Date().getTime();		// trace('Time waiting for response: ', _startReceiveTimestamp - _startRequestTimestamp);				_imageWidth = process.standardOutput.readInt();		_imageHeight = process.standardOutput.readInt();				_expectedImageLength = _imageWidth * _imageHeight * 4;				_imageData = new ByteArray();		_imageData.endian = Endian.LITTLE_ENDIAN;				if (process.standardOutput.bytesAvailable == 0) return; // (expected behavior)	} 	else // ... that first longword is part of the real image data, so write it to our ByteArray	{		_imageData.writeInt(first4);	}	// Write the remainder of the stdout data to the ByteArray	process.standardOutput.readBytes(_imageData, _imageData.length);	// Check last 4 bytes for termination code	_imageData.position = _imageData.length - 4;	var last4:int = _imageData.readUnsignedInt();		if (last4 == PROCESS_ENDCODE) 	{		_imageData.length = _imageData.length - 4; // .. remove endcode from bytearray		_isReceivingData = false;				if (_imageData.length != _expectedImageLength) trace("Image not of expected length: ", _imageData.length, "versus", _expectedImageLength);				// trace('Time taken to transfer data: ', new Date().getTime() - _startReceiveTimestamp);				drawImage(_imageData);	}} 