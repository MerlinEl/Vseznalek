package classes {	import flash.display.MovieClip;	import flash.net.URLLoader;	import flash.net.URLRequest;	import flash.net.URLLoaderDataFormat;	import flash.events.Event;	import flash.geom.Rectangle;	import flash.text.TextFormat;	import flash.display.Stage;	import flash.utils.Timer; 	import flash.events.TimerEvent; 		public class Master_Photo extends MovieClip	{			public var STAGE:Stage;		private var urlLoader:URLLoader;		private var root_dir:String = "photos";		private var sub_dir:String = "";		private var image_list_file:String=root_dir+"/names_list.txt";		private var image_list_names:Array = [];		private var tf_1:TextFormat = new TextFormat();		private var canvas_rect:Rectangle = new Rectangle(0, 0, 950, 670)		private var total_images:Number = 0;		private var current_image:Number = 0;		private var MM:Master_Image = new Master_Image();		private var slide_timer:Timer = new Timer(3000); //3 second timer				public function Master_Photo() {						tf_1.color = 0x0066CC; 			tf_1.size = 18; 			tf_1.font = "Arial"; 			tf_1.align = "center"; 			num_interval.setStyle("textFormat", tf_1);			addEventListener(Event.ADDED_TO_STAGE, init);		};		private function init(e:Event):void{			clearCanvas();			collectImages("str_32", 1); //temp this will be called externally //str_61			removeEventListener(Event.ADDED_TO_STAGE, init);			STAGE = stage;		};		public function collectImages(dir:String, show:Number):void{						sub_dir = dir;			current_image = show;			urlLoader = new URLLoader();			urlLoader.dataFormat=URLLoaderDataFormat.VARIABLES;			urlLoader.addEventListener(Event.COMPLETE, onLoaded);			urlLoader.load(new URLRequest(image_list_file));		};		private function onLoaded(e:Event):void {					trace("load list complete.")			urlLoader.removeEventListener(Event.COMPLETE, onLoaded);			var filtered_data = filterData(e.target.data)  //removing whitespace			//trace("get dir:"+sub_dir+" from data:"+filtered_data);			image_list_names = filtered_data[sub_dir].split(",");			if (image_list_names.length == 0)  return;			total_images = image_list_names.length;			photo_counter.text = "1 / "+total_images;			photo_title.text = image_list_names[current_image].split(".")[0];			var fname:String = root_dir+"/"+sub_dir+"/"+image_list_names[current_image];			MM.loadImage(photo_canvas, fname, canvas_rect); 		};		private function filterData(vars:*):Object{  						var varObject:Object = {};  			 for (var prop:String in vars)  			 {  				  //trace(prop.replace(/^\W+/, ""), vars[prop]);  				  varObject[prop.replace(/^\W+/, "")] = vars[prop];  			 }  			return varObject;		}		private function clearCanvas():void{					//trace("num children:"+photo_canvas.numChildren);			while (photo_canvas.numChildren > 0) photo_canvas.removeChildAt(0);		};		private function onTick(e:TimerEvent):void { 						if (image_list_names[current_image+1] == null) { //end reached							slide_timer.removeEventListener(TimerEvent.TIMER, onTick); 				slide_timer.stop();				btn_auto.gotoAndStop(1); btn_auto.switch_on = false;						} else nextImage();			trace("auto slide state: " + e.target.currentCount); 		} 		public function nextImage():void {						if (image_list_names[current_image+1] == null) return; //end reached			clearCanvas();			// trace("NEXT IMAGE:"+image_list_names[current_image+1]);			current_image++;			photo_counter.text = (current_image+1)+" / "+total_images;			photo_title.text = image_list_names[current_image].split(".")[0];			var fname:String = root_dir+"/"+sub_dir+"/"+image_list_names[current_image];						MM.loadImage(photo_canvas, fname, canvas_rect); 		};		public function prevImage():void {						if (current_image <= 0) return; //end reached			clearCanvas();			//trace("PREV IMAGE:"+image_list_names[current_image-1]);			current_image--;			photo_counter.text = (current_image+1)+" / "+total_images;			photo_title.text = image_list_names[current_image].split(".")[0];			var fname:String = root_dir+"/"+sub_dir+"/"+image_list_names[current_image];						MM.loadImage(photo_canvas, fname, canvas_rect); 		};		public function autoSlide(switch_on:Boolean):void {					stage.focus = stage;			if (!switch_on){							slide_timer.removeEventListener(TimerEvent.TIMER, onTick); 				slide_timer.stop();				trace("AUTO SLIDE STOP");				return;			}			slide_timer.delay = num_interval.value*1000;			slide_timer.addEventListener(TimerEvent.TIMER, onTick); 			slide_timer.start()			trace("AUTO SLIDE START");		};		public function exitPlayer():void {					 trace("EXIT APP");			var loader = parent.parent.parent;			if (loader != null) loader.unloadSWF();		};	}; //class}; //packagepackage classes {	import flash.events.Event;	import flash.events.ProgressEvent;	import flash.events.IOErrorEvent;	import flash.events.HTTPStatusEvent;	import flash.net.URLRequest;	import flash.display.Loader;	import flash.display.Bitmap;	import flash.geom.Matrix;	import flash.display.BitmapData;	import flash.display.MovieClip;	import flash.geom.Rectangle;	import com.greensock.TweenLite;		public class Master_Image {		private var loader:Loader =new Loader();		private var mc_canvas:MovieClip;		private var counter:uint = 0;		private var fit_rect:Rectangle;			public function Master_Image() {					trace("Initialize Master Image class...");		};		public function loadImage(canvas:MovieClip, fname:String, canvas_rect:Rectangle):void{			trace("Calling Master Image class... ");			trace("loading image:["+fname+"] in to:"+canvas.name);			mc_canvas = canvas;			fit_rect = canvas_rect;			var urlRequest:URLRequest = new URLRequest(fname);			loader.contentLoaderInfo.addEventListener(ProgressEvent.PROGRESS, onProgress, false, 0 ,true);			loader.contentLoaderInfo.addEventListener(Event.COMPLETE, loaderOnComplete, false, 0 ,true);			loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, onError);			loader.contentLoaderInfo.addEventListener(HTTPStatusEvent.HTTP_STATUS, onStatus);			loader.load(urlRequest);		}		private function onProgress(event:ProgressEvent):void{			//var percent:Number = event.bytesLoaded/event.bytesTotal *100;			//trace( "Loading: " + (Math.ceil(percent)).toString() + " % ");		}		private function loaderOnComplete(event:Event):void{					trace("load image complete.")			loader.contentLoaderInfo.removeEventListener(ProgressEvent.PROGRESS, onProgress);			loader.contentLoaderInfo.removeEventListener(Event.COMPLETE, loaderOnComplete);			var bitmap:Bitmap = Bitmap(event.target.content);			 //if image is bigger or smaller resize it to fit canvas			if ( bitmap.width > fit_rect.width || bitmap.height > fit_rect.height ||  bitmap.width < fit_rect.width && bitmap.height < fit_rect.height ){								fitBitmapProportionaly(bitmap, fit_rect.width, fit_rect.height)			}			bitmap.x -= bitmap.width/2;   //center x			bitmap.y -= bitmap.height/2; //center y						mc_canvas.alpha = 0;			mc_canvas.addChild(bitmap);			TweenLite.to(mc_canvas, 1.5, { alpha:1} ); //fade in			loader.unload();		};		private function onStatus(e:HTTPStatusEvent):void{			trace(e.status);		};		private function onError(e:IOErrorEvent):void{			trace( e.text);		};		private function bitmapScale(bmp:Bitmap, pos_x:Number, pos_y:Number, w:Number, h:Number):Bitmap{			var mat:Matrix = new Matrix();			mat.scale(w/bmp.width, h/bmp.height); //rescale			mat.translate( pos_x , pos_y ); //move image			var draw_bd:BitmapData = new BitmapData(w, h, true, 0x00000000);			draw_bd.draw(bmp, mat, null, null, null, true);			return new Bitmap (draw_bd);		};		private function fitBitmapProportionaly( bmp:Bitmap, max_w, max_h ) : void{					trace("Resizing Proportionaly...")			var ratio = bmp.height/bmp.width;//calculation ratio			if (bmp.width>max_w) { //scale down				bmp.width = max_w;				bmp.height = Math.round(bmp.width*ratio);			}			if (bmp.height>max_h) {//scale down				bmp.height = max_h;				bmp.width = Math.round(bmp.height/ratio);			}			if (bmp.height<max_h && bmp.width<max_w) {//scale up							if (bmp.width > bmp.height){									bmp.width = max_w;					bmp.height = Math.round(bmp.width*ratio);									} else {									bmp.height = max_h;					bmp.width = Math.round(bmp.height/ratio);				}			}		};	}//class}//package