/*Where to put this Code?You saw the code example above, but, where do you put it? Since I decided to use a helper function(addMethodsTo), the code cannot be directly pasted inside the class scope of a class unless the addMethodsTo function is declared to be static(you can only make a method call directly inside class scope if it is a class method). As, a general solution, I'd rather the code be portable. So it should be includable in both class and function scope, and also, I'd like it not to pollute any namespaces.My current solution is to put this bit of code inside an anonymous function which immediately gets executed:File: Array.as--------------------------------------------------(function(){	    include 'addMethodsTo.as';	    addMethodsTo(Array, {	        collect: function(f){	            var ret = [];	            for each(var it in this) ret.push(f(it));	            return ret;	        }	    });	})();-----------------------------------------------------Call: include 'includes/Array.as';*///PROTOTYPING ARRAYaddMethodsTo(Array, {    collect: function(f){        var ret = [];        for each(var it in this) ret.push(f(it));        return ret;    },    biggerThan: function(num){        var ret = [];		for each(var it in this) if (it > num ) ret.push(it);		return ret;    }});var arr_1:Array = [1,2,3,4,5,6,7,8,9,10];var arr_2:Array = arr_1.biggerThan(4);ftrace("arr_1:	%",arr_1);ftrace("arr_2:	%",arr_2);//PROTOTYPING OBJECTaddMethodsTo(Object, {		min: 0,	max: 0,	length: function() {	   var ret = 0;	   for (var key in this) ret++; 	   return ret;    }});var obj_1:Object = new Object();ftrace("obj_1:%	len:%",obj_1.min, obj_1.length());// ADD METHODS FUNCTIONfunction addMethodsTo(cls:Class, methods:*, enum:Boolean = false){    for (var name:String in methods){        cls.prototype[name] = methods[name];        cls.prototype.setPropertyIsEnumerable(name, enum);    }}/*//creates get/set properties inside an object's protofunction prop (propname, getfn, setfn) {    var obj = {};    obj[propname] = { get: getfn, set: setfn };    Object.defineProperties(this, obj);        }*///give you a list of properties on an object./*flash.utils.describeType(value:*)ObjectUtil.getClassInfo(object) *///OTHERObject.prototype.isEmpty = function():Boolean {    for(var i in this)    	if(i != "isEmpty")    		return false    return true}var p = {};trace(p.isEmpty()); // truevar p2 = {a:1}trace(p2.isEmpty()); // false´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´	String.prototype.replaceAll = function (replaceThis, withThis) {   var re = new RegExp(replaceThis,"g");    return this.replace(re, withThis);};var aa = "abab54..aba".replaceAll("\\.", "v");´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´	      Object.prototype.__defineGetter__("pos", function () {	return [this.x, this.y];	});	Object.prototype.__defineSetter__("pos", function (point) {		this.x = point[0];		this.y = point[1];	});     sel[0].posi = sel[1].pos´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´Object.prototype.addMethod = function(name, pMethod) {  this.prototype[name] = pMethod;}Function.prototype.addMethod = function(name, pMethod) {  this.prototype[name] = pMethod;}Object.addMethod( "getShortName", function() {  return this.name.split("/").pop();});/*  NOTE: SymbolItem.addMethod was causing a bug, so Object, although it's generic,  seems like the best choice.*/fl.trace( fl.getDocumentDOM().library.items[0].getShortName() );´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´SymbolItem.prototype.__defineGetter__('shortName', function(element){ return this.name.split('/').pop(); })SymbolItem.prototype.__defineGetter__('path', function(element){ return this.name; })trace(fl.getDocumentDOM().library.items[0].shortName);´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´function Lost () {	// Constructor}Lost.prototype = {    get location (){        return this.loc;    },    set location (val){        this.loc = val;    }};var lostIsland = new Lost();lostIsland.location = "Somewhere in time";´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´ import flash.display.Sprite;var c:Class;c = new Sprite()["constructor"];trace(1,new c());trace(2,c);trace(3,new c());´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´//DynamicClass.aspackage imost {	public var name:String;		public dynamic class DynamicClass{		}}var lostIsland:DynamicClass = new DynamicClass();lostIsland.location = "Somewhere in time";lostIsland.power = function(num:Number, pow:Number):Number {		return Math.pow(num, pow); };ftrace("Lost:%", lostIsland.location);ftrace("pow:%", lostIsland.power(4, 2));