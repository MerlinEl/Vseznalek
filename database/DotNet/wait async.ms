-- this function will delay further script execution by defined time in millisecondsfn pauseScript msec = (	global msec = timestamp() + msec		if msec != undefined then (		if msec as integer > 0 then (						rollout pauseScriptModalRollout ""				(					timer delay interval:25 active:false										on pauseScriptModalRollout open do (												delay.active = true											)										on delay tick do (												if timestamp() >= ::msec then (														delay.active = false							globalvars.remove "msec"							DestroyDialog pauseScriptModalRollout													)											)				)							createdialog pauseScriptModalRollout modal:true pos:[-666,-666]					)	)	)-- function will pause further script execution until given expression return true fn pauseUntil expression = (		global pause_expr = expression				rollout pauseScriptUntilModalRollout ""		(			timer delay interval:50 active:false						on pauseScriptUntilModalRollout open do (								delay.active = true							)						on delay tick do (														if  execute ::pause_expr == true then (										delay.active = false					globalvars.remove "pause_expr"					DestroyDialog pauseScriptUntilModalRollout									) 							)		)			createdialog pauseScriptUntilModalRollout pos:[500,500] modal:true )-- this function will delay further script execution by defined time in millisecondsfn pauseScriptDotNet msec = (	global msec = timestamp() + msec		if msec != undefined then (		if msec as integer > 0 then (						rollout pauseScriptModalRollout ""				(					local t = dotnetobject "System.Windows.Forms.Timer"										fn tick s e = (						if timestamp() >= ::msec then (														s.stop()							globalvars.remove "msec"							DestroyDialog pauseScriptModalRollout						)											)																				on pauseScriptModalRollout open do (												dotnet.addEventHandler t "Tick" tick 						t.interval = 25						t.start()					)									)							createdialog pauseScriptModalRollout modal:true pos:[200,200]					)	)	)format "dotnet timer"(global t1=timestamp()	pauseScriptDotNet 2000format "Time: %sec." ((timestamp()-t1)/1000 as float))format "max timer"(global t1=timestamp()	pauseScript 2000format "Time: %sec." ((timestamp()-t1)/1000 as float))---------------------------------------(	clearListener()		--this .net class sets up async downloads	local strAssembly = "using System.Collections.Generic;using System.IO;using System.Net.Http;using System.Threading.Tasks;namespace Downloader{    public class Download    {        //http://codereview.stackexchange.com/questions/18519/real-world-async-and-await-code-example        public static async Task DownloadFileAsync(string remoteUrl, string localUrl)        {            HttpClient client = new HttpClient();            HttpResponseMessage responseMessage = await client.GetAsync(remoteUrl).ConfigureAwait(false);            var byteArray = await responseMessage.Content.ReadAsByteArrayAsync().ConfigureAwait(false);            using (FileStream filestream = new FileStream(localUrl, FileMode.Create, FileAccess.Write, FileShare.None, bufferSize:4096, useAsync:true))            {                await filestream.WriteAsync(byteArray, 0, byteArray.Length);            }        }        public static async Task DownloadMultipleFilesAsync(string remoteUrl, string localFolder, int downloadTimes)        {            List<Task> allTasks = new List<Task>();            for (int n = 0; n < downloadTimes; n++)            {                string localUrl = Path.Combine(localFolder, n.ToString());                localUrl = Path.ChangeExtension(localUrl, (Path.GetExtension(remoteUrl)));                allTasks.Add(DownloadFileAsync(remoteUrl, localUrl));            }            await Task.WhenAll(allTasks).ConfigureAwait(false);        }    }}"	function fn_loadClass strAssembly =	(		/*<FUNCTION>		Description			Loads a .net class from a string		Arguments		Return			compilerResults which can be instanciated		<FUNCTION>*/		local csharpProvider = dotnetobject "Microsoft.CSharp.CSharpCodeProvider"		local compilerParams = dotnetobject "System.CodeDom.Compiler.CompilerParameters"		compilerParams.ReferencedAssemblies.AddRange #("System.Net.Http.dll","System.dll", "System.Management.dll")		compilerParams.GenerateInMemory = on		local compilerResults = csharpProvider.CompileAssemblyFromSource compilerParams #(strAssembly)	)			local compilerResults = fn_loadClass strAssembly	local Download = compilerResults.CompiledAssembly.CreateInstance "Downloader.Download"	local remoteUrl = @"http://a.tile.openstreetmap.org/8/131/84.png"; --we'll download this file	local  localFolder = (dotnetClass "system.IO.Path").Combine (pathConfig.removePathLeaf (getSourceFileName())) "output"	makeDir localFolder	local downloadTasks = 10 --this is the number of times we'll download the file concurrently	local theTask = Download.DownloadMultipleFilesAsync remoteUrl localFolder downloadTasks			--we need to wait for the async download task to finish, otherwise we might get in trouble with the rest of the script. If we don't	--wait, we're counting on the files to be downloaded while they might not be there yet.	theTask.Wait()			local arrFile = getFiles (localFolder + @"\*.png")	format "Downloaded % files" arrFile.count)