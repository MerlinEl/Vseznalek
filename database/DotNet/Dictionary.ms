--(1)stringAQN= (dotnet.gettype "System.String").AssemblyQualifiedNamellist = dotnetobject ("System.Collections.Generic.LinkedList`1[[" + stringAQN + "]]")llist.AddFirst "AAA"llist.AddFirst "BBB"linkC = llist.AddLast "CCC"it = llist.GetEnumerator()while it.MoveNext() do format "it.current = %" it.currentllist.AddBefore linkC "xxx"it = llist.GetEnumerator()while it.MoveNext() do format "it.current = % " it.currentllist.Remove (llist.Find "AAA")it = llist.GetEnumerator()while it.MoveNext() do format "it.current = % " it.current--(2)	struct MICRA_DICTIONARY (				HashTbl = dotNetObject "System.Collections.Hashtable",			fn add key val = (						local key_str = dotNetObject "System.String" key			local val_by_type = case (classOf val) of (				Integer:dotNetObject "System.Int32" val					Float:dotNetObject "System.Float" val					String:dotNetObject "System.String" val				--Array:dotNetObject "System.Array" val				--BitArray:dotNetObject "System.BitArray" val				--Point2:				--Point3:			)							HashTbl.Add key_str val val_by_type			--HashTbl.Add (dotNetObject "System.String" key) (dotNetObject "System.Object" val)		),		fn get key = (						HashTbl.Item[dotNetObject "System.String" key]		)	)	mcDict = MICRA_DICTIONARY()	mcDict.add "first" 123	mcDict.add "first" 25.3	mcDict.add "first" 123	mcDict.add "first" 123	mcDict.add "first" 123	mcDict.get "first"  56				HashTbl.Add (dotNetObject "System.Int32" 1) (dotNetObject "System.String" "First Entry")	HashTbl.Add (dotNetObject "System.String" "Two") (dotNetObject "System.String" "Second Entry")		clearListener()		format "1 : %\n" HashTbl.Item[dotNetObject "System.Int32" 1]	format "Two : %\n" HashTbl.Item[dotNetObject "System.String" "Two"]	format "Properties :"	showProperties HashTbl	format "----------------------------------------------\n"	format "Methods :\n"	showMethods HashTbl	   Properties :  .Count : <System.Int32>, read-only  .IsFixedSize : <System.Boolean>, read-only  .IsReadOnly : <System.Boolean>, read-only  .IsSynchronized : <System.Boolean>, read-only  .Item[<System.Object>key] : <System.Object>  .Keys : <System.Collections.ICollection>, read-only  .SyncRoot : <System.Object>, read-only  .Values : <System.Collections.ICollection>, read-only(	hd = dotNetObject "System.Collections.Specialized.HybridDictionary"	fileNames = for i = 1 to 20	collect "abc_"+i as string+".wm"		fullPaths = for i = 1 to 20	collect "c:\\temp\\abc_"+i as string+".wm"	fewFiles = for i = 1 to 10 by 2	collect "abc_"+i as string+".wm"		--ADD***	gc() ; t1 = timestamp() ; m1 = heapfree	for i in 1 to fileNames.count where not (hd.Contains fileNames[i]) do hd.Add fileNames[i] fullPaths[i]	format "Adding Method > time:% memory:%" ((timestamp()- t1 as float)/1000) (m1-heapfree)	--FIND***	gc() ; t1 = timestamp() ; m1 = heapfree	for p in fewFiles collect hd.item[p]	format "Finding Method > time:% memory:%" ((timestamp()- t1 as float)/1000) (m1-heapfree))hd = dotNetObject "System.Collections.Specialized.HybridDictionary"hd.Add "aaa" 123hd.Add "aab" 1.2hd.Add "aac" [1,56] -- Unable to convert: [1,56] to type: System.Objecthd.Add "aad" #(1,2,3)hd.Add "aae" #{5..9} -- Unable to convert: #{5..9} to type: System.Objecthd.Add "aae" (dotNetObject "System.BitArray" #{5..9}) -- Unable to convert: #{5..9} to type: System.Objecthd.Add "aae" (dotNetObject "System.Collections" #{5..9}) -- Unable to convert: #{5..9} to type: System.Objecthd.Add "aaf" "test"hd.Add "aag"  [1,56, 45] -- Unable to convert: [1,56,45] to type: System.Object--(3)/*slist = dotnetobject "System.Collections.Generic.List" "System.String"sdict = dotnetobject "System.Collections.Generic.Dictionary"sdict = dotnetobject "System.Collections.Generic.Dictionary" 2[System.String,System.Char]"theList = dotnetobject "System.Collections.arrayList" theList = dotnetobject "System.Collections.arrayList"  ("System.Collections.ICollection" #(1,3,5))*/fn createAssembly src = (		local csharpProvider = dotnetobject "Microsoft.CSharp.CSharpCodeProvider"	local compilerParams = dotnetobject "System.CodeDom.Compiler.CompilerParameters"	compilerParams.CompilerOptions = "/t:library"	compilerParams.GenerateInMemory = true	compilerResults = csharpProvider.CompileAssemblyFromSource compilerParams #(src)		if (compilerResults.Errors.Count > 0 ) then (				errs = stringstream ""		for i = 0 to (compilerResults.Errors.Count-1) do (						err = compilerResults.Errors.Item[i]			format "Error:% Line:% Column:% %" err.ErrorNumber err.Line err.Column err.ErrorText to:errs 		)		MessageBox (errs as string) title: "Errors encountered while compiling C# code"		return undefined	)	a = compilerResults.CompiledAssembly)createAssembly ???class SharpSvnHelpers{    public static Collection<SvnLogEventArgs> CreateCollection()    {        return new Collection<SvnLogEventArgs>();    }}logItems = (dotNetClass "MyAssembly.SharpSvnHelpers").CreateCollection()